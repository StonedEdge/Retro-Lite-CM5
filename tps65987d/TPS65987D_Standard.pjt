
import os
import sys

appcust_path = os.path.abspath(os.path.join('..', 'src'))
sys.path.append(appcust_path)
template_path = "templates"
sys.path.append(template_path)

import register_class
import function_class
import bintable_class
import helper_functions


class cPDOCurrentField(register_class.cScalingDMTerminator):
    def __init__(self, register, iDict):
        register_class.cScalingDMTerminator.__init__(self, register, iDict)
        # map all strings representing units to scale factor
        self.dictScaleUnits = {'': 0.01, 'A': 0.01, 'mA': 10.0}
        self.defaultUnit = 'A'


class cPDOVoltageField(register_class.cScalingDMTerminator):
    def __init__(self, register, iDict):
        register_class.cScalingDMTerminator.__init__(self, register, iDict)
        # map all strings representing units to scale factor
        self.dictScaleUnits = {'': 0.05, 'V': 0.05, 'mV': 50.0}
        self.defaultUnit = 'V'


class cPDOPowerField(register_class.cScalingDMTerminator):
    def __init__(self, register, iDict):
        register_class.cScalingDMTerminator.__init__(self, register, iDict)
        # map all strings representing units to scale factor
        self.dictScaleUnits = {'': 0.25, 'W': 0.25, 'mW': 250.0}
        self.defaultUnit = 'W'


class cPDPPowerField(register_class.cScalingDMTerminator):
    def __init__(self, register, iDict):
        register_class.cScalingDMTerminator.__init__(self, register, iDict)
        # map all strings representing units to scale factor
        self.dictScaleUnits = {'': 1, 'W': 1}
        self.defaultUnit = 'W'


class cOVPVoltageField(register_class.cScalingDMTerminator):
    def __init__(self, register, iDict):
        register_class.cScalingDMTerminator.__init__(self, register, iDict)
        # map all strings representing units to scale factor
        self.dictScaleUnits = {'': 0.32, 'V': 0.32, 'mV': 320.0}
        self.defaultUnit = 'V'
        self.scalingOffset = 12


class cI2CTimeoutField(register_class.cScalingDMTerminator):
    def __init__(self, register, iDict):
        register_class.cScalingDMTerminator.__init__(self, register, iDict)
        # map all strings representing units to scale factor
        self.dictScaleUnits = {'': 25.0, 'mS': 25.0, 'S': 0.025}
        self.defaultUnit = 'mS'
        self.scalingOffset = 1


class cEventDelay500uSField(register_class.cScalingDMTerminator):
    def __init__(self, register, iDict):
        register_class.cScalingDMTerminator.__init__(self, register, iDict)
        # map all strings representing units to scale factor
        self.dictScaleUnits = {'': 0.5, 'mS': 0.5}
        self.defaultUnit = 'mS'


class cEventDelay250uSField(register_class.cScalingDMTerminator):
    def __init__(self, register, iDict):
        register_class.cScalingDMTerminator.__init__(self, register, iDict)
        # map all strings representing units to scale factor
        self.dictScaleUnits = {'': 0.25, 'mS': 0.25}
        self.defaultUnit = 'mS'


class cFRSInitmS(register_class.cScalingDMTerminator):
    def __init__(self, register, iDict):
        register_class.cScalingDMTerminator.__init__(self, register, iDict)
        # map all strings representing units to scale factor
        self.dictScaleUnits = {'': 1, 'mS': 1}
        self.defaultUnit = 'mS'


class cDMFixedSourcePdoArray(register_class.cDataModelArray):
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)
        #
        current = cPDOCurrentField(self.register, {'name': 'Maximum Current',
                                                   'offset': 0,
                                                   'bit length': 10})
        current.help = "The maximum current that can be supplied via this PDO"
        self.addChild(current)

        voltage = cPDOVoltageField(self.register, {'name': 'Voltage',
                                                   'offset': 10,
                                                   'bit length': 10})
        voltage.help = "The voltage sourced by this PDO."
        self.addChild(voltage)

        PeakCurrent = register_class.cListDMTerminator(self.register, {'name': 'Peak Current',
                                                                       'offset': 20,
                                                                       'bit length': 2})
        PeakCurrent.help = """Set the percentage that the Source current can peak over the max before an OCP event occurs."""
        PeakCurrent.setReportList(['100%', '130%', '150%', '200%'])

        self.addChild(PeakCurrent)

        reserved = register_class.cForceSetDMTerminator(self.register, {'name': "reserved",
                                                                        'offset': 22,
                                                                        'bit length': 8,
                                                                        'force value': int(0),
                                                                        'force display': 'reserved, set 0'})

        reserved.setFromInt(0)
        reserved.hide()
        self.addChild(reserved)

        supplyType = register_class.cListDMTerminator(self.register, {'name': 'Supply Type',
                                                                      'offset': 30,
                                                                      'bit length': 2})
        supplyType.help = """Select what type of supply will source this PDO."""
        supplyType.setReportList(['Fixed Source', 'Battery Source', 'Variable Source'])
        supplyType.addUpdateRegisterByName("self")
        supplyType.setMaxValue(2)

        self.addChild(supplyType)


class cDMFixedSinkPdoArray(register_class.cDataModelArray):
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)
        #
        current = cPDOCurrentField(self.register, {'name': 'Operating Current',
                                                   'offset': 0,
                                                   'bit length': 10})
        current.help = "The current to be requested at this PDO"
        self.addChild(current)

        voltage = cPDOVoltageField(self.register, {'name': 'Voltage',
                                                   'offset': 10,
                                                   'bit length': 10})
        voltage.help = "The voltage of this PDO"
        self.addChild(voltage)

        PeakCurrent = register_class.cListDMTerminator(self.register, {'name': 'Peak Current',
                                                                       'offset': 20,
                                                                       'bit length': 2})
        PeakCurrent.help = """Set the percentage that the Sink current can peak over the max before an OCP event occurs."""
        PeakCurrent.setReportList(['100%', '130%', '150%', '200%'])

        self.addChild(PeakCurrent)

        reserved = register_class.cForceSetDMTerminator(self.register, {'name': "reserved",
                                                                        'offset': 22,
                                                                        'bit length': 8,
                                                                        'force value': int(0),
                                                                        'force display': 'reserved, set 0'})

        reserved.setFromInt(0)
        reserved.hide()
        self.addChild(reserved)

        supplyType = register_class.cListDMTerminator(self.register, {'name': 'Supply Type',
                                                                      'offset': 30,
                                                                      'bit length': 2})
        supplyType.help = """Select what type of supply will be attached to this Sink PDO."""
        supplyType.setReportList(['Fixed Sink', 'Battery Sink', 'Variable Sink'])
        supplyType.addUpdateRegisterByName("self")
        supplyType.setMaxValue(2)

        self.addChild(supplyType)

        if ('No RDO Extensions' in iDict) and (iDict['No RDO Extensions'] == True):
            pass
        else:
            maxCurrent = cPDOCurrentField(self.register, {'name': 'Maximum Operating Current',
                                                          'offset': 224,
                                                          'bit length': 10})
            maxCurrent.help = "The maximum current that the sink may request for this PDO."
            self.addChild(maxCurrent)

            minCurrent = cPDOCurrentField(self.register, {'name': 'Minimum Operating Current',
                                                          'offset': 234,
                                                          'bit length': 10})
            minCurrent.help = "The minimum current required for the device to operate within this PDO"
            self.addChild(minCurrent)

            askForMax = register_class.cBooleanDMTerminator(self.register, {'name': 'Ask For Max',
                                                                            'offset': 254,
                                                                            'bit length': 1})
            askForMax.help = "When selected, the sink will request the maximum current the source is capable of supplying at this PDO up to the value specified in the Maximum Operating Current field."
            self.addChild(askForMax)


class cDMSourcePdo1Array(register_class.cDataModelArray):
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)

        if ('Is Receive' in iDict) and (iDict['Is Receive'] == True):
            isReceive = True
        else:
            isReceive = False

        current = cPDOCurrentField(self.register, {'name': 'Maximum Current',
                                                   'offset': 0,
                                                   'bit length': 10})
        current.help = "The maximum current that can be supplied via this PDO"
        self.addChild(current)

        fvDisplayWidget = cPDOVoltageField(self.register, {'name': 'Voltage',
                                                           'offset': 10,
                                                           'bit length': 10})
        fvDisplayWidget.help = "The voltage sourced by this PDO."

        fixedVoltage = register_class.cForceSetDMTerminator(self.register, {'name': 'Voltage',
                                                                            'offset': 10,
                                                                            'bit length': 10,
                                                                            'force value': int(100),
                                                                            'force display': '5 V',
                                                                            'display widget': fvDisplayWidget})

        fixedVoltage.help = """Source PDO1 voltage will always be set to 5V to follow PD Spec."""
        self.addChild(fixedVoltage)
        fixedVoltage.setFromInt(100)

        PeakCurrent = register_class.cListDMTerminator(self.register, {'name': 'Peak Current',
                                                                       'offset': 20,
                                                                       'bit length': 2})

        PeakCurrent.setReportList(['100%', '130%', '150%', '200%'])
        PeakCurrent.help = """Set the percentage that the Source current can peak over the max before an OCP event occurs."""
        self.addChild(PeakCurrent)

        reserved = register_class.cForceSetDMTerminator(self.register, {'name': "reserved",
                                                                        'offset': 22,
                                                                        'bit length': 2,
                                                                        'force value': int(0),
                                                                        'force display': 'reserved, set 0'})

        reserved.setFromInt(0)
        reserved.hide()
        self.addChild(reserved)

        # Dual Role and Externally Powered are overwritten by firmware, so avoid confusion by not listing in GUI

        unchunk = register_class.cBooleanDMTerminator(self.register, {'name': 'Unchunked Extended Msg Supported',
                                                                      'offset': 24,
                                                                      'bit length': 1})
        unchunk.help = "set to true to support extended PD3 messages without using chunking."
        self.addChild(unchunk)

        usbCap = register_class.cBooleanDMTerminator(self.register, {'name': 'USB Capable',
                                                                     'offset': 26,
                                                                     'bit length': 1})
        usbCap.help = "Set to true if the device has USB2 and/or USB3 support."
        self.addChild(usbCap)

        usbSuspend = register_class.cBooleanDMTerminator(self.register, {'name': 'USB Suspend Supported',
                                                                         'offset': 28,
                                                                         'bit length': 1})
        usbSuspend.help = "Set to true if the device may be suspended via USB."
        self.addChild(usbSuspend)

        if ('Is Receive' in iDict) and (iDict['Is Receive'] == True):
            dualData = register_class.cBooleanDMTerminator(self.register, {'name': 'Dual Role Data',
                                                                           'offset': 25,
                                                                           'bit length': 1})
            dualData.help = "Is set to true if device supports UFP and DFP operation"
            self.addChild(dualData)

            extPow = register_class.cBooleanDMTerminator(self.register, {'name': 'Externally Powered',
                                                                         'offset': 27,
                                                                         'bit length': 1})
            extPow.help = "Is set ot true if the device is wall powered."
            self.addChild(extPow)

            dualPow = register_class.cBooleanDMTerminator(self.register, {'name': 'Dual Role Power',
                                                                          'offset': 29,
                                                                          'bit length': 1})
            dualPow.help = "Is set to true if the device may be a source or sink."
            self.addChild(dualPow)

        supplyType = register_class.cListDMTerminator(self.register, {'name': 'Supply Type',
                                                                      'offset': 30,
                                                                      'bit length': 2})
        supplyType.help = """Select what type of supply will source this PDO."""
        supplyType.setReportList(['Fixed Source'])
        supplyType.addUpdateRegisterByName("self")
        supplyType.setMaxValue(0)

        fixedSupplyType = register_class.cForceSetDMTerminator(self.register, {'name': 'Supply Type',
                                                                               'offset': 30,
                                                                               'bit length': 2,
                                                                               'force value': int(0),
                                                                               'force display': 'Fixed Source',
                                                                               'display widget': supplyType})

        fixedSupplyType.help = """Supply Type for PDO0 may only be Fixed."""
        self.addChild(fixedSupplyType)
        fixedSupplyType.setFromInt(0)

    def maxPower(self):
        # 10 mA steps
        current = self.getChildByName('Maximum Current').valueToInt()
        # 50 mV steps
        voltage = self.getChildByName('Voltage').valueToInt()
        # 0.01 * 0.05 = .0005 Watts
        power = current * voltage * 0.0005

        return power


class cDMSinkPdo1Array(register_class.cDataModelArray):
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)

        if ('Is Receive' in iDict) and (iDict['Is Receive'] == True):
            isReceive = True
        else:
            isReceive = False

        current = cPDOCurrentField(self.register, {'name': 'Operating Current',
                                                   'offset': 0,
                                                   'bit length': 10})
        current.help = "The current to be requested at this PDO"
        self.addChild(current)

        fvDisplayWidget = cPDOVoltageField(self.register, {'name': 'Voltage',
                                                           'offset': 10,
                                                           'bit length': 10})
        fvDisplayWidget.help = "The voltage of this PDO"

        fixedVoltage = register_class.cForceSetDMTerminator(self.register, {'name': 'Voltage',
                                                                            'offset': 10,
                                                                            'bit length': 10,
                                                                            'force value': int(100),
                                                                            'force display': '5 V',
                                                                            'display widget': fvDisplayWidget})

        fixedVoltage.help = """Sink PDO1 will always be 5V to be PD Spec compliant."""
        self.addChild(fixedVoltage)
        fixedVoltage.setFromInt(100)

        PeakCurrent = register_class.cListDMTerminator(self.register, {'name': 'Peak Current',
                                                                       'offset': 20,
                                                                       'bit length': 2})
        PeakCurrent.help = """Set the percentage that the Sink current can peak over the max before an OCP event occurs."""
        PeakCurrent.setReportList(['100%', '130%', '150%', '200%'])

        self.addChild(PeakCurrent)

        reserved = register_class.cForceSetDMTerminator(self.register, {'name': "reserved",
                                                                        'offset': 22,
                                                                        'bit length': 1,
                                                                        'force value': int(0),
                                                                        'force display': 'reserved, set 0'})

        reserved.setFromInt(0)
        reserved.hide()
        self.addChild(reserved)

        # Dual Role and Externally Powered are overwritten by firmware, so avoid confusion by not listing in GUI
        # USB capable is set in autonegotiate sink register
        # Higher Capability is set automatically if there are any >5V contracts
        # These are shown in receive registers, but not transmit registers, which are configuration registers

        frsCurrent = register_class.cListDMTerminator(self.register,
                                                      {'name': 'Fast Role Swap required USB Type-C Current',
                                                       'offset': 23,
                                                       'bit length': 2})
        frsCurrent.setReportList(['Fast Swap not Supported', 'Default USB Power', '5V, 1.5A', '5V, 3.0A'])
        frsCurrent.help = "The current that will be supplied by this device if it performs a fast role swap from sink to source."
        self.addChild(frsCurrent)

        if ('Is Receive' in iDict) and (iDict['Is Receive'] == True):
            dualData = register_class.cBooleanDMTerminator(self.register, {'name': 'Dual Role Data',
                                                                           'offset': 25,
                                                                           'bit length': 1})
            dualData.help = "Is set to true of the device supports UFP and DFP."
            self.addChild(dualData)

            usbCapable = register_class.cBooleanDMTerminator(self.register, {'name': 'USB Capable',
                                                                             'offset': 26,
                                                                             'bit length': 1})
            usbCapable.help = "Is set to true if the device supports USB2 and/or USB3 data."
            self.addChild(usbCapable)

            extPow = register_class.cBooleanDMTerminator(self.register, {'name': 'Externally Powered',
                                                                         'offset': 27,
                                                                         'bit length': 1})
            extPow.help = "Is set to true if the device is wall powered."
            self.addChild(extPow)

        higherCap = register_class.cBooleanDMTerminator(self.register, {'name': 'Higher Capability',
                                                                        'offset': 28,
                                                                        'bit length': 1})
        higherCap.help = "Is set to true if the device requests more than 5 V."
        self.addChild(higherCap)

        if ('Is Receive' in iDict) and (iDict['Is Receive'] == True):
            dualPow = register_class.cBooleanDMTerminator(self.register, {'name': 'Dual Role Power',
                                                                          'offset': 29,
                                                                          'bit length': 1})
            dualPow.help = "Is set to true of the device operates as a source or sink."
            self.addChild(dualPow)

        supplyType = register_class.cListDMTerminator(self.register, {'name': 'Supply Type',
                                                                      'offset': 30,
                                                                      'bit length': 2})
        supplyType.help = """Select what type of supply this PDO will sink."""
        supplyType.setReportList(['Fixed Sink', 'Battery Sink', 'Variable Sink'])
        supplyType.addUpdateRegisterByName("self")
        supplyType.setMaxValue(2)

        fixedSupplyType = register_class.cForceSetDMTerminator(self.register, {'name': 'Supply Type',
                                                                               'offset': 30,
                                                                               'bit length': 2,
                                                                               'force value': int(0),
                                                                               'force display': 'Fixed Sink',
                                                                               'display widget': supplyType})

        fixedSupplyType.help = """Supply Type that will source PDO1."""
        self.addChild(fixedSupplyType)
        fixedSupplyType.setFromInt(0)

        if (('No RDO Extensions' in iDict) and (iDict['No RDO Extensions'] == True)) or (
                ('Is Receive' in iDict) and (iDict['Is Receive'] == True)):
            pass
        else:
            maxCurrent = cPDOCurrentField(self.register, {'name': 'Maximum Operating Current',
                                                          'offset': 224,
                                                          'bit length': 10})
            maxCurrent.help = "The maximum current that the sink may request for this PDO."
            self.addChild(maxCurrent)

            minCurrent = cPDOCurrentField(self.register, {'name': 'Minimum Operating Current',
                                                          'offset': 234,
                                                          'bit length': 10})
            minCurrent.help = "The minimum current required for the device to operate within this PDO"
            self.addChild(minCurrent)

            askForMax = register_class.cBooleanDMTerminator(self.register, {'name': 'Ask For Max',
                                                                            'offset': 254,
                                                                            'bit length': 1})
            askForMax.help = "When selected, the sink will request the maximum current the source is capable of supplying at this PDO up to the value specified in the Maximum Operating Current field."
            self.addChild(askForMax)


class cDMVariableSourcePdoArray(register_class.cDataModelArray):
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)
        #
        self.addChild(cPDOCurrentField(self.register, {'name': 'Maximum Current',
                                                       'offset': 0,
                                                       'bit length': 10}))

        self.addChild(cPDOVoltageField(self.register, {'name': 'Minimum Voltage',
                                                       'offset': 10,
                                                       'bit length': 10}))

        self.addChild(cPDOVoltageField(self.register, {'name': 'Maximum Voltage',
                                                       'offset': 20,
                                                       'bit length': 10}))

        supplyType = register_class.cListDMTerminator(self.register, {'name': 'Supply Type',
                                                                      'offset': 30,
                                                                      'bit length': 2})
        supplyType.help = """Supply Type that will Source this PDO."""
        supplyType.setReportList(['Fixed Source', 'Battery Source', 'Variable Source'])
        supplyType.addUpdateRegisterByName("self")
        supplyType.setMaxValue(2)

        self.addChild(supplyType)


class cDMVariableSinkPdoArray(register_class.cDataModelArray):
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)
        #
        self.addChild(cPDOCurrentField(self.register, {'name': 'Operating Current',
                                                       'offset': 0,
                                                       'bit length': 10}))

        self.addChild(cPDOVoltageField(self.register, {'name': 'Minimum Voltage',
                                                       'offset': 10,
                                                       'bit length': 10}))

        self.addChild(cPDOVoltageField(self.register, {'name': 'Maximum Voltage',
                                                       'offset': 20,
                                                       'bit length': 10}))

        supplyType = register_class.cListDMTerminator(self.register, {'name': 'Supply Type',
                                                                      'offset': 30,
                                                                      'bit length': 2})
        supplyType.help = """Supply Type that will be used for this Sink PDO."""
        supplyType.setReportList(['Fixed Sink', 'Battery Sink', 'Variable Sink'])
        supplyType.addUpdateRegisterByName("self")
        supplyType.setMaxValue(2)

        self.addChild(supplyType)

        if ('No RDO Extensions' in iDict) and (iDict['No RDO Extensions'] == True):
            pass
        else:
            self.addChild(cPDOCurrentField(self.register, {'name': 'Maximum Operating Current',
                                                           'offset': 224,
                                                           'bit length': 10}))

            self.addChild(cPDOCurrentField(self.register, {'name': 'Minimum Operating Current',
                                                           'offset': 234,
                                                           'bit length': 10}))

            self.addChild(register_class.cBooleanDMTerminator(self.register, {'name': 'Ask For Max',
                                                                              'offset': 254,
                                                                              'bit length': 1}))


class cDMBatterySourcePdoArray(register_class.cDataModelArray):
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)
        #
        self.addChild(cPDOPowerField(self.register, {'name': 'Maximum Power',
                                                     'offset': 0,
                                                     'bit length': 10}))

        self.addChild(cPDOVoltageField(self.register, {'name': 'Minimum Voltage',
                                                       'offset': 10,
                                                       'bit length': 10}))

        self.addChild(cPDOVoltageField(self.register, {'name': 'Maximum Voltage',
                                                       'offset': 20,
                                                       'bit length': 10}))

        supplyType = register_class.cListDMTerminator(self.register, {'name': 'Supply Type',
                                                                      'offset': 30,
                                                                      'bit length': 2})
        supplyType.help = """Supply type that will source this PDO."""
        supplyType.setReportList(['Fixed Source', 'Battery Source', 'Variable Source'])
        supplyType.addUpdateRegisterByName("self")
        supplyType.setMaxValue(2)

        self.addChild(supplyType)


class cDMBatterySinkPdoArray(register_class.cDataModelArray):
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)
        #
        self.addChild(cPDOPowerField(self.register, {'name': 'Operating Power',
                                                     'offset': 0,
                                                     'bit length': 10}))

        self.addChild(cPDOVoltageField(self.register, {'name': 'Minimum Voltage',
                                                       'offset': 10,
                                                       'bit length': 10}))

        self.addChild(cPDOVoltageField(self.register, {'name': 'Maximum Voltage',
                                                       'offset': 20,
                                                       'bit length': 10}))

        supplyType = register_class.cListDMTerminator(self.register, {'name': 'Supply Type',
                                                                      'offset': 30,
                                                                      'bit length': 2})
        supplyType.help = """Supply Type that will be used for this Sink PDO."""
        supplyType.setReportList(['Fixed Sink', 'Battery Sink', 'Variable Sink'])
        supplyType.addUpdateRegisterByName("self")
        supplyType.setMaxValue(2)

        self.addChild(supplyType)

        self.addChild(cPDOPowerField(self.register, {'name': 'Maximum Operating Power',
                                                     'offset': 224,
                                                     'bit length': 10}))

        self.addChild(cPDOPowerField(self.register, {'name': 'Minimum Operating Power',
                                                     'offset': 234,
                                                     'bit length': 10}))

        self.addChild(register_class.cBooleanDMTerminator(self.register, {'name': 'Ask For Max',
                                                                          'offset': 254,
                                                                          'bit length': 1}))


# TODO : This is a common need. Build an extender class that takes an arbitrary data model in init and adds the
#        prepend and append capability.
class cDMAnySourcePdoArray(register_class.cDataModelArray):
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)

        self.prependChildrenArray = []
        self.appendChildrenArray = []

        self.fixedOverlay = cDMFixedSourcePdoArray(register, self.tier, iDict)
        self.variableOverlay = cDMVariableSourcePdoArray(register, self.tier, iDict)
        self.batteryOverlay = cDMBatterySourcePdoArray(register, self.tier, iDict)

        # self.dataModelChildrenArray must contain the children in all three of the overlays
        self.dataModelChildrenArray = []
        self.dataModelChildrenArray.extend(self.fixedOverlay.dataModelChildrenArray)
        self.dataModelChildrenArray.extend(self.variableOverlay.dataModelChildrenArray)
        self.dataModelChildrenArray.extend(self.batteryOverlay.dataModelChildrenArray)

        self.dataModelGenerator = self.AnyPdoArrayDMGenerator

    def findDependentRegisters(self):
        # only update forcevals in current overlay
        type = self.fixedOverlay.getChildByName('Supply Type').valueToInt()
        if type == 0:
            return self.fixedOverlay.findDependentRegisters()

        elif type == 1:
            return self.variableOverlay.findDependentRegisters()

        elif type == 2:
            return self.batteryOverlay.findDependentRegisters()

    def updateForceVal(self):
        # todo: should make a set parent call instead of allowing to be set directly
        #       then the objects can correctly set sub-object parent relationships
        self.fixedOverlay.parent = self.parent
        self.variableOverlay.parent = self.parent
        self.batteryOverlay.parent = self.parent

        # only update forcevals in current overlay
        type = self.fixedOverlay.getChildByName('Supply Type').valueToInt()
        if type == 0:
            self.fixedOverlay.updateForceVal()

        elif type == 1:
            self.variableOverlay.updateForceVal()

        elif type == 2:
            self.batteryOverlay.updateForceVal()

    def maxPower(self):
        power = 0.0
        type = self.fixedOverlay.getChildByName('Supply Type').valueToInt()
        if type == 0:
            # 10 mA steps
            current = self.fixedOverlay.getChildByName('Maximum Current').valueToInt()
            # 50 mV steps
            voltage = self.fixedOverlay.getChildByName('Voltage').valueToInt()
            # 0.01 * 0.05 = .0005 Watts
            power = current * voltage * 0.0005

        if type == 1:
            # 10 mA steps
            current = self.variableOverlay.getChildByName('Maximum Current').valueToInt()
            # 50 mV steps
            voltage = self.variableOverlay.getChildByName('Maximum Voltage').valueToInt()
            # 0.01 * 0.05 = .0005 Watts
            power = current * voltage * 0.0005

        if type == 2:
            # reported in 250 mW steps
            power = self.batteryOverlay.getChildByName('Maximum Power').valueToInt() * 0.25

        return power

    def prependChild(self, child):
        self.prependChildrenArray[:0] = [child, ]
        # it is okay to append to the dataModelChildrenArray because it is not directly used in the
        #    data model generator.
        self.dataModelChildrenArray.append(child)

    def addChild(self, child):
        child.parent = self
        self.appendChildrenArray.append(child)
        self.dataModelChildrenArray.append(child)

    # return the first child with a matching name or none if no match
    def getChildByName(self, name):
        for child in self.prependChildrenArray:
            if child.name == name:
                return child

        for child in self.appendChildrenArray:
            if child.name == name:
                return child

        type = self.fixedOverlay.getChildByName('Supply Type').valueToInt()
        if type == 0:
            for child in self.fixedOverlay:
                if child.name == name:
                    return child
        elif type == 1:
            for child in self.variableOverlay:
                if child.name == name:
                    return child
        elif type == 2:
            for child in self.batteryOverlay:
                if child.name == name:
                    return child

        return None

    def AnyPdoArrayDMGenerator(self):
        # todo: should make a set parent call instead of allowing to be set directly
        #       then the objects can correctly set sub-object parent relationships
        self.fixedOverlay.parent = self.parent
        self.variableOverlay.parent = self.parent
        self.batteryOverlay.parent = self.parent

        type = self.fixedOverlay.getChildByName('Supply Type').valueToInt()
        retDict = {'name': self.name, 'grouping tier': self.tier, 'show': self.show, 'data model list': []}
        if type == 0:
            for child in self.prependChildrenArray:
                if isinstance(child, dict):
                    retDict['data model list'].extend(child.dataModelGenerator()['data model list'])
                else:
                    retDict['data model list'].append(child.dataModelGenerator())
            retDict['data model list'].extend(self.fixedOverlay.dataModelGenerator()['data model list'])
            for child in self.appendChildrenArray:
                if isinstance(child, list):
                    retDict['data model list'].extend(child.dataModelGenerator()['data model list'])
                else:
                    retDict['data model list'].append(child.dataModelGenerator())
        elif type == 1:
            for child in self.prependChildrenArray:
                if isinstance(child, list):
                    retDict['data model list'].extend(child.dataModelGenerator()['data model list'])
                else:
                    retDict['data model list'].append(child.dataModelGenerator())
            retDict['data model list'].extend(self.batteryOverlay.dataModelGenerator()['data model list'])
            for child in self.appendChildrenArray:
                if isinstance(child, list):
                    retDict['data model list'].extend(child.dataModelGenerator()['data model list'])
                else:
                    retDict['data model list'].append(child.dataModelGenerator())
        elif type == 2:
            for child in self.prependChildrenArray:
                if isinstance(child, list):
                    retDict['data model list'].extend(child.dataModelGenerator()['data model list'])
                else:
                    retDict['data model list'].append(child.dataModelGenerator())
            retDict['data model list'].extend(self.variableOverlay.dataModelGenerator()['data model list'])
            for child in self.appendChildrenArray:
                if isinstance(child, list):
                    retDict['data model list'].extend(child.dataModelGenerator()['data model list'])
                else:
                    retDict['data model list'].append(child.dataModelGenerator())
        else:
            # invalid setting
            # TODO: improve error handling
            retDict['data model list'] = []

        return retDict


class cDMAnySinkPdoArray(register_class.cDataModelArray):
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)

        self.prependChildrenArray = []
        self.appendChildrenArray = []

        self.fixedOverlay = cDMFixedSinkPdoArray(register, self.tier, iDict)
        self.variableOverlay = cDMVariableSinkPdoArray(register, self.tier, iDict)
        self.batteryOverlay = cDMBatterySinkPdoArray(register, self.tier, iDict)

        # self.dataModelChildrenArray must contain the children in all three of the overlays
        self.dataModelChildrenArray = []
        self.dataModelChildrenArray.extend(self.fixedOverlay.dataModelChildrenArray)
        self.dataModelChildrenArray.extend(self.variableOverlay.dataModelChildrenArray)
        self.dataModelChildrenArray.extend(self.batteryOverlay.dataModelChildrenArray)

        self.dataModelGenerator = self.AnyPdoArrayDMGenerator

    def findDependentRegisters(self):
        # only update forcevals in current overlay
        type = self.fixedOverlay.getChildByName('Supply Type').valueToInt()
        if type == 0:
            return self.fixedOverlay.findDependentRegisters()

        elif type == 1:
            return self.variableOverlay.findDependentRegisters()

        elif type == 2:
            return self.batteryOverlay.findDependentRegisters()

    def updateForceVal(self):
        # todo: should make a set parent call instead of allowing to be set directly
        #       then the objects can correctly set sub-object parent relationships
        self.fixedOverlay.parent = self.parent
        self.variableOverlay.parent = self.parent
        self.batteryOverlay.parent = self.parent

        # only update forcevals in current overlay
        type = self.fixedOverlay.getChildByName('Supply Type').valueToInt()
        if type == 0:
            self.fixedOverlay.updateForceVal()

        elif type == 1:
            self.variableOverlay.updateForceVal()

        elif type == 2:
            self.batteryOverlay.updateForceVal()

    def prependChild(self, child):
        self.prependChildrenArray[:0] = [child, ]
        # it is okay to append to the dataModelChildrenArray because it is not directly used in the
        #    data model generator.
        self.dataModelChildrenArray.append(child)

    def addChild(self, child):
        child.parent = self
        self.appendChildrenArray.append(child)
        self.dataModelChildrenArray.append(child)

    # return the first child with a matching name or none if no match
    def getChildByName(self, name):
        for child in self.prependChildrenArray:
            if child.name == name:
                return child

        for child in self.appendChildrenArray:
            if child.name == name:
                return child

        type = self.fixedOverlay.getChildByName('Supply Type').valueToInt()
        if type == 0:
            for child in self.fixedOverlay:
                if child.name == name:
                    return child
        elif type == 1:
            for child in self.variableOverlay:
                if child.name == name:
                    return child
        elif type == 2:
            for child in self.batteryOverlay:
                if child.name == name:
                    return child

        return None

    def AnyPdoArrayDMGenerator(self):
        # todo: should make a set parent call instead of allowing to be set directly
        #       then the objects can correctly set sub-object parent relationships
        self.fixedOverlay.parent = self.parent
        self.variableOverlay.parent = self.parent
        self.batteryOverlay.parent = self.parent

        type = self.fixedOverlay.getChildByName('Supply Type').valueToInt()
        retDict = {'name': self.name, 'grouping tier': self.tier, 'show': self.show, 'data model list': []}
        if type == 0:
            for child in self.prependChildrenArray:
                if isinstance(child, dict):
                    retDict['data model list'].extend(child.dataModelGenerator()['data model list'])
                else:
                    retDict['data model list'].append(child.dataModelGenerator())
            retDict['data model list'].extend(self.fixedOverlay.dataModelGenerator()['data model list'])
            for child in self.appendChildrenArray:
                if isinstance(child, list):
                    retDict['data model list'].extend(child.dataModelGenerator()['data model list'])
                else:
                    retDict['data model list'].append(child.dataModelGenerator())
        elif type == 1:
            for child in self.prependChildrenArray:
                if isinstance(child, list):
                    retDict['data model list'].extend(child.dataModelGenerator()['data model list'])
                else:
                    retDict['data model list'].append(child.dataModelGenerator())
            retDict['data model list'].extend(self.batteryOverlay.dataModelGenerator()['data model list'])
            for child in self.appendChildrenArray:
                if isinstance(child, list):
                    retDict['data model list'].extend(child.dataModelGenerator()['data model list'])
                else:
                    retDict['data model list'].append(child.dataModelGenerator())
        elif type == 2:
            for child in self.prependChildrenArray:
                if isinstance(child, list):
                    retDict['data model list'].extend(child.dataModelGenerator()['data model list'])
                else:
                    retDict['data model list'].append(child.dataModelGenerator())
            retDict['data model list'].extend(self.variableOverlay.dataModelGenerator()['data model list'])
            for child in self.appendChildrenArray:
                if isinstance(child, list):
                    retDict['data model list'].extend(child.dataModelGenerator()['data model list'])
                else:
                    retDict['data model list'].append(child.dataModelGenerator())
        else:
            # invalid setting
            # TODO: improve error handling
            retDict['data model list'] = []

        return retDict


class cIDHeaderVDO(register_class.cDataModelArray) :
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)
        #
        self.addChild(register_class.cHexDMTerminator( self.register,  { 'name' : 'USB Vendor ID',
                                                                'offset' : 0,
                                                                'bit length' : 16}))

        connectortype = register_class.cListDMTerminator(self.register,
                {'name': 'Connector Type',
                    'offset': 21,
                    'bit length': 2})
        connectortype.setReportList(['Reserved Legacy', 'Reserved', 'Receptacle', 'Plug'])
        self.addChild(connectortype)
        connectortype.reference_name = "Connector Type"
        connectortype.help = "This is as defined in the USB PD specification. The value written for Connector Type is used to  identify it as either a USB Type-C receptacle or a USB Type-C plug."
        connectortype.hide()
        connectortype.setMaxValue(3)

        productTypeDFP = register_class.cListDMTerminator(self.register, {'name': 'Product Type (DFP)',
                                                                          'offset': 23,
                                                                          'bit length': 3})
        productTypeDFP.setReportList(
            ['Undefined', 'PDUSB Hub', 'PDUSB Host', 'Power Brick', 'Alternate Mode Controller'])

        self.addChild(productTypeDFP)


        self.addChild(register_class.cBooleanDMTerminator( self.register,  { 'name' : 'Modal Operation Supported',
                                                                'offset' : 26,
                                                                'bit length' : 1}))

        productTypeUFP = register_class.cListDMTerminator( self.register,  { 'name' : 'Product Type (UFP)',
                                                                'offset' : 27,
                                                                'bit length' : 3})
        productTypeUFP.setMaxValue(6)
        productTypeUFP.setReportList(['Undefined', 'PDUSB Hub', 'PDUSB Peripheral', 'PSD', 'Reserved', 'Alternate Mode Adapter', 'VConn Powered USB Device (VPD)', 'Reserved'])

        self.addChild(productTypeUFP)

        self.addChild(register_class.cBooleanDMTerminator( self.register,  { 'name' : 'Data Capable as USB Device',
                                                                'offset' : 30,
                                                                'bit length' : 1}))

        self.addChild(register_class.cBooleanDMTerminator( self.register,  { 'name' : 'Data Capable as USB Host',
                                                                'offset' : 31,
                                                                'bit length' : 1}))


class cUFPProductVDO(register_class.cDataModelArray):
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)
        #
        self.addChild(register_class.cHexDMTerminator(self.register, {'name': 'BCD Device',
                                                                      'offset': 0,
                                                                      'bit length': 16}))

        self.addChild(register_class.cHexDMTerminator(self.register, {'name': 'USB Product ID',
                                                                      'offset': 16,
                                                                      'bit length': 16}))



class cCableIDOHeaderVDO(register_class.cDataModelArray) :
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)
        #
        self.addChild(register_class.cHexDMTerminator( self.register,  { 'name' : 'USB Vendor ID',
                                                                'offset' : 0,
                                                                'bit length' : 16}))

        productTypeDFP = register_class.cListDMTerminator(self.register, {'name': 'Product Type (DFP)',
                                                                          'offset': 23,
                                                                          'bit length': 3})
        productTypeDFP.setReportList(
            ['Undefined', 'PDUSB Hub', 'PDUSB Host', 'Power Brick', 'Alternate Mode Controller'])

        self.addChild(productTypeDFP)


        self.addChild(register_class.cBooleanDMTerminator( self.register,  { 'name' : 'Modal Operation Supported',
                                                                'offset' : 26,
                                                                'bit length' : 1}))

        productTypeUFP = register_class.cListDMTerminator( self.register,  { 'name' : 'Product Type (Cable Plug)',
                                                                'offset' : 27,
                                                                'bit length' : 3})
        productTypeUFP.setMaxValue(6)
        productTypeUFP.setReportList(['Undefined', 'Reserved', 'Reserved', 'Passive Cable', 'Active Cable', 'Reserved'])

        self.addChild(productTypeUFP)

        self.addChild(register_class.cBooleanDMTerminator( self.register,  { 'name' : 'Data Capable as USB Device',
                                                                'offset' : 30,
                                                                'bit length' : 1}))

        self.addChild(register_class.cBooleanDMTerminator( self.register,  { 'name' : 'Data Capable as USB Host',
                                                                'offset' : 31,
                                                                'bit length' : 1}))

class cCableVDO(register_class.cDataModelArray) :
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)
        #
        usbSSSignal = register_class.cListDMTerminator( self.register,  { 'name' : 'USB SS Signalling',
                                                                'offset' : 0,
                                                                'bit length' : 3})
        usbSSSignal.setMaxValue(2)
        usbSSSignal.setReportList(['USB 2.0 Only', 'USB 3.1 Gen 1', 'USB 3.1 Gen 1 and 2'])

        self.addChild(usbSSSignal)

        self.addChild(register_class.cBooleanDMTerminator( self.register,  { 'name' : 'SOP" Controller Present',
                                                                'offset' : 3,
                                                                'bit length' : 1}))

        self.addChild(register_class.cBooleanDMTerminator( self.register,  { 'name' : 'VBus Through Cable',
                                                                'offset' : 4,
                                                                'bit length' : 1}))

        currentCap = register_class.cListDMTerminator( self.register,  { 'name' : 'VBus Current Handling Capability',
                                                                'offset' : 5,
                                                                'bit length' : 2})
        currentCap.setMaxValue(2)
        currentCap.setReportList(['Reserved', '3.0 A', '5 A'])

        self.addChild(currentCap)

        maxvbusVoltage = register_class.cListDMTerminator(self.register, {'name': 'Maximum Vbus Voltage',
                                                                      'offset': 9,
                                                                      'bit length': 2})
        maxvbusVoltage.setReportList(['20V', '30V', '40V', '50V'])
        self.addChild(maxvbusVoltage)

        cableTerm = register_class.cListDMTerminator( self.register,  { 'name' : 'Cable Termination Type',
                                                                'offset' : 11,
                                                                'bit length' : 2})
        cableTerm.setReportList(['Both Ends Passive, VConn Not Required', 'Both Ends Passive, VConn Is Required', 'One End Active, One End Passive, VConn Is Required', 'Both Ends Active, VConn Is Required'])

        self.addChild(cableTerm)

        cableLat = register_class.cListDMTerminator( self.register,  { 'name' : 'Cable Latency',
                                                                'offset' : 13,
                                                                'bit length' : 4})

        cableLat.setMaxValue(8)
        cableLat.setReportList(['reserved (0000b)', '< 10nS (~1m)', '10-20nS (~2m)', '20-30nS (~3m)', '30-40nS (~4m)', '40-50nS (~5m)', '50-60nS (~6m)', '60-70nS (~7m)', '>70nS (>~7m)'])

        self.addChild(cableLat)

        typeCto = register_class.cListDMTerminator( self.register,  { 'name' : 'Type-C Plug to Type-C/Captive',
                                                                'offset' : 18,
                                                                'bit length' : 2})

        typeCto.setReportList(['reserved', 'reserved', 'Type-C', 'Captive'])

        self.addChild(typeCto)

        self.addChild(register_class.cHexDMTerminator(self.register, {'name': 'VDO version',
                                                                      'offset': 21,
                                                                      'bit length': 3}))

        self.addChild(register_class.cHexDMTerminator( self.register,  { 'name' : 'Cable Firmware Version',
                                                                'offset' : 24,
                                                                'bit length' : 4}))

        self.addChild(register_class.cHexDMTerminator( self.register,  { 'name' : 'Cable Hardware Version',
                                                                'offset' : 28,
                                                                'bit length' : 4}))


class cAMAVDO(register_class.cDataModelArray):
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)
        #
        usbSSSignal = register_class.cListDMTerminator(self.register, {'name': 'USB SS Signalling',
                                                                       'offset': 0,
                                                                       'bit length': 3})
        usbSSSignal.setMaxValue(3)
        usbSSSignal.setReportList(['USB 2.0 Only', 'USB 3.1 Gen 1', 'USB 3.1 Gen 1 and 2', 'USB 2.0 Billboard Only'])

        self.addChild(usbSSSignal)

        self.addChild(register_class.cBooleanDMTerminator(self.register, {'name': 'VBus Required',
                                                                          'offset': 3,
                                                                          'bit length': 1}))

        self.addChild(register_class.cBooleanDMTerminator(self.register, {'name': 'VConn Required',
                                                                          'offset': 4,
                                                                          'bit length': 1}))

        vConnPower = register_class.cListDMTerminator(self.register, {'name': 'VConn Power',
                                                                      'offset': 5,
                                                                      'bit length': 3})
        vConnPower.setMaxValue(6)
        vConnPower.setReportList(['1 W', '1.5 W', '2 W', '3 W', '4 W', '5 W', '6 W'])

        self.addChild(vConnPower)

        ssrx2dir = register_class.cListDMTerminator(self.register, {'name': 'SSRx 2 Directionality',
                                                                    'offset': 8,
                                                                    'bit length': 1})
        ssrx2dir.setReportList(['Fixed', 'Configurable'])

        self.addChild(ssrx2dir)

        ssrx1dir = register_class.cListDMTerminator(self.register, {'name': 'SSRx 1 Directionality',
                                                                    'offset': 9,
                                                                    'bit length': 1})
        ssrx1dir.setReportList(['Fixed', 'Configurable'])

        self.addChild(ssrx1dir)

        sstx2dir = register_class.cListDMTerminator(self.register, {'name': 'SSTx 2 Directionality',
                                                                    'offset': 10,
                                                                    'bit length': 1})
        sstx2dir.setReportList(['Fixed', 'Configurable'])

        self.addChild(sstx2dir)

        sstx1dir = register_class.cListDMTerminator(self.register, {'name': 'SSTx 1 Directionality',
                                                                    'offset': 11,
                                                                    'bit length': 1})
        sstx1dir.setReportList(['Fixed', 'Configurable'])

        self.addChild(sstx1dir)

        self.addChild(register_class.cHexDMTerminator(self.register, {'name': 'AMA Firmware Version',
                                                                      'offset': 24,
                                                                      'bit length': 4}))

        self.addChild(register_class.cHexDMTerminator(self.register, {'name': 'AMA Hardware Version',
                                                                      'offset': 28,
                                                                      'bit length': 4}))


# ==========================================================================
# main registers
# ==========================================================================

VID_COMMON_TI = 0x28


class cVID_0x00_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'VID',
                                                 'address': 0x00,
                                                 'byte length': 4,
                                                 'permission': 'RO'})

        self.setAsShared()
        self.hide()

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'VID',
                                                         'offset': 0,
                                                         'bit length': 32})

        VID = register_class.cForceSetDMTerminator(self,
                                                   {'name': 'Intel-assigned Thunderbolt Vendor ID',
                                                    'offset': 0,
                                                    'bit length': 32,
                                                    'force value': int(VID_COMMON_TI),
                                                    'force display': str(VID_COMMON_TI)})

        # VID = register_class.cHexDMTerminator(self,
        #                                                    {'name': 'Intel-assigned Thunderbolt Vendor ID',
        #                                                     'offset': 0,
        #                                                     'bit length': 32})

        self.dataModel.addChild(VID)


def intFrom4CC(value):
    retVal = 0x0
    # little endian. First char takes position 0 of the array
    for (i, char) in enumerate(value):
        retVal |= (ord(char) << (8 * i))

    return retVal


DID_ACE = "ACEL"

DID_OF_DEVICE_STR = DID_ACE
DID_OF_DEVICE_INT = intFrom4CC(DID_ACE)


class cDID_0x01_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'DID',
                                                 'address': 0x01,
                                                 'byte length': 4,
                                                 'permission': 'RO'})

        self.setAsShared()

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'DID',
                                                         'offset': 0,
                                                         'bit length': 32})

        self.hide()

        DID = register_class.cForceSetDMTerminator(self,
                                                   {'name': 'Vendor-specific Device ID.',
                                                    'offset': 0,
                                                    'bit length': 32,
                                                    'force value': int(DID_OF_DEVICE_INT),
                                                    'force display': str(DID_OF_DEVICE_STR)})

        self.dataModel.addChild(DID)


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cMode_0x03_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Mode',
                                                 'address': 0x03,
                                                 'byte length': 4,
                                                 'permission': 'DRO'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'Mode',
                                                         'offset': 0,
                                                         'bit length': 32})
        self.setAsShared()
        mode = register_class.cAsciiDMTerminator(self,
                                                 {'name': 'Mode',
                                                  'offset': 0,
                                                  'bit length': 32})
        mode.help = """4-character string to indicate mode of device"""
        self.dataModel.addChild(mode)


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cUID_0x05_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'UID',
                                                 'address': 0x05,
                                                 'byte length': 16,
                                                 'permission': 'DRO'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'UID',
                                                         'offset': 0,
                                                         'bit length': 128})
        self.setAsShared()
        UIDdata = register_class.cHexDMTerminator(self,
                                                  {'name': 'UID',
                                                   'offset': 0,
                                                   'bit length': 128})
        UIDdata.help = """128-bit unique ID (unique for each PD controller)"""
        self.dataModel.addChild(UIDdata)


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cCustUse_0x06_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Customer Use',
                                                 'address': 0x06,
                                                 'byte length': 8,
                                                 'permission': 'RO'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'Customer Use',
                                                         'offset': 0,
                                                         'bit length': 64})

        svid = register_class.cHexDMTerminator(self,
                                               {'name': 'Customer Use Word 1',
                                                'offset': 0,
                                                'bit length': 32})

        svid.help = """The customer use register is a read-only register that is configured at build time using the configuration tool. It stores an arbitrary value that may be read from the customer use register (0x06) at run time.

Common uses of this register include platform identifiers, configuration version numbers and date codes."""

        self.dataModel.addChild(svid)

        svid = register_class.cHexDMTerminator(self,
                                               {'name': 'Customer Use Word 2',
                                                'offset': 32,
                                                'bit length': 32})

        svid.help = """The customer use register is a read-only register that is configured at build time using the configuration tool. It stores an arbitrary value that may be read from the customer use register (0x06) at run time.

Common uses of this register include platform identifiers, configuration version numbers and date codes."""

        self.dataModel.addChild(svid)


########################################################################################################################
########################################################################################################################
########################################################################################################################


class cIntEvent1_0x14_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Interrupt Event for I2C1',
                                                 'address': 0x14,
                                                 'byte length': 11,
                                                 'permission': 'DRO'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name': 'Interrupt Event for I2C1',
                                                         'offset': 0,
                                                         'bit length': 88})

        port0ints = register_class.cDataModelArray(self, 1,
                                                   {'name': 'Interrupt Event for I2C1',
                                                    'offset': 0,
                                                    'bit length': 80})

        self.dataModel.addChild(port0ints)

        SoftReset = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'Soft Reset',
                                                         'offset': 0,
                                                         'bit length': 1})

        SoftReset.help = """When this bit is enabled, an I2C interrupt event will be set when a PD Soft Reset has been performed. See PD Status.SoftResetType for more information."""
        port0ints.addChild(SoftReset)

        HardReset = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'Hard Reset',
                                                         'offset': 1,
                                                         'bit length': 1})

        HardReset.help = """when this bit is enabled, an I2C interrupt event will be set when a PD Hard Reset has been performed. See PD Status.HardResetDetails for more information."""
        port0ints.addChild(HardReset)

        CableResetEvent = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Cable Reset Event',
                                                               'offset': 2,
                                                               'bit length': 1})

        CableResetEvent.help = """This event occurs when PD Controller sends Cable Reset signaling."""
        port0ints.addChild(CableResetEvent)

        PlugInsertOrRemoval = register_class.cBooleanDMTerminator(self,
                                                                  {'name': 'Plug Insert or Removal',
                                                                   'offset': 3,
                                                                   'bit length': 1})

        PlugInsertOrRemoval.help = """when this bit is enabled, an I2C interrupt event will be set when the user inserts or removes a plug into the Type-C port."""
        port0ints.addChild(PlugInsertOrRemoval)

        PRSwapComplete = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'PR Swap Complete',
                                                              'offset': 4,
                                                              'bit length': 1})

        PRSwapComplete.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller completes a power role swap."""
        port0ints.addChild(PRSwapComplete)

        DRSwapComplete = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'DR Swap Complete',
                                                              'offset': 5,
                                                              'bit length': 1})

        DRSwapComplete.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller completes a data role swap."""
        port0ints.addChild(DRSwapComplete)

        FRSwapComplete = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'FR Swap Complete',
                                                              'offset': 6,
                                                              'bit length': 1})

        FRSwapComplete.help = """A Fast Role Swap has completed."""
        port0ints.addChild(FRSwapComplete)

        RdoReceivedFromSink = register_class.cBooleanDMTerminator(self,
                                                                  {'name': 'RDO Received from Sink',
                                                                   'offset': 7,
                                                                   'bit length': 1})

        RdoReceivedFromSink.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller receives an RDO (Request Data Object) from the sink device."""
        port0ints.addChild(RdoReceivedFromSink)

        Bist = register_class.cBooleanDMTerminator(self,
                                                   {'name': 'Built-In Self Test',
                                                    'offset': 8,
                                                    'bit length': 1})

        Bist.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller completes a Built-In Self Test (BIST). This bit is set whenever the STATUS.BIST changes."""
        port0ints.addChild(Bist)

        Overcurrent = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'Overcurrent Event',
                                                           'offset': 9,
                                                           'bit length': 1})

        Overcurrent.help = """when this bit is enabled, an I2C interrupt event will be set when an Overcurrent Event occurs on VBUS. This bit is set whenever STATUS.Overcurrent changes."""
        port0ints.addChild(Overcurrent)

        AttentionReceived = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Attention Received',
                                                                 'offset': 10,
                                                                 'bit length': 1})

        AttentionReceived.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller received an Attention message."""
        port0ints.addChild(AttentionReceived)

        VDMReceived = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'Vendor-Defined Message Received',
                                                           'offset': 11,
                                                           'bit length': 1})

        VDMReceived.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller receives a Vendor Defined Message from the device it is connected to."""
        port0ints.addChild(VDMReceived)

        NewContractAsCons = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'New Contract as Consumer',
                                                                 'offset': 12,
                                                                 'bit length': 1})

        NewContractAsCons.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller enters a new power contract as a Consumer (Power Sink). This bit is set when an RDO from the far-end device has been accepted and the PD Controller is a Sink. See Active Contract PDO & Active Contract RDO registers for details"""
        port0ints.addChild(NewContractAsCons)

        NewContractAsProv = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'New Contract as Provider',
                                                                 'offset': 13,
                                                                 'bit length': 1})

        NewContractAsProv.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller enters a new power contract as a Provider (Power Source). This bit is set when an RDO from the far-end device has been accepted and the PD Controller is a Source. See Active Contract PDO & Active Contract RDO registers for details"""
        port0ints.addChild(NewContractAsProv)

        SourceCapMsgReady = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Source Capabilities Message Ready',
                                                                 'offset': 14,
                                                                 'bit length': 1})

        SourceCapMsgReady.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller is ready to send its Source Capabilities message has been updated by the far end device."""
        port0ints.addChild(SourceCapMsgReady)

        SinkCapMsgReady = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Sink Capabilities Message Ready',
                                                               'offset': 15,
                                                               'bit length': 1})

        SinkCapMsgReady.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller is ready to send its Sink Capabilities message has been updated by the far end device."""
        port0ints.addChild(SinkCapMsgReady)

        LowVoltageWarning = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Low Voltage Warning',
                                                                 'offset': 16,
                                                                 'bit length': 1})

        LowVoltageWarning.help = """when this bit is enabled, an I2C interrupt event will be set when the voltage level on VBUS is lower than the expected value."""
        port0ints.addChild(LowVoltageWarning)

        PRSwapReq = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'PR Swap Requested',
                                                         'offset': 17,
                                                         'bit length': 1})

        PRSwapReq.help = """when this bit is enabled, an I2C interrupt event will be set when the device attached to the PD controller requests a power role swap."""
        port0ints.addChild(PRSwapReq)

        DRSwapReq = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'DR Swap Requested',
                                                         'offset': 18,
                                                         'bit length': 1})

        DRSwapReq.help = """when this bit is enabled, an I2C interrupt event will be set when the device attached to the PD controller requests a data role swap."""
        port0ints.addChild(DRSwapReq)

        GotoMinReceived = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Goto Min Received',
                                                               'offset': 19,
                                                               'bit length': 1})

        GotoMinReceived.help = """when this bit is enabled, an I2C interrupt event will be set when the PD Controller has received a GotoMin message while in a contract where the GiveBack flag in the RDO was set. The system needs to reduce power consumption down to the level specified in the Auto Negotiate Sink Register (0x37)."""
        port0ints.addChild(GotoMinReceived)

        UsbHostPresent = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'USB Host Present',
                                                              'offset': 20,
                                                              'bit length': 1})

        UsbHostPresent.help = """when this bit is enabled, an I2C interrupt event will be set when there is a USB Host Present on the Type-C port."""
        port0ints.addChild(UsbHostPresent)

        UsbHostPresentNoLonger = register_class.cBooleanDMTerminator(self,
                                                                     {'name': 'USB Host Present no longer',
                                                                      'offset': 21,
                                                                      'bit length': 1})

        UsbHostPresentNoLonger.help = """when this bit is enabled, an I2C interrupt event will be set when a USB Host gets removed from the Type-C port os is no longer available."""
        port0ints.addChild(UsbHostPresentNoLonger)

        HighVoltageWarning = register_class.cBooleanDMTerminator(self,
                                                                 {'name': 'High Voltage Warning',
                                                                  'offset': 22,
                                                                  'bit length': 1})

        HighVoltageWarning.help = """when this bit is enabled, an I2C interrupt event will be set when the voltage on VBUS exceeds the safe threshold."""
        port0ints.addChild(HighVoltageWarning)

        PPswitchChanged = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'PP Switch Changed',
                                                               'offset': 23,
                                                               'bit length': 1})

        PPswitchChanged.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller changes the power path that is currently sourcing or sinking power on VBUS."""
        port0ints.addChild(PPswitchChanged)

        PowerStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Power Status Update',
                                                                 'offset': 24,
                                                                 'bit length': 1})

        PowerStatusUpdate.help = """when this bit is enabled, an I2C interrupt event will be set when the PD Controller updates its power status. This is set when the contents of Register (0x3F) change."""
        port0ints.addChild(PowerStatusUpdate)

        DataStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'Data Status Update',
                                                                'offset': 25,
                                                                'bit length': 1})
        DataStatusUpdate.hide()
        DataStatusUpdate.help = """when this bit is enabled, an I2C interrupt event will be set when the data status is updated on the PD controller. This bit must be set for use with Alpine Ridge thunderbolt controllers. This interrupt is set when the contents of register (0x5F) change."""
        port0ints.addChild(DataStatusUpdate)

        StatusUpdate = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Status Update',
                                                            'offset': 26,
                                                            'bit length': 1})

        StatusUpdate.help = """when this bit is enabled, an I2C interrupt event will be set when the status of the PD controller is updated. This is set when the contents of Register (0x1A) change."""
        port0ints.addChild(StatusUpdate)

        PDStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'PD Status Update',
                                                              'offset': 27,
                                                              'bit length': 1})

        PDStatusUpdate.help = """when this bit is enabled, an I2C interrupt event will be set whenever contents of PD Status register (0x40) change"""
        port0ints.addChild(PDStatusUpdate)

        ADCLowThreshold = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'ADC Low Threshold',
                                                               'offset': 28,
                                                               'bit length': 1})

        ADCLowThreshold.help = """when this bit is enabled, an I2C interrupt event will be set when the ADC Threshold exceeds its lower boundary. (ADC_MON_THR_LO_STAT)"""
        ADCLowThreshold.hide()
        port0ints.addChild(ADCLowThreshold)

        ADCHighThreshold = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'ADC High Threshold',
                                                                'offset': 29,
                                                                'bit length': 1})

        ADCHighThreshold.help = """when this bit is enabled, an I2C interrupt event will be set when the ADC Threshold exceeds its higher boundary. (ADC_MON_THR_HI_STAT)"""
        ADCHighThreshold.hide()
        port0ints.addChild(ADCHighThreshold)

        Cmd1Complete = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'CMD1 Complete',
                                                            'offset': 30,
                                                            'bit length': 1})

        Cmd1Complete.help = """when this bit is enabled, an I2C interrupt event will be set whenever a non-zero value in CMD1 register is set to zero or !CMD."""
        port0ints.addChild(Cmd1Complete)

        Cmd2Complete = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'CMD2 Complete',
                                                            'offset': 31,
                                                            'bit length': 1})

        Cmd2Complete.help = """when this bit is enabled, an I2C interrupt event will be set whenever a non-zero value in CMD2 register is set to zero or !CMD."""
        port0ints.addChild(Cmd2Complete)

        Error_DeviceIncompatible = register_class.cBooleanDMTerminator(self,
                                                                       {'name': 'Error: Device Incompatible',
                                                                        'offset': 32,
                                                                        'bit length': 1})

        Error_DeviceIncompatible.help = """When set to 1, a USB PD device with an incompatible specification version wasconnected. Or the partner device is not USB PD capable."""
        port0ints.addChild(Error_DeviceIncompatible)

        Error_CannotProvideVoltageOrCurrent = register_class.cBooleanDMTerminator(self,
                                                                                  {
                                                                                      'name': 'Error: Cannot Provide Voltage or Current',
                                                                                      'offset': 33,
                                                                                      'bit length': 1})

        Error_CannotProvideVoltageOrCurrent.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller is unable to source the power required for the current PDO."""
        port0ints.addChild(Error_CannotProvideVoltageOrCurrent)

        Error_CanProvideVoltageOrCurrentLater = register_class.cBooleanDMTerminator(self,
                                                                                    {
                                                                                        'name': 'Error: Cannot Provide Voltage or Current Later',
                                                                                        'offset': 34,
                                                                                        'bit length': 1})

        Error_CanProvideVoltageOrCurrentLater.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller is unable to sustain sourcing the power required for the current PDO."""
        port0ints.addChild(Error_CanProvideVoltageOrCurrentLater)

        Error_PowerEventOccurred = register_class.cBooleanDMTerminator(self,
                                                                       {'name': 'Error: Power Event Occurred',
                                                                        'offset': 35,
                                                                        'bit length': 1})

        Error_PowerEventOccurred.help = """when this bit is enabled, an I2C interrupt event will be set when an OVP (Over-Voltage Protection) or short circuit event occured on VBUS"""
        port0ints.addChild(Error_PowerEventOccurred)

        Error_MissingGetCapMessage = register_class.cBooleanDMTerminator(self,
                                                                         {
                                                                             'name': 'Error: Missing Get Capabilities Message',
                                                                             'offset': 36,
                                                                             'bit length': 1})

        Error_MissingGetCapMessage.help = """when this bit is enabled, an I2C interrupt event will be set when he partner device did not respond to the Get_Sink_Cap or Get_Source_Cap message that was sent."""
        port0ints.addChild(Error_MissingGetCapMessage)

        Error_ProtError = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Error: Protocol Error',
                                                               'offset': 38,
                                                               'bit length': 1})

        Error_ProtError.help = """when this bit is enabled, an I2C interrupt event will be set when an unexpected message was received from the partner device."""

        port0ints.addChild(Error_ProtError)

        Error_MessageData = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Error: Message Data',
                                                                 'offset': 39,
                                                                 'bit length': 1})

        Error_MessageData.help = """when this bit is enabled, an I2C interrupt event will be set when a message was received and the CRC failed or the data length in the header (“Number of Data Objects”) did not match the actual amount of data received or its signal level caused the message to be deemed invalid."""
        port0ints.addChild(Error_MessageData)

        Error_DischargeFailed = register_class.cBooleanDMTerminator(self,
                                                                    {'name': 'Error: Discharge Failed',
                                                                     'offset': 41,
                                                                     'bit length': 1})

        Error_DischargeFailed.help = """when this bit is enabled, an I2C interrupt event will be set when the PD Controller fails to discharge VBUS"""
        port0ints.addChild(Error_DischargeFailed)

        SnkTransitionComplete = register_class.cBooleanDMTerminator(self,
                                                                    {'name': 'Sink Transition Complete',
                                                                     'offset': 42,
                                                                     'bit length': 1})

        SnkTransitionComplete.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully transitioned into a power sink."""
        port0ints.addChild(SnkTransitionComplete)

        iclProchot = register_class.cBooleanDMTerminator(self,
                                                         {'name': 'Ice Lake Proc Hot Notification',
                                                          'offset': 44,
                                                          'bit length': 1})
        # port0ints.addChild(ICLProcHot)

        Error_UnableToSource = register_class.cBooleanDMTerminator(self,
                                                                   {'name': 'Error: Unable to Source',
                                                                    'offset': 46,
                                                                    'bit length': 1})

        Error_UnableToSource.help = """when this bit is enabled, an I2C interrupt event will be set when the source device is unable to increase the voltage to the negotiated voltage of the PD contract."""
        port0ints.addChild(Error_UnableToSource)

        Error_BISTIg = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Error: BIST Message Ignored',
                                                            'offset': 47,
                                                            'bit length': 1})

        Error_BISTIg.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller sends a Built-In Self Test message that is ignored by the far end device."""
        port0ints.addChild(Error_BISTIg)

        AMEntryFail = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'AM Entry Failure',
                                                           'offset': 48,
                                                           'bit length': 1})

        AMEntryFail.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller fails to enter an Alternate Mode."""
        port0ints.addChild(AMEntryFail)

        AMEntered = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'AM Entered',
                                                         'offset': 49,
                                                         'bit length': 1})

        AMEntered.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully entered an Alternate Mode."""
        port0ints.addChild(AMEntered)

        VDMMsgSent = register_class.cBooleanDMTerminator(self,
                                                         {'name': 'Vendor Defined Message Sent',
                                                          'offset': 50,
                                                          'bit length': 1})

        VDMMsgSent.help = """Set when a VDM has been sent."""
        port0ints.addChild(VDMMsgSent)

        discModeComp = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Discover Mode Complete',
                                                            'offset': 51,
                                                            'bit length': 1})

        discModeComp.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully Discovered the available modes of the far end device."""
        port0ints.addChild(discModeComp)

        exitModeComp = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Exit Mode Complete',
                                                            'offset': 52,
                                                            'bit length': 1})

        exitModeComp.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully exited an Alternate Mode."""
        port0ints.addChild(exitModeComp)

        UserSvidModeEntered = register_class.cBooleanDMTerminator(self,
                                                                  {'name': 'User SVID Mode Entered',
                                                                   'offset': 56,
                                                                   'bit length': 1})

        UserSvidModeEntered.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully entered a users SVID mode."""
        port0ints.addChild(UserSvidModeEntered)

        UserSvidModeExited = register_class.cBooleanDMTerminator(self,
                                                                 {'name': 'User SVID Mode Exited',
                                                                  'offset': 57,
                                                                  'bit length': 1})

        UserSvidModeExited.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has exited a users SVID mode."""
        port0ints.addChild(UserSvidModeExited)

        UserSvidAttentionVDMReceived = register_class.cBooleanDMTerminator(self,
                                                                           {'name': 'User SVID Attention VDM Received',
                                                                            'offset': 58,
                                                                            'bit length': 1})

        UserSvidAttentionVDMReceived.help = """when this bit is enabled, an I2C interrupt event will be set when a users SVID structured attention vendor defined message is received."""
        port0ints.addChild(UserSvidAttentionVDMReceived)

        UserSvidOtherVDMReceived = register_class.cBooleanDMTerminator(self,
                                                                       {'name': 'User SVID Other VDM Received',
                                                                        'offset': 59,
                                                                        'bit length': 1})

        UserSvidOtherVDMReceived.help = """when this bit is enabled, an I2C interrupt event will be set when a users SVID structured non-Attention VDM or unstructured VDM has been received."""
        port0ints.addChild(UserSvidOtherVDMReceived)

        DPSIDStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'DP SID Status Update',
                                                                 'offset': 62,
                                                                 'bit length': 1})

        DPSIDStatusUpdate.help = """Set when the contents of the DP SID Status register (0x58) change."""
        port0ints.addChild(DPSIDStatusUpdate)

        IntelVIDStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                                   {'name': 'Intel VID Status Update',
                                                                    'offset': 63,
                                                                    'bit length': 1})
        IntelVIDStatusUpdate.hide()
        IntelVIDStatusUpdate.help = """Set when the contents of the Intel VID Status register (0x59) change."""
        port0ints.addChild(IntelVIDStatusUpdate)

        PD3StatusUpdate = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'PD3 Status Update',
                                                               'offset': 64,
                                                               'bit length': 1})

        PD3StatusUpdate.help = """Set when the contents of the PD3.0 Status register (0x41) change."""
        port0ints.addChild(PD3StatusUpdate)

        TXMemBufferEmpty = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'TX Mem Buffer Empty',
                                                                'offset': 65,
                                                                'bit length': 1})

        TXMemBufferEmpty.help = """Transmit memory buffer empty."""
        port0ints.addChild(TXMemBufferEmpty)

        RXMemBufferFull = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'RX Mem Buffer Full',
                                                               'offset': 66,
                                                               'bit length': 1})

        RXMemBufferFull.help = """Transmit memory buffer empty."""
        port0ints.addChild(RXMemBufferFull)

        CustomDVDMArrive = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'Custom VDM Arrive',
                                                                'offset': 67,
                                                                'bit length': 1})

        CustomDVDMArrive.help = """A custom VDM has arrived"""
        port0ints.addChild(CustomDVDMArrive)

        CustomDAMEntered = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'Custom AM Entered',
                                                                'offset': 68,
                                                                'bit length': 1})

        CustomDAMEntered.help = """A custom Alternate Mode has been entered."""
        port0ints.addChild(CustomDAMEntered)

        CustomDVDMMSGSENT = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Custom VDM Message Sent',
                                                                 'offset': 69,
                                                                 'bit length': 1})

        CustomDVDMMSGSENT.help = """A custom VDM has been sent."""
        port0ints.addChild(CustomDVDMMSGSENT)

        ackTime = register_class.cBooleanDMTerminator(self,
                                                      {'name': 'SOC ACK Timeout',
                                                       'offset': 70,
                                                       'bit length': 1})

        ackTime.help = """ACK Timeout Occurred."""
        port0ints.addChild(ackTime)

        FRSSignalReceived = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'FRS Signal Received',
                                                                 'offset': 76,
                                                                 'bit length': 1})

        FRSSignalReceived.help = """An FRS Message has been received."""
        port0ints.addChild(FRSSignalReceived)

        ChunkResponseReceived = register_class.cBooleanDMTerminator(self,
                                                                    {'name': 'Chunk Response Received',
                                                                     'offset': 77,
                                                                     'bit length': 1})

        ChunkResponseReceived.help = """Chunk Response message received."""
        port0ints.addChild(ChunkResponseReceived)

        ChunkRequestReceived = register_class.cBooleanDMTerminator(self,
                                                                   {'name': 'Chunk Request Received',
                                                                    'offset': 78,
                                                                    'bit length': 1})

        ChunkRequestReceived.help = """Chunk Request message received."""
        port0ints.addChild(ChunkRequestReceived)

        AlertMessageReceived = register_class.cBooleanDMTerminator(self,
                                                                   {'name': 'Alert Message Received',
                                                                    'offset': 79,
                                                                    'bit length': 1})

        AlertMessageReceived.help = """An Alert Messae has been received."""
        port0ints.addChild(AlertMessageReceived)

        commonInts = register_class.cDataModelArray(self, 1,
                                                    {'name': 'Common Interrupt Mask for I2C1',
                                                     'offset': 80,
                                                     'bit length': 8})

        self.dataModel.addChild(commonInts)

        patchLoaded = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'Patch Loaded',
                                                           'offset': 0,
                                                           'bit length': 1})

        patchLoaded.help = """when this bit is enabled, an I2C interrupt event will be set when a patch has been loaded onto the device."""
        commonInts.addChild(patchLoaded)

        readyPatch = register_class.cBooleanDMTerminator(self,
                                                         {'name': 'Ready for Patch',
                                                          'offset': 1,
                                                          'bit length': 1})

        readyPatch.help = """when this bit is enabled, an I2C interrupt event will be set when the device is ready to receive a patch."""
        commonInts.addChild(readyPatch)


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cIntEvent2_0x15_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Interrupt Event for I2C2',
                                                 'address': 0x15,
                                                 'byte length': 11,
                                                 'permission': 'DRO'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name': 'Interrupt Event for I2C2',
                                                         'offset': 0,
                                                         'bit length': 88})

        port0ints = register_class.cDataModelArray(self, 1,
                                                   {'name': 'Interrupt Event for I2C2',
                                                    'offset': 0,
                                                    'bit length': 80})

        self.dataModel.addChild(port0ints)

        SoftReset = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'Soft Reset',
                                                         'offset': 0,
                                                         'bit length': 1})

        SoftReset.help = """When this bit is enabled, an I2C interrupt event will be set when a PD Soft Reset has been performed. See PD Status.SoftResetType for more information."""
        port0ints.addChild(SoftReset)

        HardReset = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'Hard Reset',
                                                         'offset': 1,
                                                         'bit length': 1})

        HardReset.help = """when this bit is enabled, an I2C interrupt event will be set when a PD Hard Reset has been performed. See PD Status.HardResetDetails for more information."""
        port0ints.addChild(HardReset)

        CableResetEvent = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Cable Reset Event',
                                                               'offset': 2,
                                                               'bit length': 1})

        CableResetEvent.help = """This event occurs when PD Controller sends Cable Reset signaling."""
        port0ints.addChild(CableResetEvent)

        PlugInsertOrRemoval = register_class.cBooleanDMTerminator(self,
                                                                  {'name': 'Plug Insert or Removal',
                                                                   'offset': 3,
                                                                   'bit length': 1})

        PlugInsertOrRemoval.help = """when this bit is enabled, an I2C interrupt event will be set when the user inserts or removes a plug into the Type-C port."""
        port0ints.addChild(PlugInsertOrRemoval)

        PRSwapComplete = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'PR Swap Complete',
                                                              'offset': 4,
                                                              'bit length': 1})

        PRSwapComplete.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller completes a power role swap."""
        port0ints.addChild(PRSwapComplete)

        DRSwapComplete = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'DR Swap Complete',
                                                              'offset': 5,
                                                              'bit length': 1})

        DRSwapComplete.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller completes a data role swap."""
        port0ints.addChild(DRSwapComplete)

        FRSwapComplete = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'FR Swap Complete',
                                                              'offset': 6,
                                                              'bit length': 1})

        FRSwapComplete.help = """A Fast Role Swap has completed."""
        port0ints.addChild(FRSwapComplete)

        RdoReceivedFromSink = register_class.cBooleanDMTerminator(self,
                                                                  {'name': 'RDO Received from Sink',
                                                                   'offset': 7,
                                                                   'bit length': 1})

        RdoReceivedFromSink.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller receives an RDO (Request Data Object) from the sink device."""
        port0ints.addChild(RdoReceivedFromSink)

        Bist = register_class.cBooleanDMTerminator(self,
                                                   {'name': 'Built-In Self Test',
                                                    'offset': 8,
                                                    'bit length': 1})

        Bist.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller completes a Built-In Self Test (BIST). This bit is set whenever the STATUS.BIST changes."""
        port0ints.addChild(Bist)

        Overcurrent = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'Overcurrent Event',
                                                           'offset': 9,
                                                           'bit length': 1})

        Overcurrent.help = """when this bit is enabled, an I2C interrupt event will be set when an Overcurrent Event occurs on VBUS. This bit is set whenever STATUS.Overcurrent changes."""
        port0ints.addChild(Overcurrent)

        AttentionReceived = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Attention Received',
                                                                 'offset': 10,
                                                                 'bit length': 1})

        AttentionReceived.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller received an Attention message."""
        port0ints.addChild(AttentionReceived)

        VDMReceived = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'Vendor-Defined Message Received',
                                                           'offset': 11,
                                                           'bit length': 1})

        VDMReceived.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller receives a Vendor Defined Message from the device it is connected to."""
        port0ints.addChild(VDMReceived)

        NewContractAsCons = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'New Contract as Consumer',
                                                                 'offset': 12,
                                                                 'bit length': 1})

        NewContractAsCons.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller enters a new power contract as a Consumer (Power Sink). This bit is set when an RDO from the far-end device has been accepted and the PD Controller is a Sink. See Active Contract PDO & Active Contract RDO registers for details"""
        port0ints.addChild(NewContractAsCons)

        NewContractAsProv = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'New Contract as Provider',
                                                                 'offset': 13,
                                                                 'bit length': 1})

        NewContractAsProv.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller enters a new power contract as a Provider (Power Source). This bit is set when an RDO from the far-end device has been accepted and the PD Controller is a Source. See Active Contract PDO & Active Contract RDO registers for details"""
        port0ints.addChild(NewContractAsProv)

        SourceCapMsgReady = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Source Capabilities Message Ready',
                                                                 'offset': 14,
                                                                 'bit length': 1})

        SourceCapMsgReady.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller is ready to send its Source Capabilities message has been updated by the far end device."""
        port0ints.addChild(SourceCapMsgReady)

        SinkCapMsgReady = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Sink Capabilities Message Ready',
                                                               'offset': 15,
                                                               'bit length': 1})

        SinkCapMsgReady.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller is ready to send its Sink Capabilities message has been updated by the far end device."""
        port0ints.addChild(SinkCapMsgReady)

        LowVoltageWarning = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Low Voltage Warning',
                                                                 'offset': 16,
                                                                 'bit length': 1})

        LowVoltageWarning.help = """when this bit is enabled, an I2C interrupt event will be set when the voltage level on VBUS is lower than the expected value."""
        port0ints.addChild(LowVoltageWarning)

        PRSwapReq = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'PR Swap Requested',
                                                         'offset': 17,
                                                         'bit length': 1})

        PRSwapReq.help = """when this bit is enabled, an I2C interrupt event will be set when the device attached to the PD controller requests a power role swap."""
        port0ints.addChild(PRSwapReq)

        DRSwapReq = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'DR Swap Requested',
                                                         'offset': 18,
                                                         'bit length': 1})

        DRSwapReq.help = """when this bit is enabled, an I2C interrupt event will be set when the device attached to the PD controller requests a data role swap."""
        port0ints.addChild(DRSwapReq)

        GotoMinReceived = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Goto Min Received',
                                                               'offset': 19,
                                                               'bit length': 1})

        GotoMinReceived.help = """when this bit is enabled, an I2C interrupt event will be set when the PD Controller has received a GotoMin message while in a contract where the GiveBack flag in the RDO was set. The system needs to reduce power consumption down to the level specified in the Auto Negotiate Sink Register (0x37)."""
        port0ints.addChild(GotoMinReceived)

        UsbHostPresent = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'USB Host Present',
                                                              'offset': 20,
                                                              'bit length': 1})

        UsbHostPresent.help = """when this bit is enabled, an I2C interrupt event will be set when there is a USB Host Present on the Type-C port."""
        port0ints.addChild(UsbHostPresent)

        UsbHostPresentNoLonger = register_class.cBooleanDMTerminator(self,
                                                                     {'name': 'USB Host Present no longer',
                                                                      'offset': 21,
                                                                      'bit length': 1})

        UsbHostPresentNoLonger.help = """when this bit is enabled, an I2C interrupt event will be set when a USB Host gets removed from the Type-C port os is no longer available."""
        port0ints.addChild(UsbHostPresentNoLonger)

        HighVoltageWarning = register_class.cBooleanDMTerminator(self,
                                                                 {'name': 'High Voltage Warning',
                                                                  'offset': 22,
                                                                  'bit length': 1})

        HighVoltageWarning.help = """when this bit is enabled, an I2C interrupt event will be set when the voltage on VBUS exceeds the safe threshold."""
        port0ints.addChild(HighVoltageWarning)

        PPswitchChanged = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'PP Switch Changed',
                                                               'offset': 23,
                                                               'bit length': 1})

        PPswitchChanged.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller changes the power path that is currently sourcing or sinking power on VBUS."""
        port0ints.addChild(PPswitchChanged)

        PowerStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Power Status Update',
                                                                 'offset': 24,
                                                                 'bit length': 1})

        PowerStatusUpdate.help = """when this bit is enabled, an I2C interrupt event will be set when the PD Controller updates its power status. This is set when the contents of Register (0x3F) change."""
        port0ints.addChild(PowerStatusUpdate)

        DataStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'Data Status Update',
                                                                'offset': 25,
                                                                'bit length': 1})
        DataStatusUpdate.hide()
        DataStatusUpdate.help = """when this bit is enabled, an I2C interrupt event will be set when the data status is updated on the PD controller. This bit must be set for use with Alpine Ridge thunderbolt controllers. This interrupt is set when the contents of register (0x5F) change."""
        port0ints.addChild(DataStatusUpdate)

        StatusUpdate = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Status Update',
                                                            'offset': 26,
                                                            'bit length': 1})

        StatusUpdate.help = """when this bit is enabled, an I2C interrupt event will be set when the status of the PD controller is updated. This is set when the contents of Register (0x1A) change."""
        port0ints.addChild(StatusUpdate)

        PDStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'PD Status Update',
                                                              'offset': 27,
                                                              'bit length': 1})

        PDStatusUpdate.help = """when this bit is enabled, an I2C interrupt event will be set whenever contents of PD Status register (0x40) change"""
        port0ints.addChild(PDStatusUpdate)

        ADCLowThreshold = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'ADC Low Threshold',
                                                               'offset': 28,
                                                               'bit length': 1})

        ADCLowThreshold.help = """when this bit is enabled, an I2C interrupt event will be set when the ADC Threshold exceeds its lower boundary. (ADC_MON_THR_LO_STAT)"""
        ADCLowThreshold.hide()
        port0ints.addChild(ADCLowThreshold)

        ADCHighThreshold = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'ADC High Threshold',
                                                                'offset': 29,
                                                                'bit length': 1})

        ADCHighThreshold.help = """when this bit is enabled, an I2C interrupt event will be set when the ADC Threshold exceeds its higher boundary. (ADC_MON_THR_HI_STAT)"""
        ADCHighThreshold.hide()
        port0ints.addChild(ADCHighThreshold)

        Cmd1Complete = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'CMD1 Complete',
                                                            'offset': 30,
                                                            'bit length': 1})

        Cmd1Complete.help = """when this bit is enabled, an I2C interrupt event will be set whenever a non-zero value in CMD1 register is set to zero or !CMD."""
        port0ints.addChild(Cmd1Complete)

        Cmd2Complete = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'CMD2 Complete',
                                                            'offset': 31,
                                                            'bit length': 1})

        Cmd2Complete.help = """when this bit is enabled, an I2C interrupt event will be set whenever a non-zero value in CMD2 register is set to zero or !CMD."""
        port0ints.addChild(Cmd2Complete)

        Error_DeviceIncompatible = register_class.cBooleanDMTerminator(self,
                                                                       {'name': 'Error: Device Incompatible',
                                                                        'offset': 32,
                                                                        'bit length': 1})

        Error_DeviceIncompatible.help = """When set to 1, a USB PD device with an incompatible specification version wasconnected. Or the partner device is not USB PD capable."""
        port0ints.addChild(Error_DeviceIncompatible)

        Error_CannotProvideVoltageOrCurrent = register_class.cBooleanDMTerminator(self,
                                                                                  {
                                                                                      'name': 'Error: Cannot Provide Voltage or Current',
                                                                                      'offset': 33,
                                                                                      'bit length': 1})

        Error_CannotProvideVoltageOrCurrent.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller is unable to source the power required for the current PDO."""
        port0ints.addChild(Error_CannotProvideVoltageOrCurrent)

        Error_CanProvideVoltageOrCurrentLater = register_class.cBooleanDMTerminator(self,
                                                                                    {
                                                                                        'name': 'Error: Cannot Provide Voltage or Current Later',
                                                                                        'offset': 34,
                                                                                        'bit length': 1})

        Error_CanProvideVoltageOrCurrentLater.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller is unable to sustain sourcing the power required for the current PDO."""
        port0ints.addChild(Error_CanProvideVoltageOrCurrentLater)

        Error_PowerEventOccurred = register_class.cBooleanDMTerminator(self,
                                                                       {'name': 'Error: Power Event Occurred',
                                                                        'offset': 35,
                                                                        'bit length': 1})

        Error_PowerEventOccurred.help = """when this bit is enabled, an I2C interrupt event will be set when an OVP (Over-Voltage Protection) or short circuit event occured on VBUS"""
        port0ints.addChild(Error_PowerEventOccurred)

        Error_MissingGetCapMessage = register_class.cBooleanDMTerminator(self,
                                                                         {
                                                                             'name': 'Error: Missing Get Capabilities Message',
                                                                             'offset': 36,
                                                                             'bit length': 1})

        Error_MissingGetCapMessage.help = """when this bit is enabled, an I2C interrupt event will be set when he partner device did not respond to the Get_Sink_Cap or Get_Source_Cap message that was sent."""
        port0ints.addChild(Error_MissingGetCapMessage)

        Error_ProtError = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Error: Protocol Error',
                                                               'offset': 38,
                                                               'bit length': 1})

        Error_ProtError.help = """when this bit is enabled, an I2C interrupt event will be set when an unexpected message was received from the partner device."""

        port0ints.addChild(Error_ProtError)

        Error_MessageData = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Error: Message Data',
                                                                 'offset': 39,
                                                                 'bit length': 1})

        Error_MessageData.help = """when this bit is enabled, an I2C interrupt event will be set when a message was received and the CRC failed or the data length in the header (“Number of Data Objects”) did not match the actual amount of data received or its signal level caused the message to be deemed invalid."""
        port0ints.addChild(Error_MessageData)

        Error_DischargeFailed = register_class.cBooleanDMTerminator(self,
                                                                    {'name': 'Error: Discharge Failed',
                                                                     'offset': 41,
                                                                     'bit length': 1})

        Error_DischargeFailed.help = """when this bit is enabled, an I2C interrupt event will be set when the PD Controller fails to discharge VBUS"""
        port0ints.addChild(Error_DischargeFailed)

        SnkTransitionComplete = register_class.cBooleanDMTerminator(self,
                                                                    {'name': 'Sink Transition Complete',
                                                                     'offset': 42,
                                                                     'bit length': 1})

        SnkTransitionComplete.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully transitioned into a power sink."""
        port0ints.addChild(SnkTransitionComplete)

        iclProchot = register_class.cBooleanDMTerminator(self,
                                                         {'name': 'Ice Lake Proc Hot Notification',
                                                          'offset': 44,
                                                          'bit length': 1})
        # port0ints.addChild(ICLProcHot)

        Error_UnableToSource = register_class.cBooleanDMTerminator(self,
                                                                   {'name': 'Error: Unable to Source',
                                                                    'offset': 46,
                                                                    'bit length': 1})

        Error_UnableToSource.help = """when this bit is enabled, an I2C interrupt event will be set when the source device is unable to increase the voltage to the negotiated voltage of the PD contract."""
        port0ints.addChild(Error_UnableToSource)

        Error_BISTIg = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Error: BIST Message Ignored',
                                                            'offset': 47,
                                                            'bit length': 1})

        Error_BISTIg.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller sends a Built-In Self Test message that is ignored by the far end device."""
        port0ints.addChild(Error_BISTIg)

        AMEntryFail = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'AM Entry Failure',
                                                           'offset': 48,
                                                           'bit length': 1})

        AMEntryFail.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller fails to enter an Alternate Mode."""
        port0ints.addChild(AMEntryFail)

        AMEntered = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'AM Entered',
                                                         'offset': 49,
                                                         'bit length': 1})

        AMEntered.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully entered an Alternate Mode."""
        port0ints.addChild(AMEntered)

        VDMMsgSent = register_class.cBooleanDMTerminator(self,
                                                         {'name': 'Vendor Defined Message Sent',
                                                          'offset': 50,
                                                          'bit length': 1})

        VDMMsgSent.help = """Set when a VDM has been sent."""
        port0ints.addChild(VDMMsgSent)

        discModeComp = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Discover Mode Complete',
                                                            'offset': 51,
                                                            'bit length': 1})

        discModeComp.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully Discovered the available modes of the far end device."""
        port0ints.addChild(discModeComp)

        exitModeComp = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Exit Mode Complete',
                                                            'offset': 52,
                                                            'bit length': 1})

        exitModeComp.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully exited an Alternate Mode."""
        port0ints.addChild(exitModeComp)

        UserSvidModeEntered = register_class.cBooleanDMTerminator(self,
                                                                  {'name': 'User SVID Mode Entered',
                                                                   'offset': 56,
                                                                   'bit length': 1})

        UserSvidModeEntered.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully entered a users SVID mode."""
        port0ints.addChild(UserSvidModeEntered)

        UserSvidModeExited = register_class.cBooleanDMTerminator(self,
                                                                 {'name': 'User SVID Mode Exited',
                                                                  'offset': 57,
                                                                  'bit length': 1})

        UserSvidModeExited.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has exited a users SVID mode."""
        port0ints.addChild(UserSvidModeExited)

        UserSvidAttentionVDMReceived = register_class.cBooleanDMTerminator(self,
                                                                           {'name': 'User SVID Attention VDM Received',
                                                                            'offset': 58,
                                                                            'bit length': 1})

        UserSvidAttentionVDMReceived.help = """when this bit is enabled, an I2C interrupt event will be set when a users SVID structured attention vendor defined message is received."""
        port0ints.addChild(UserSvidAttentionVDMReceived)

        UserSvidOtherVDMReceived = register_class.cBooleanDMTerminator(self,
                                                                       {'name': 'User SVID Other VDM Received',
                                                                        'offset': 59,
                                                                        'bit length': 1})

        UserSvidOtherVDMReceived.help = """when this bit is enabled, an I2C interrupt event will be set when a users SVID structured non-Attention VDM or unstructured VDM has been received."""
        port0ints.addChild(UserSvidOtherVDMReceived)

        DPSIDStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'DP SID Status Update',
                                                                 'offset': 62,
                                                                 'bit length': 1})

        DPSIDStatusUpdate.help = """Set when the contents of the DP SID Status register (0x58) change."""
        port0ints.addChild(DPSIDStatusUpdate)

        IntelVIDStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                                   {'name': 'Intel VID Status Update',
                                                                    'offset': 63,
                                                                    'bit length': 1})
        IntelVIDStatusUpdate.hide()
        IntelVIDStatusUpdate.help = """Set when the contents of the Intel VID Status register (0x59) change."""
        port0ints.addChild(IntelVIDStatusUpdate)

        PD3StatusUpdate = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'PD3 Status Update',
                                                               'offset': 64,
                                                               'bit length': 1})

        PD3StatusUpdate.help = """Set when the contents of the PD3.0 Status register (0x41) change."""
        port0ints.addChild(PD3StatusUpdate)

        TXMemBufferEmpty = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'TX Mem Buffer Empty',
                                                                'offset': 65,
                                                                'bit length': 1})

        TXMemBufferEmpty.help = """Transmit memory buffer empty."""
        port0ints.addChild(TXMemBufferEmpty)

        RXMemBufferFull = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'RX Mem Buffer Full',
                                                               'offset': 66,
                                                               'bit length': 1})

        RXMemBufferFull.help = """Transmit memory buffer empty."""
        port0ints.addChild(RXMemBufferFull)

        CustomDVDMArrive = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'Custom VDM Arrive',
                                                                'offset': 67,
                                                                'bit length': 1})

        CustomDVDMArrive.help = """A custom VDM has arrived"""
        port0ints.addChild(CustomDVDMArrive)

        CustomDAMEntered = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'Custom AM Entered',
                                                                'offset': 68,
                                                                'bit length': 1})

        CustomDAMEntered.help = """A custom Alternate Mode has been entered."""
        port0ints.addChild(CustomDAMEntered)

        CustomDVDMMSGSENT = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Custom VDM Message Sent',
                                                                 'offset': 69,
                                                                 'bit length': 1})

        CustomDVDMMSGSENT.help = """A custom VDM has been sent."""
        port0ints.addChild(CustomDVDMMSGSENT)

        ackTime = register_class.cBooleanDMTerminator(self,
                                                      {'name': 'SOC ACK Timeout',
                                                       'offset': 70,
                                                       'bit length': 1})

        ackTime.help = """ACK Timeout Occurred."""
        port0ints.addChild(ackTime)

        FRSSignalReceived = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'FRS Signal Received',
                                                                 'offset': 76,
                                                                 'bit length': 1})

        FRSSignalReceived.help = """An FRS Message has been received."""
        port0ints.addChild(FRSSignalReceived)

        ChunkResponseReceived = register_class.cBooleanDMTerminator(self,
                                                                    {'name': 'Chunk Response Received',
                                                                     'offset': 77,
                                                                     'bit length': 1})

        ChunkResponseReceived.help = """Chunk Response message received."""
        port0ints.addChild(ChunkResponseReceived)

        ChunkRequestReceived = register_class.cBooleanDMTerminator(self,
                                                                   {'name': 'Chunk Request Received',
                                                                    'offset': 78,
                                                                    'bit length': 1})

        ChunkRequestReceived.help = """Chunk Request message received."""
        port0ints.addChild(ChunkRequestReceived)

        AlertMessageReceived = register_class.cBooleanDMTerminator(self,
                                                                   {'name': 'Alert Message Received',
                                                                    'offset': 79,
                                                                    'bit length': 1})

        AlertMessageReceived.help = """An Alert Messae has been received."""
        port0ints.addChild(AlertMessageReceived)

        commonInts = register_class.cDataModelArray(self, 1,
                                                    {'name': 'Common Interrupt Mask for I2C1',
                                                     'offset': 80,
                                                     'bit length': 8})

        self.dataModel.addChild(commonInts)

        patchLoaded = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'Patch Loaded',
                                                           'offset': 0,
                                                           'bit length': 1})

        patchLoaded.help = """when this bit is enabled, an I2C interrupt event will be set when a patch has been loaded onto the device."""
        commonInts.addChild(patchLoaded)

        readyPatch = register_class.cBooleanDMTerminator(self,
                                                         {'name': 'Ready for Patch',
                                                          'offset': 1,
                                                          'bit length': 1})

        readyPatch.help = """when this bit is enabled, an I2C interrupt event will be set when the device is ready to receive a patch."""
        commonInts.addChild(readyPatch)


########################################################################################################################
########################################################################################################################
########################################################################################################################


class cIntMask1_0x16_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Interrupt Mask for I2C1',
                                                 'address': 0x16,
                                                 'byte length': 11,
                                                 'permission': 'RW'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name': 'Interrupt Mask for I2C1',
                                                         'offset': 0,
                                                         'bit length': 88})

        port0ints = register_class.cDataModelArray(self, 1,
                                                   {'name': 'Port Interrupt Mask for I2C1',
                                                    'offset': 0,
                                                    'bit length': 80})

        self.dataModel.addChild(port0ints)

        SoftReset = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'Soft Reset',
                                                         'offset': 0,
                                                         'bit length': 1})

        SoftReset.help = """When this bit is enabled, an I2C interrupt event will be set when a PD Soft Reset has been performed. See PD Status.SoftResetType for more information."""
        port0ints.addChild(SoftReset)

        HardReset = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'Hard Reset',
                                                         'offset': 1,
                                                         'bit length': 1})

        HardReset.help = """when this bit is enabled, an I2C interrupt event will be set when a PD Hard Reset has been performed. See PD Status.HardResetDetails for more information."""
        port0ints.addChild(HardReset)

        CableResetEvent = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Cable Reset Event',
                                                               'offset': 2,
                                                               'bit length': 1})

        CableResetEvent.help = """This event occurs when PD Controller sends Cable Reset signaling."""
        port0ints.addChild(CableResetEvent)

        PlugInsertOrRemoval = register_class.cBooleanDMTerminator(self,
                                                                  {'name': 'Plug Insert or Removal',
                                                                   'offset': 3,
                                                                   'bit length': 1})

        PlugInsertOrRemoval.help = """when this bit is enabled, an I2C interrupt event will be set when the user inserts or removes a plug into the Type-C port."""
        port0ints.addChild(PlugInsertOrRemoval)

        PRSwapComplete = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'PR Swap Complete',
                                                              'offset': 4,
                                                              'bit length': 1})

        PRSwapComplete.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller completes a power role swap."""
        port0ints.addChild(PRSwapComplete)

        DRSwapComplete = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'DR Swap Complete',
                                                              'offset': 5,
                                                              'bit length': 1})

        DRSwapComplete.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller completes a data role swap."""
        port0ints.addChild(DRSwapComplete)

        FRSwapComplete = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'FR Swap Complete',
                                                              'offset': 6,
                                                              'bit length': 1})

        FRSwapComplete.help = """A Fast Role Swap has completed."""
        port0ints.addChild(FRSwapComplete)

        RdoReceivedFromSink = register_class.cBooleanDMTerminator(self,
                                                                  {'name': 'RDO Received from Sink',
                                                                   'offset': 7,
                                                                   'bit length': 1})

        RdoReceivedFromSink.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller receives an RDO (Request Data Object) from the sink device."""
        port0ints.addChild(RdoReceivedFromSink)

        Bist = register_class.cBooleanDMTerminator(self,
                                                   {'name': 'Built-In Self Test',
                                                    'offset': 8,
                                                    'bit length': 1})

        Bist.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller completes a Built-In Self Test (BIST). This bit is set whenever the STATUS.BIST changes."""
        port0ints.addChild(Bist)

        Overcurrent = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'Overcurrent Event',
                                                           'offset': 9,
                                                           'bit length': 1})

        Overcurrent.help = """when this bit is enabled, an I2C interrupt event will be set when an Overcurrent Event occurs on VBUS. This bit is set whenever STATUS.Overcurrent changes."""
        port0ints.addChild(Overcurrent)

        AttentionReceived = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Attention Received',
                                                                 'offset': 10,
                                                                 'bit length': 1})

        AttentionReceived.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller received an Attention message."""
        port0ints.addChild(AttentionReceived)

        VDMReceived = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'Vendor-Defined Message Received',
                                                           'offset': 11,
                                                           'bit length': 1})

        VDMReceived.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller receives a Vendor Defined Message from the device it is connected to."""
        port0ints.addChild(VDMReceived)

        NewContractAsCons = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'New Contract as Consumer',
                                                                 'offset': 12,
                                                                 'bit length': 1})

        NewContractAsCons.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller enters a new power contract as a Consumer (Power Sink). This bit is set when an RDO from the far-end device has been accepted and the PD Controller is a Sink. See Active Contract PDO & Active Contract RDO registers for details"""
        port0ints.addChild(NewContractAsCons)

        NewContractAsProv = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'New Contract as Provider',
                                                                 'offset': 13,
                                                                 'bit length': 1})

        NewContractAsProv.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller enters a new power contract as a Provider (Power Source). This bit is set when an RDO from the far-end device has been accepted and the PD Controller is a Source. See Active Contract PDO & Active Contract RDO registers for details"""
        port0ints.addChild(NewContractAsProv)

        SourceCapMsgReady = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Source Capabilities Message Ready',
                                                                 'offset': 14,
                                                                 'bit length': 1})

        SourceCapMsgReady.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller is ready to send its Source Capabilities message has been updated by the far end device."""
        port0ints.addChild(SourceCapMsgReady)

        SinkCapMsgReady = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Sink Capabilities Message Ready',
                                                               'offset': 15,
                                                               'bit length': 1})

        SinkCapMsgReady.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller is ready to send its Sink Capabilities message has been updated by the far end device."""
        port0ints.addChild(SinkCapMsgReady)

        LowVoltageWarning = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Low Voltage Warning',
                                                                 'offset': 16,
                                                                 'bit length': 1})

        LowVoltageWarning.help = """when this bit is enabled, an I2C interrupt event will be set when the voltage level on VBUS is lower than the expected value."""
        port0ints.addChild(LowVoltageWarning)

        PRSwapReq = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'PR Swap Requested',
                                                         'offset': 17,
                                                         'bit length': 1})

        PRSwapReq.help = """when this bit is enabled, an I2C interrupt event will be set when the device attached to the PD controller requests a power role swap."""
        port0ints.addChild(PRSwapReq)

        DRSwapReq = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'DR Swap Requested',
                                                         'offset': 18,
                                                         'bit length': 1})

        DRSwapReq.help = """when this bit is enabled, an I2C interrupt event will be set when the device attached to the PD controller requests a data role swap."""
        port0ints.addChild(DRSwapReq)

        GotoMinReceived = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Goto Min Received',
                                                               'offset': 19,
                                                               'bit length': 1})

        GotoMinReceived.help = """when this bit is enabled, an I2C interrupt event will be set when the PD Controller has received a GotoMin message while in a contract where the GiveBack flag in the RDO was set. The system needs to reduce power consumption down to the level specified in the Auto Negotiate Sink Register (0x37)."""
        port0ints.addChild(GotoMinReceived)

        UsbHostPresent = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'USB Host Present',
                                                              'offset': 20,
                                                              'bit length': 1})

        UsbHostPresent.help = """when this bit is enabled, an I2C interrupt event will be set when there is a USB Host Present on the Type-C port."""
        port0ints.addChild(UsbHostPresent)

        UsbHostPresentNoLonger = register_class.cBooleanDMTerminator(self,
                                                                     {'name': 'USB Host Present no longer',
                                                                      'offset': 21,
                                                                      'bit length': 1})

        UsbHostPresentNoLonger.help = """when this bit is enabled, an I2C interrupt event will be set when a USB Host gets removed from the Type-C port os is no longer available."""
        port0ints.addChild(UsbHostPresentNoLonger)

        HighVoltageWarning = register_class.cBooleanDMTerminator(self,
                                                                 {'name': 'High Voltage Warning',
                                                                  'offset': 22,
                                                                  'bit length': 1})

        HighVoltageWarning.help = """when this bit is enabled, an I2C interrupt event will be set when the voltage on VBUS exceeds the safe threshold."""
        port0ints.addChild(HighVoltageWarning)

        PPswitchChanged = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'PP Switch Changed',
                                                               'offset': 23,
                                                               'bit length': 1})

        PPswitchChanged.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller changes the power path that is currently sourcing or sinking power on VBUS."""
        port0ints.addChild(PPswitchChanged)

        PowerStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Power Status Update',
                                                                 'offset': 24,
                                                                 'bit length': 1})

        PowerStatusUpdate.help = """when this bit is enabled, an I2C interrupt event will be set when the PD Controller updates its power status. This is set when the contents of Register (0x3F) change."""
        port0ints.addChild(PowerStatusUpdate)

        DataStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'Data Status Update',
                                                                'offset': 25,
                                                                'bit length': 1})
        DataStatusUpdate.hide()
        DataStatusUpdate.help = """when this bit is enabled, an I2C interrupt event will be set when the data status is updated on the PD controller. This bit must be set for use with Alpine Ridge thunderbolt controllers. This interrupt is set when the contents of register (0x5F) change."""
        port0ints.addChild(DataStatusUpdate)

        StatusUpdate = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Status Update',
                                                            'offset': 26,
                                                            'bit length': 1})

        StatusUpdate.help = """when this bit is enabled, an I2C interrupt event will be set when the status of the PD controller is updated. This is set when the contents of Register (0x1A) change."""
        port0ints.addChild(StatusUpdate)

        PDStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'PD Status Update',
                                                              'offset': 27,
                                                              'bit length': 1})

        PDStatusUpdate.help = """when this bit is enabled, an I2C interrupt event will be set whenever contents of PD Status register (0x40) change"""
        port0ints.addChild(PDStatusUpdate)

        ADCLowThreshold = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'ADC Low Threshold',
                                                               'offset': 28,
                                                               'bit length': 1})

        ADCLowThreshold.help = """when this bit is enabled, an I2C interrupt event will be set when the ADC Threshold exceeds its lower boundary. (ADC_MON_THR_LO_STAT)"""
        ADCLowThreshold.hide()
        port0ints.addChild(ADCLowThreshold)

        ADCHighThreshold = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'ADC High Threshold',
                                                                'offset': 29,
                                                                'bit length': 1})

        ADCHighThreshold.help = """when this bit is enabled, an I2C interrupt event will be set when the ADC Threshold exceeds its higher boundary. (ADC_MON_THR_HI_STAT)"""
        ADCHighThreshold.hide()
        port0ints.addChild(ADCHighThreshold)

        Cmd1Complete = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'CMD1 Complete',
                                                            'offset': 30,
                                                            'bit length': 1})

        Cmd1Complete.help = """when this bit is enabled, an I2C interrupt event will be set whenever a non-zero value in CMD1 register is set to zero or !CMD."""
        port0ints.addChild(Cmd1Complete)

        Cmd2Complete = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'CMD2 Complete',
                                                            'offset': 31,
                                                            'bit length': 1})

        Cmd2Complete.help = """when this bit is enabled, an I2C interrupt event will be set whenever a non-zero value in CMD2 register is set to zero or !CMD."""
        port0ints.addChild(Cmd2Complete)

        Error_DeviceIncompatible = register_class.cBooleanDMTerminator(self,
                                                                       {'name': 'Error: Device Incompatible',
                                                                        'offset': 32,
                                                                        'bit length': 1})

        Error_DeviceIncompatible.help = """When set to 1, a USB PD device with an incompatible specification version wasconnected. Or the partner device is not USB PD capable."""
        port0ints.addChild(Error_DeviceIncompatible)

        Error_CannotProvideVoltageOrCurrent = register_class.cBooleanDMTerminator(self,
                                                                                  {
                                                                                      'name': 'Error: Cannot Provide Voltage or Current',
                                                                                      'offset': 33,
                                                                                      'bit length': 1})

        Error_CannotProvideVoltageOrCurrent.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller is unable to source the power required for the current PDO."""
        port0ints.addChild(Error_CannotProvideVoltageOrCurrent)

        Error_CanProvideVoltageOrCurrentLater = register_class.cBooleanDMTerminator(self,
                                                                                    {
                                                                                        'name': 'Error: Cannot Provide Voltage or Current Later',
                                                                                        'offset': 34,
                                                                                        'bit length': 1})

        Error_CanProvideVoltageOrCurrentLater.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller is unable to sustain sourcing the power required for the current PDO."""
        port0ints.addChild(Error_CanProvideVoltageOrCurrentLater)

        Error_PowerEventOccurred = register_class.cBooleanDMTerminator(self,
                                                                       {'name': 'Error: Power Event Occurred',
                                                                        'offset': 35,
                                                                        'bit length': 1})

        Error_PowerEventOccurred.help = """when this bit is enabled, an I2C interrupt event will be set when an OVP (Over-Voltage Protection) or short circuit event occured on VBUS"""
        port0ints.addChild(Error_PowerEventOccurred)

        Error_MissingGetCapMessage = register_class.cBooleanDMTerminator(self,
                                                                         {
                                                                             'name': 'Error: Missing Get Capabilities Message',
                                                                             'offset': 36,
                                                                             'bit length': 1})

        Error_MissingGetCapMessage.help = """when this bit is enabled, an I2C interrupt event will be set when he partner device did not respond to the Get_Sink_Cap or Get_Source_Cap message that was sent."""
        port0ints.addChild(Error_MissingGetCapMessage)

        Error_ProtError = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Error: Protocol Error',
                                                               'offset': 38,
                                                               'bit length': 1})

        Error_ProtError.help = """when this bit is enabled, an I2C interrupt event will be set when an unexpected message was received from the partner device."""

        port0ints.addChild(Error_ProtError)

        Error_MessageData = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Error: Message Data',
                                                                 'offset': 39,
                                                                 'bit length': 1})

        Error_MessageData.help = """when this bit is enabled, an I2C interrupt event will be set when a message was received and the CRC failed or the data length in the header (“Number of Data Objects”) did not match the actual amount of data received or its signal level caused the message to be deemed invalid."""
        port0ints.addChild(Error_MessageData)

        Error_DischargeFailed = register_class.cBooleanDMTerminator(self,
                                                                    {'name': 'Error: Discharge Failed',
                                                                     'offset': 41,
                                                                     'bit length': 1})

        Error_DischargeFailed.help = """when this bit is enabled, an I2C interrupt event will be set when the PD Controller fails to discharge VBUS"""
        port0ints.addChild(Error_DischargeFailed)

        SnkTransitionComplete = register_class.cBooleanDMTerminator(self,
                                                                    {'name': 'Sink Transition Complete',
                                                                     'offset': 42,
                                                                     'bit length': 1})

        SnkTransitionComplete.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully transitioned into a power sink."""
        port0ints.addChild(SnkTransitionComplete)

        iclProchot = register_class.cBooleanDMTerminator(self,
                                                         {'name': 'Ice Lake Proc Hot Notification',
                                                          'offset': 44,
                                                          'bit length': 1})
        # port0ints.addChild(ICLProcHot)

        Error_UnableToSource = register_class.cBooleanDMTerminator(self,
                                                                   {'name': 'Error: Unable to Source',
                                                                    'offset': 46,
                                                                    'bit length': 1})

        Error_UnableToSource.help = """when this bit is enabled, an I2C interrupt event will be set when the source device is unable to increase the voltage to the negotiated voltage of the PD contract."""
        port0ints.addChild(Error_UnableToSource)

        Error_BISTIg = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Error: BIST Message Ignored',
                                                            'offset': 47,
                                                            'bit length': 1})

        Error_BISTIg.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller sends a Built-In Self Test message that is ignored by the far end device."""
        port0ints.addChild(Error_BISTIg)

        AMEntryFail = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'AM Entry Failure',
                                                           'offset': 48,
                                                           'bit length': 1})

        AMEntryFail.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller fails to enter an Alternate Mode."""
        port0ints.addChild(AMEntryFail)

        AMEntered = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'AM Entered',
                                                         'offset': 49,
                                                         'bit length': 1})

        AMEntered.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully entered an Alternate Mode."""
        port0ints.addChild(AMEntered)

        VDMMsgSent = register_class.cBooleanDMTerminator(self,
                                                         {'name': 'Vendor Defined Message Sent',
                                                          'offset': 50,
                                                          'bit length': 1})

        VDMMsgSent.help = """Set when a VDM has been sent."""
        port0ints.addChild(VDMMsgSent)

        discModeComp = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Discover Mode Complete',
                                                            'offset': 51,
                                                            'bit length': 1})

        discModeComp.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully Discovered the available modes of the far end device."""
        port0ints.addChild(discModeComp)

        exitModeComp = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Exit Mode Complete',
                                                            'offset': 52,
                                                            'bit length': 1})

        exitModeComp.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully exited an Alternate Mode."""
        port0ints.addChild(exitModeComp)

        UserSvidModeEntered = register_class.cBooleanDMTerminator(self,
                                                                  {'name': 'User SVID Mode Entered',
                                                                   'offset': 56,
                                                                   'bit length': 1})

        UserSvidModeEntered.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully entered a users SVID mode."""
        port0ints.addChild(UserSvidModeEntered)

        UserSvidModeExited = register_class.cBooleanDMTerminator(self,
                                                                 {'name': 'User SVID Mode Exited',
                                                                  'offset': 57,
                                                                  'bit length': 1})

        UserSvidModeExited.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has exited a users SVID mode."""
        port0ints.addChild(UserSvidModeExited)

        UserSvidAttentionVDMReceived = register_class.cBooleanDMTerminator(self,
                                                                           {'name': 'User SVID Attention VDM Received',
                                                                            'offset': 58,
                                                                            'bit length': 1})

        UserSvidAttentionVDMReceived.help = """when this bit is enabled, an I2C interrupt event will be set when a users SVID structured attention vendor defined message is received."""
        port0ints.addChild(UserSvidAttentionVDMReceived)

        UserSvidOtherVDMReceived = register_class.cBooleanDMTerminator(self,
                                                                       {'name': 'User SVID Other VDM Received',
                                                                        'offset': 59,
                                                                        'bit length': 1})

        UserSvidOtherVDMReceived.help = """when this bit is enabled, an I2C interrupt event will be set when a users SVID structured non-Attention VDM or unstructured VDM has been received."""
        port0ints.addChild(UserSvidOtherVDMReceived)

        DPSIDStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'DP SID Status Update',
                                                                 'offset': 62,
                                                                 'bit length': 1})

        DPSIDStatusUpdate.help = """Set when the contents of the DP SID Status register (0x58) change."""
        port0ints.addChild(DPSIDStatusUpdate)

        IntelVIDStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                                   {'name': 'Intel VID Status Update',
                                                                    'offset': 63,
                                                                    'bit length': 1})
        IntelVIDStatusUpdate.hide()
        IntelVIDStatusUpdate.help = """Set when the contents of the Intel VID Status register (0x59) change."""
        port0ints.addChild(IntelVIDStatusUpdate)

        PD3StatusUpdate = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'PD3 Status Update',
                                                               'offset': 64,
                                                               'bit length': 1})

        PD3StatusUpdate.help = """Set when the contents of the PD3.0 Status register (0x41) change."""
        port0ints.addChild(PD3StatusUpdate)

        TXMemBufferEmpty = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'TX Mem Buffer Empty',
                                                                'offset': 65,
                                                                'bit length': 1})

        TXMemBufferEmpty.help = """Transmit memory buffer empty."""
        port0ints.addChild(TXMemBufferEmpty)

        RXMemBufferFull = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'RX Mem Buffer Full',
                                                               'offset': 66,
                                                               'bit length': 1})

        RXMemBufferFull.help = """Transmit memory buffer empty."""
        port0ints.addChild(RXMemBufferFull)

        CustomDVDMArrive = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'Custom VDM Arrive',
                                                                'offset': 67,
                                                                'bit length': 1})

        CustomDVDMArrive.help = """A custom VDM has arrived"""
        port0ints.addChild(CustomDVDMArrive)

        CustomDAMEntered = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'Custom AM Entered',
                                                                'offset': 68,
                                                                'bit length': 1})

        CustomDAMEntered.help = """A custom Alternate Mode has been entered."""
        port0ints.addChild(CustomDAMEntered)

        CustomDVDMMSGSENT = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Custom VDM Message Sent',
                                                                 'offset': 69,
                                                                 'bit length': 1})

        CustomDVDMMSGSENT.help = """A custom VDM has been sent."""
        port0ints.addChild(CustomDVDMMSGSENT)

        ackTime = register_class.cBooleanDMTerminator(self,
                                                      {'name': 'SOC ACK Timeout',
                                                       'offset': 70,
                                                       'bit length': 1})

        ackTime.help = """ACK Timeout Occurred."""
        port0ints.addChild(ackTime)

        FRSSignalReceived = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'FRS Signal Received',
                                                                 'offset': 76,
                                                                 'bit length': 1})

        FRSSignalReceived.help = """An FRS Message has been received."""
        port0ints.addChild(FRSSignalReceived)

        ChunkResponseReceived = register_class.cBooleanDMTerminator(self,
                                                                    {'name': 'Chunk Response Received',
                                                                     'offset': 77,
                                                                     'bit length': 1})

        ChunkResponseReceived.help = """Chunk Response message received."""
        port0ints.addChild(ChunkResponseReceived)

        ChunkRequestReceived = register_class.cBooleanDMTerminator(self,
                                                                   {'name': 'Chunk Request Received',
                                                                    'offset': 78,
                                                                    'bit length': 1})

        ChunkRequestReceived.help = """Chunk Request message received."""
        port0ints.addChild(ChunkRequestReceived)

        AlertMessageReceived = register_class.cBooleanDMTerminator(self,
                                                                   {'name': 'Alert Message Received',
                                                                    'offset': 79,
                                                                    'bit length': 1})

        AlertMessageReceived.help = """An Alert Messae has been received."""
        port0ints.addChild(AlertMessageReceived)

        commonInts = register_class.cDataModelArray(self, 1,
                                                    {'name': 'Common Interrupt Mask for I2C1',
                                                     'offset': 80,
                                                     'bit length': 8})

        self.dataModel.addChild(commonInts)

        patchLoaded = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'Patch Loaded',
                                                           'offset': 0,
                                                           'bit length': 1})

        patchLoaded.help = """when this bit is enabled, an I2C interrupt event will be set when a patch has been loaded onto the device."""
        commonInts.addChild(patchLoaded)

        readyPatch = register_class.cBooleanDMTerminator(self,
                                                         {'name': 'Ready for Patch',
                                                          'offset': 1,
                                                          'bit length': 1})

        readyPatch.help = """when this bit is enabled, an I2C interrupt event will be set when the device is ready to receive a patch."""
        commonInts.addChild(readyPatch)


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cData1_0x09_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Data Register for CMD1',
                                                 'address': 0x09,
                                                 'byte length': 4,
                                                 'permission': 'DRW'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'Data Register for CMD1',
                                                         'offset': 0,
                                                         'bit length': 32})

        word1 = register_class.cHexDMTerminator(self,
                                                {'name': 'Word 1 (Least Significant)',
                                                 'offset': 0,
                                                 'bit length': 32})

        self.dataModel.addChild(word1)

        word2 = register_class.cHexDMTerminator(self,
                                                {'name': 'Word 2',
                                                 'offset': 32,
                                                 'bit length': 32})

        self.dataModel.addChild(word2)

        word3 = register_class.cHexDMTerminator(self,
                                                {'name': 'Word 3',
                                                 'offset': 64,
                                                 'bit length': 32})

        self.dataModel.addChild(word3)

        word4 = register_class.cHexDMTerminator(self,
                                                {'name': 'Word 4',
                                                 'offset': 96,
                                                 'bit length': 32})

        self.dataModel.addChild(word4)

        word5 = register_class.cHexDMTerminator(self,
                                                {'name': 'Word 5',
                                                 'offset': 128,
                                                 'bit length': 32})

        self.dataModel.addChild(word5)

        word6 = register_class.cHexDMTerminator(self,
                                                {'name': 'Word 6',
                                                 'offset': 160,
                                                 'bit length': 32})

        self.dataModel.addChild(word6)

        word7 = register_class.cHexDMTerminator(self,
                                                {'name': 'Word 7',
                                                 'offset': 192,
                                                 'bit length': 32})

        self.dataModel.addChild(word7)

        word8 = register_class.cHexDMTerminator(self,
                                                {'name': 'Word 8',
                                                 'offset': 224,
                                                 'bit length': 32})

        self.dataModel.addChild(word8)

        word9 = register_class.cHexDMTerminator(self,
                                                {'name': 'Word 9',
                                                 'offset': 256,
                                                 'bit length': 32})

        self.dataModel.addChild(word9)

        word10 = register_class.cHexDMTerminator(self,
                                                 {'name': 'Word 10',
                                                  'offset': 288,
                                                  'bit length': 32})

        self.dataModel.addChild(word10)

        word11 = register_class.cHexDMTerminator(self,
                                                 {'name': 'Word 11',
                                                  'offset': 320,
                                                  'bit length': 32})

        self.dataModel.addChild(word11)

        word12 = register_class.cHexDMTerminator(self,
                                                 {'name': 'Word 12',
                                                  'offset': 352,
                                                  'bit length': 32})

        self.dataModel.addChild(word12)

        word13 = register_class.cHexDMTerminator(self,
                                                 {'name': 'Word 13',
                                                  'offset': 384,
                                                  'bit length': 32})

        self.dataModel.addChild(word13)

        word14 = register_class.cHexDMTerminator(self,
                                                 {'name': 'Word 14',
                                                  'offset': 416,
                                                  'bit length': 32})

        self.dataModel.addChild(word14)

        word15 = register_class.cHexDMTerminator(self,
                                                 {'name': 'Word 15',
                                                  'offset': 448,
                                                  'bit length': 32})

        self.dataModel.addChild(word15)

        word16 = register_class.cHexDMTerminator(self,
                                                 {'name': 'Word 16',
                                                  'offset': 480,
                                                  'bit length': 32})

        self.dataModel.addChild(word16)


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cVersion_0x0f_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Version',
                                                 'address': 0x0f,
                                                 'byte length': 4,
                                                 'permission': 'DRO'})

        self.setAsShared()

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'Version',
                                                         'offset': 0,
                                                         'bit length': 32})

        versionData = register_class.cHexDMTerminator(self,
                                                      {'name': 'Version',
                                                       'offset': 0,
                                                       'bit length': 32})
        versionData.help = """Binary Coded Decimal version number, bootloader/application code version. Represented as VVVV.MM.RR with leading 0's removed \
                                \n\ne.g. 65794d (decimal) -> 0x00010102 -> 0001.01.02 -> 1.1.2 (version). The version information is returned in little Endian format i.e. byte 1 = RR, byte 2 = MM, etc. """
        self.dataModel.addChild(versionData)


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cCmd2_0x10_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Command Register for CMD2',
                                                 'address': 0x10,
                                                 'byte length': 4,
                                                 'permission': 'DRW'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'Command Register for CMD1',
                                                         'offset': 0,
                                                         'bit length': 32})

        word1 = register_class.cHexDMTerminator(self,
                                                {'name': 'Word 1 (Least Significant)',
                                                 'offset': 0,
                                                 'bit length': 32})

        word1.help = """Command register used for the secondary command interface.
Shall be cleared to 0x00000000 by PD Controller during
initialization and after successful processing of every command. If
an unrecognized command is written to this register it shall be
replaced by a 4CC value of “!CMD”."""
        self.dataModel.addChild(word1)


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cData2_0x11_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Data Register for CMD2',
                                                 'address': 0x11,
                                                 'byte length': 4,
                                                 'permission': 'DRW'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'Data Register for CMD2',
                                                         'offset': 0,
                                                         'bit length': 32})

        word1 = register_class.cHexDMTerminator(self,
                                                {'name': 'Word 1 (Least Significant)',
                                                 'offset': 0,
                                                 'bit length': 32})
        word1.help = """Data register used for the secondary command interface."""
        self.dataModel.addChild(word1)

        word2 = register_class.cHexDMTerminator(self,
                                                {'name': 'Word 2',
                                                 'offset': 32,
                                                 'bit length': 32})

        self.dataModel.addChild(word2)

        word3 = register_class.cHexDMTerminator(self,
                                                {'name': 'Word 3',
                                                 'offset': 64,
                                                 'bit length': 32})

        self.dataModel.addChild(word3)

        word4 = register_class.cHexDMTerminator(self,
                                                {'name': 'Word 4',
                                                 'offset': 96,
                                                 'bit length': 32})

        self.dataModel.addChild(word4)

        word5 = register_class.cHexDMTerminator(self,
                                                {'name': 'Word 5',
                                                 'offset': 128,
                                                 'bit length': 32})

        self.dataModel.addChild(word5)

        word6 = register_class.cHexDMTerminator(self,
                                                {'name': 'Word 6',
                                                 'offset': 160,
                                                 'bit length': 32})

        self.dataModel.addChild(word6)

        word7 = register_class.cHexDMTerminator(self,
                                                {'name': 'Word 7',
                                                 'offset': 192,
                                                 'bit length': 32})

        self.dataModel.addChild(word7)

        word8 = register_class.cHexDMTerminator(self,
                                                {'name': 'Word 8',
                                                 'offset': 224,
                                                 'bit length': 32})

        self.dataModel.addChild(word8)

        word9 = register_class.cHexDMTerminator(self,
                                                {'name': 'Word 9',
                                                 'offset': 256,
                                                 'bit length': 32})

        self.dataModel.addChild(word9)

        word10 = register_class.cHexDMTerminator(self,
                                                 {'name': 'Word 10',
                                                  'offset': 288,
                                                  'bit length': 32})

        self.dataModel.addChild(word10)

        word11 = register_class.cHexDMTerminator(self,
                                                 {'name': 'Word 11',
                                                  'offset': 320,
                                                  'bit length': 32})

        self.dataModel.addChild(word11)

        word12 = register_class.cHexDMTerminator(self,
                                                 {'name': 'Word 12',
                                                  'offset': 352,
                                                  'bit length': 32})

        self.dataModel.addChild(word12)

        word13 = register_class.cHexDMTerminator(self,
                                                 {'name': 'Word 13',
                                                  'offset': 384,
                                                  'bit length': 32})

        self.dataModel.addChild(word13)

        word14 = register_class.cHexDMTerminator(self,
                                                 {'name': 'Word 14',
                                                  'offset': 416,
                                                  'bit length': 32})

        self.dataModel.addChild(word14)

        word15 = register_class.cHexDMTerminator(self,
                                                 {'name': 'Word 15',
                                                  'offset': 448,
                                                  'bit length': 32})

        self.dataModel.addChild(word15)

        word16 = register_class.cHexDMTerminator(self,
                                                 {'name': 'Word 16',
                                                  'offset': 480,
                                                  'bit length': 32})

        self.dataModel.addChild(word16)


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cExtData2_0x12_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Extended Data 2',
                                                 'address': 0x12,
                                                 'byte length': 64,
                                                 'permission': 'DRW'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'Extended Data 2',
                                                         'offset': 0,
                                                         'bit length': 512})

        extData2 = register_class.cHexDMTerminator(self,
                                                   {'name': 'Extended Data 2',
                                                    'offset': 0,
                                                    'bit length': 512})
        extData2.help = """Extended Data2 register. Used for Cmd2 4CCs that need Data2 purely for 64 bytes of data but still require control/status payloads. """
        self.dataModel.addChild(extData2)


class cExtData1_0x13_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Extended Data 1',
                                                 'address': 0x13,
                                                 'byte length': 64,
                                                 'permission': 'DRW'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'Extended Data 1',
                                                         'offset': 0,
                                                         'bit length': 512})

        extData1 = register_class.cHexDMTerminator(self,
                                                   {'name': 'External Data 1',
                                                    'offset': 0,
                                                    'bit length': 512})
        extData1.help = """Extended Data1 register. Used for Cmd1 4CCs that need Data1 purely for 64 bytes of data but still require control/status payloads. """
        self.dataModel.addChild(extData1)


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cStatus_0x1A_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Status',
                                                 'address': 0x1A,
                                                 'byte length': 6,
                                                 'permission': 'DRO'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'Status',
                                                         'offset': 0,
                                                         'bit length': 48})

        plugPresent = register_class.cListDMTerminator(self,
                                                       {'name': 'Plug Present',
                                                        'offset': 0,
                                                        'bit length': 1})

        plugPresent.setReportList(['No plug present', 'Plug present, see Conn State (below) for details.'])
        plugPresent.help = """Indicates presence of plug"""
        self.dataModel.addChild(plugPresent)

        connState = register_class.cListDMTerminator(self,
                                                     {'name': 'Conn State',
                                                      'offset': 1,
                                                      'bit length': 3})

        connState.setReportList(
            ['No connection', 'Port is disabled', 'Audio connection (Ra/Ra)', 'Debug connection (Rd/Rd)', \
             'No connection, Ra detected (Ra but no Rd)', 'Reserved (may be used for Rp/Rp Debug connection)', \
             'Connection present, no Ra detected (Rd but no Ra) or Rp detected with no previous Ra detection, includes PD Controller that connected in Attached.SNK.', \
             'Connection present, Ra detected (Rd and Ra detected) or Rp detected with previous Ra detection (assumes PD Controller started as Source and later swapped to Sink).'])
        connState.help = """Indicates state of connection"""
        self.dataModel.addChild(connState)

        plugOrientation = register_class.cListDMTerminator(self,
                                                           {'name': 'Plug Orientation',
                                                            'offset': 4,
                                                            'bit length': 1})

        plugOrientation.setReportList(
            ['Upside-up orientation (plug CC on C_CC1) or orientation unknown or port is disabled/disconnected.', \
             'Upside-down orientation (plug CC on C_CC2).'])
        plugOrientation.help = """Indicates port orientation when known (requires connection)."""
        self.dataModel.addChild(plugOrientation)

        portRole = register_class.cListDMTerminator(self,
                                                    {'name': 'Port Role',
                                                     'offset': 5,
                                                     'bit length': 1})
        portRole.setReportList(['PD Controller is Sink (C_CCx pull-down active) or port is disabled/disconnected.', \
                                'PD Controller is Source (C_CCx pull-up active).'])
        portRole.help = """Indicates current state of PD Controller C_CCx pulls, and therefore PD Controller Power Role, once connected. This bit does not toggle during Unattached.* state transitions."""
        self.dataModel.addChild(portRole)

        dataRole = register_class.cListDMTerminator(self,
                                                    {'name': 'Data Role',
                                                     'offset': 6,
                                                     'bit length': 1})
        dataRole.setReportList(['PD Controller is UFP or port is disabled/disconnected.', 'PD Controller is DFP.'])
        dataRole.help = """Indicates current state of PD Controller Data Role once connected."""
        self.dataModel.addChild(dataRole)

        vbusStatus = register_class.cListDMTerminator(self,
                                                      {'name': 'VBUS Status',
                                                       'offset': 20,
                                                       'bit length': 2})
        vbusStatus.setReportList(['VBUS is at vSafe0V (less than 0.8V)', \
                                  'VBUS is at vSafe5V (4.75V to 5.5V).', \
                                  'VBUS is at other PD-negotiated power level and within expected limits.', \
                                  'VBUS is not within any of the above ranges.'])
        vbusStatus.help = """Indicates status of VBUS."""
        self.dataModel.addChild(vbusStatus)

        usbHostPresent = register_class.cListDMTerminator(self,
                                                          {'name': 'USB Host Present',
                                                           'offset': 22,
                                                           'bit length': 2})
        usbHostPresent.setReportList(['No far-end device present providing VBUS or PD Controller power role is Source.', \
                                      'VBUS is being provided by a far-end device that is a PD device not capable of USB communications', \
                                      'VBUS is being provided by a far-end device that is not a PD device.', \
                                      'VBUS is being provided by a far-end device that is a PD device capable of USB communications.'])
        usbHostPresent.help = """Indicates presence of USB Host"""
        self.dataModel.addChild(usbHostPresent)

        actingAsLegacy = register_class.cListDMTerminator(self,
                                                          {'name': 'Acting as Legacy',
                                                           'offset': 24,
                                                           'bit length': 2})
        actingAsLegacy.setReportList(['PD Controller is not in a legacy (non PD mode).', \
                                      'PD Controller is acting like a legacy sink. It will not respond to USB PD message traffic.', \
                                      'PD Controller is acting like a legacy source. It will not respond to USB PD message traffic.'])
        actingAsLegacy.setMaxValue(3)
        actingAsLegacy.help = """Indicates when PD Controller has gone into a mode where it is acting like a legacy (non PD) device."""
        self.dataModel.addChild(actingAsLegacy)

        goToMinActive = register_class.cListDMTerminator(self,
                                                         {'name': 'Go To Min Active',
                                                          'offset': 26,
                                                          'bit length': 1})
        goToMinActive.setReportList([
                                        'No PD contract established or GotoMin restriction has been cleared by Source Capabilities message or disconnect/Hard Reset.', \
                                        'GotoMin has been received as Sink or sent as Source'])
        goToMinActive.help = """Indicates whether GoToMin has been received"""
        self.dataModel.addChild(goToMinActive)

        bist = register_class.cListDMTerminator(self,
                                                {'name': 'BIST',
                                                 'offset': 27,
                                                 'bit length': 1})
        bist.setReportList(['No BIST in progress', 'BIST in progress'])
        bist.help = """Indicates status of BIST"""
        self.dataModel.addChild(bist)

        HVWarn = register_class.cListDMTerminator(self,
                                                  {'name': 'High Voltage Warning',
                                                   'offset': 28,
                                                   'bit length': 1})
        HVWarn.setReportList([
                                 'PD Controller operating as Sink or VBUS voltage is below limit specified by HighVoltageWarningLimit register or port is disconnected.', \
                                 'PD Controller operating as Source and VBUS voltage is above limit specified by HighVoltageWarningLimit register.'])
        HVWarn.help = """Indicates if HighVoltageWarning Limit is triggered"""
        self.dataModel.addChild(HVWarn)

        LVWarn = register_class.cListDMTerminator(self,
                                                  {'name': 'Low Voltage Warning',
                                                   'offset': 29,
                                                   'bit length': 1})
        LVWarn.setReportList([
                                 'PD Controller operating as Sink or VBUS voltage is above limit specified by LowVoltageWarningLimit register or port is disconnected.', \
                                 'PD Controller operating as Source and VBUS voltage is below limit specified by LowVoltageWarningLimit register.'])
        LVWarn.help = """Indicates if LowVoltageWarning Limit is triggered"""
        self.dataModel.addChild(LVWarn)

        ackTime = register_class.cListDMTerminator(self,
                                                   {'name': 'SOC ACK Timeout Occurred',
                                                    'offset': 30,
                                                    'bit length': 1})
        ackTime.help = """Indicates an SOC ACK timeout occurred"""
        self.dataModel.addChild(ackTime)

        AMStatus = register_class.cListDMTerminator(self,
                                                    {'name': 'Alternative Mode Status',
                                                     'offset': 32,
                                                     'bit length': 3})
        AMStatus.setMaxValue(4)
        AMStatus.setReportList(['No Alternate Modes attempted.', \
                                'At least one Alternate Mode entry successful.', \
                                'At least one Alternate Mode entry unsuccessful.' \
                                'At least one Alternate Mode entry successful and at least one mode entry unsuccessful.'])
        AMStatus.help = """Indicates if AM entry, if any, is successful"""
        self.dataModel.addChild(AMStatus)


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cIntEvent3_0x1B_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Interrupt Event for external access',
                                                 'address': 0x1B,
                                                 'byte length': 9,
                                                 'permission': 'DRO'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name': 'Interrupt Event for external access',
                                                         'offset': 0,
                                                         'bit length': 72})

        port0ints = register_class.cDataModelArray(self, 1,
                                                   {'name': 'Interrupt Event for external access',
                                                    'offset': 0,
                                                    'bit length': 72})

        self.dataModel.addChild(port0ints)

        SoftReset = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'Soft Reset',
                                                         'offset': 0,
                                                         'bit length': 1})

        SoftReset.help = """When this bit is enabled, an I2C interrupt event will be set when a PD Soft Reset has been performed. See PD Status.SoftResetType for more information."""
        port0ints.addChild(SoftReset)

        HardReset = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'Hard Reset',
                                                         'offset': 1,
                                                         'bit length': 1})

        HardReset.help = """when this bit is enabled, an I2C interrupt event will be set when a PD Hard Reset has been performed. See PD Status.HardResetDetails for more information."""
        port0ints.addChild(HardReset)

        CableResetEvent = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Cable Reset Event',
                                                               'offset': 2,
                                                               'bit length': 1})

        CableResetEvent.help = """This event occurs when PD Controller sends Cable Reset signaling."""
        port0ints.addChild(CableResetEvent)

        PlugInsertOrRemoval = register_class.cBooleanDMTerminator(self,
                                                                  {'name': 'Plug Insert or Removal',
                                                                   'offset': 3,
                                                                   'bit length': 1})

        PlugInsertOrRemoval.help = """when this bit is enabled, an I2C interrupt event will be set when the user inserts or removes a plug into the Type-C port."""
        port0ints.addChild(PlugInsertOrRemoval)

        PRSwapComplete = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'PR Swap Complete',
                                                              'offset': 4,
                                                              'bit length': 1})

        PRSwapComplete.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller completes a power role swap."""
        port0ints.addChild(PRSwapComplete)

        DRSwapComplete = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'DR Swap Complete',
                                                              'offset': 5,
                                                              'bit length': 1})

        DRSwapComplete.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller completes a data role swap."""
        port0ints.addChild(DRSwapComplete)

        FRSwapComplete = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'FR Swap Complete',
                                                              'offset': 6,
                                                              'bit length': 1})

        FRSwapComplete.help = """A Fast Role Swap has completed."""
        port0ints.addChild(FRSwapComplete)

        RdoReceivedFromSink = register_class.cBooleanDMTerminator(self,
                                                                  {'name': 'RDO Received from Sink',
                                                                   'offset': 7,
                                                                   'bit length': 1})

        RdoReceivedFromSink.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller receives an RDO (Request Data Object) from the sink device."""
        port0ints.addChild(RdoReceivedFromSink)

        Bist = register_class.cBooleanDMTerminator(self,
                                                   {'name': 'Built-In Self Test',
                                                    'offset': 8,
                                                    'bit length': 1})

        Bist.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller completes a Built-In Self Test (BIST). This bit is set whenever the STATUS.BIST changes."""
        port0ints.addChild(Bist)

        Overcurrent = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'Overcurrent Event',
                                                           'offset': 9,
                                                           'bit length': 1})

        Overcurrent.help = """when this bit is enabled, an I2C interrupt event will be set when an Overcurrent Event occurs on VBUS. This bit is set whenever STATUS.Overcurrent changes."""
        port0ints.addChild(Overcurrent)

        AttentionReceived = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Attention Received',
                                                                 'offset': 10,
                                                                 'bit length': 1})

        AttentionReceived.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller received an Attention message."""
        port0ints.addChild(AttentionReceived)

        VDMReceived = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'Vendor-Defined Message Received',
                                                           'offset': 11,
                                                           'bit length': 1})

        VDMReceived.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller receives a Vendor Defined Message from the device it is connected to."""
        port0ints.addChild(VDMReceived)

        NewContractAsCons = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'New Contract as Consumer',
                                                                 'offset': 12,
                                                                 'bit length': 1})

        NewContractAsCons.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller enters a new power contract as a Consumer (Power Sink). This bit is set when an RDO from the far-end device has been accepted and the PD Controller is a Sink. See Active Contract PDO & Active Contract RDO registers for details"""
        port0ints.addChild(NewContractAsCons)

        NewContractAsProv = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'New Contract as Provider',
                                                                 'offset': 13,
                                                                 'bit length': 1})

        NewContractAsProv.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller enters a new power contract as a Provider (Power Source). This bit is set when an RDO from the far-end device has been accepted and the PD Controller is a Source. See Active Contract PDO & Active Contract RDO registers for details"""
        port0ints.addChild(NewContractAsProv)

        SourceCapMsgReady = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Source Capabilities Message Ready',
                                                                 'offset': 14,
                                                                 'bit length': 1})

        SourceCapMsgReady.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller is ready to send its Source Capabilities message has been updated by the far end device."""
        port0ints.addChild(SourceCapMsgReady)

        SinkCapMsgReady = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Sink Capabilities Message Ready',
                                                               'offset': 15,
                                                               'bit length': 1})

        SinkCapMsgReady.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller is ready to send its Sink Capabilities message has been updated by the far end device."""
        port0ints.addChild(SinkCapMsgReady)

        LowVoltageWarning = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Low Voltage Warning',
                                                                 'offset': 16,
                                                                 'bit length': 1})

        LowVoltageWarning.help = """when this bit is enabled, an I2C interrupt event will be set when the voltage level on VBUS is lower than the expected value."""
        port0ints.addChild(LowVoltageWarning)

        PRSwapReq = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'PR Swap Requested',
                                                         'offset': 17,
                                                         'bit length': 1})

        PRSwapReq.help = """when this bit is enabled, an I2C interrupt event will be set when the device attached to the PD controller requests a power role swap."""
        port0ints.addChild(PRSwapReq)

        DRSwapReq = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'DR Swap Requested',
                                                         'offset': 18,
                                                         'bit length': 1})

        DRSwapReq.help = """when this bit is enabled, an I2C interrupt event will be set when the device attached to the PD controller requests a data role swap."""
        port0ints.addChild(DRSwapReq)

        GotoMinReceived = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Goto Min Received',
                                                               'offset': 19,
                                                               'bit length': 1})

        GotoMinReceived.help = """when this bit is enabled, an I2C interrupt event will be set when the PD Controller has received a GotoMin message while in a contract where the GiveBack flag in the RDO was set. The system needs to reduce power consumption down to the level specified in the Auto Negotiate Sink Register (0x37)."""
        port0ints.addChild(GotoMinReceived)

        UsbHostPresent = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'USB Host Present',
                                                              'offset': 20,
                                                              'bit length': 1})

        UsbHostPresent.help = """when this bit is enabled, an I2C interrupt event will be set when there is a USB Host Present on the Type-C port."""
        port0ints.addChild(UsbHostPresent)

        UsbHostPresentNoLonger = register_class.cBooleanDMTerminator(self,
                                                                     {'name': 'USB Host Present no longer',
                                                                      'offset': 21,
                                                                      'bit length': 1})

        UsbHostPresentNoLonger.help = """when this bit is enabled, an I2C interrupt event will be set when a USB Host gets removed from the Type-C port os is no longer available."""
        port0ints.addChild(UsbHostPresentNoLonger)

        HighVoltageWarning = register_class.cBooleanDMTerminator(self,
                                                                 {'name': 'High Voltage Warning',
                                                                  'offset': 22,
                                                                  'bit length': 1})

        HighVoltageWarning.help = """when this bit is enabled, an I2C interrupt event will be set when the voltage on VBUS exceeds the safe threshold."""
        port0ints.addChild(HighVoltageWarning)

        PPswitchChanged = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'PP Switch Changed',
                                                               'offset': 23,
                                                               'bit length': 1})

        PPswitchChanged.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller changes the power path that is currently sourcing or sinking power on VBUS."""
        port0ints.addChild(PPswitchChanged)

        PowerStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Power Status Update',
                                                                 'offset': 24,
                                                                 'bit length': 1})

        PowerStatusUpdate.help = """when this bit is enabled, an I2C interrupt event will be set when the PD Controller updates its power status. This is set when the contents of Register (0x3F) change."""
        port0ints.addChild(PowerStatusUpdate)

        DataStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'Data Status Update',
                                                                'offset': 25,
                                                                'bit length': 1})
        DataStatusUpdate.hide()
        DataStatusUpdate.help = """when this bit is enabled, an I2C interrupt event will be set when the data status is updated on the PD controller. This bit must be set for use with Alpine Ridge thunderbolt controllers. This interrupt is set when the contents of register (0x5F) change."""
        port0ints.addChild(DataStatusUpdate)

        StatusUpdate = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Status Update',
                                                            'offset': 26,
                                                            'bit length': 1})

        StatusUpdate.help = """when this bit is enabled, an I2C interrupt event will be set when the status of the PD controller is updated. This is set when the contents of Register (0x1A) change."""
        port0ints.addChild(StatusUpdate)

        PDStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'PD Status Update',
                                                              'offset': 27,
                                                              'bit length': 1})

        PDStatusUpdate.help = """when this bit is enabled, an I2C interrupt event will be set whenever contents of PD Status register (0x40) change"""
        port0ints.addChild(PDStatusUpdate)

        ADCLowThreshold = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'ADC Low Threshold',
                                                               'offset': 28,
                                                               'bit length': 1})

        ADCLowThreshold.help = """when this bit is enabled, an I2C interrupt event will be set when the ADC Threshold exceeds its lower boundary. (ADC_MON_THR_LO_STAT)"""
        ADCLowThreshold.hide()
        port0ints.addChild(ADCLowThreshold)

        ADCHighThreshold = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'ADC High Threshold',
                                                                'offset': 29,
                                                                'bit length': 1})

        ADCHighThreshold.help = """when this bit is enabled, an I2C interrupt event will be set when the ADC Threshold exceeds its higher boundary. (ADC_MON_THR_HI_STAT)"""
        ADCHighThreshold.hide()
        port0ints.addChild(ADCHighThreshold)

        Cmd1Complete = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'CMD1 Complete',
                                                            'offset': 30,
                                                            'bit length': 1})

        Cmd1Complete.help = """when this bit is enabled, an I2C interrupt event will be set whenever a non-zero value in CMD1 register is set to zero or !CMD."""
        port0ints.addChild(Cmd1Complete)

        Cmd2Complete = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'CMD2 Complete',
                                                            'offset': 31,
                                                            'bit length': 1})

        Cmd2Complete.help = """when this bit is enabled, an I2C interrupt event will be set whenever a non-zero value in CMD2 register is set to zero or !CMD."""
        port0ints.addChild(Cmd2Complete)

        Error_DeviceIncompatible = register_class.cBooleanDMTerminator(self,
                                                                       {'name': 'Error: Device Incompatible',
                                                                        'offset': 32,
                                                                        'bit length': 1})

        Error_DeviceIncompatible.help = """When set to 1, a USB PD device with an incompatible specification version wasconnected. Or the partner device is not USB PD capable."""
        port0ints.addChild(Error_DeviceIncompatible)

        Error_CannotProvideVoltageOrCurrent = register_class.cBooleanDMTerminator(self,
                                                                                  {
                                                                                      'name': 'Error: Cannot Provide Voltage or Current',
                                                                                      'offset': 33,
                                                                                      'bit length': 1})

        Error_CannotProvideVoltageOrCurrent.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller is unable to source the power required for the current PDO."""
        port0ints.addChild(Error_CannotProvideVoltageOrCurrent)

        Error_CanProvideVoltageOrCurrentLater = register_class.cBooleanDMTerminator(self,
                                                                                    {
                                                                                        'name': 'Error: Cannot Provide Voltage or Current Later',
                                                                                        'offset': 34,
                                                                                        'bit length': 1})

        Error_CanProvideVoltageOrCurrentLater.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller is unable to sustain sourcing the power required for the current PDO."""
        port0ints.addChild(Error_CanProvideVoltageOrCurrentLater)

        Error_PowerEventOccurred = register_class.cBooleanDMTerminator(self,
                                                                       {'name': 'Error: Power Event Occurred',
                                                                        'offset': 35,
                                                                        'bit length': 1})

        Error_PowerEventOccurred.help = """when this bit is enabled, an I2C interrupt event will be set when an OVP (Over-Voltage Protection) or short circuit event occured on VBUS"""
        port0ints.addChild(Error_PowerEventOccurred)

        Error_MissingGetCapMessage = register_class.cBooleanDMTerminator(self,
                                                                         {
                                                                             'name': 'Error: Missing Get Capabilities Message',
                                                                             'offset': 36,
                                                                             'bit length': 1})

        Error_MissingGetCapMessage.help = """when this bit is enabled, an I2C interrupt event will be set when he partner device did not respond to the Get_Sink_Cap or Get_Source_Cap message that was sent."""
        port0ints.addChild(Error_MissingGetCapMessage)

        Error_ProtError = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Error: Protocol Error',
                                                               'offset': 38,
                                                               'bit length': 1})

        Error_ProtError.help = """when this bit is enabled, an I2C interrupt event will be set when an unexpected message was received from the partner device."""

        port0ints.addChild(Error_ProtError)

        Error_MessageData = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Error: Message Data',
                                                                 'offset': 39,
                                                                 'bit length': 1})

        Error_MessageData.help = """when this bit is enabled, an I2C interrupt event will be set when a message was received and the CRC failed or the data length in the header (“Number of Data Objects”) did not match the actual amount of data received or its signal level caused the message to be deemed invalid."""
        port0ints.addChild(Error_MessageData)

        Error_DischargeFailed = register_class.cBooleanDMTerminator(self,
                                                                    {'name': 'Error: Discharge Failed',
                                                                     'offset': 41,
                                                                     'bit length': 1})

        Error_DischargeFailed.help = """when this bit is enabled, an I2C interrupt event will be set when the PD Controller fails to discharge VBUS"""
        port0ints.addChild(Error_DischargeFailed)

        SnkTransitionComplete = register_class.cBooleanDMTerminator(self,
                                                                    {'name': 'Sink Transition Complete',
                                                                     'offset': 42,
                                                                     'bit length': 1})

        SnkTransitionComplete.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully transitioned into a power sink."""
        port0ints.addChild(SnkTransitionComplete)

        iclProchot = register_class.cBooleanDMTerminator(self,
                                                         {'name': 'Ice Lake Proc Hot Notification',
                                                          'offset': 44,
                                                          'bit length': 1})
        # port0ints.addChild(ICLProcHot)

        Error_UnableToSource = register_class.cBooleanDMTerminator(self,
                                                                   {'name': 'Error: Unable to Source',
                                                                    'offset': 46,
                                                                    'bit length': 1})

        Error_UnableToSource.help = """when this bit is enabled, an I2C interrupt event will be set when the source device is unable to increase the voltage to the negotiated voltage of the PD contract."""
        port0ints.addChild(Error_UnableToSource)

        Error_BISTIg = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Error: BIST Message Ignored',
                                                            'offset': 47,
                                                            'bit length': 1})

        Error_BISTIg.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller sends a Built-In Self Test message that is ignored by the far end device."""
        port0ints.addChild(Error_BISTIg)

        AMEntryFail = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'AM Entry Failure',
                                                           'offset': 48,
                                                           'bit length': 1})

        AMEntryFail.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller fails to enter an Alternate Mode."""
        port0ints.addChild(AMEntryFail)

        AMEntered = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'AM Entered',
                                                         'offset': 49,
                                                         'bit length': 1})

        AMEntered.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully entered an Alternate Mode."""
        port0ints.addChild(AMEntered)

        VDMMsgSent = register_class.cBooleanDMTerminator(self,
                                                         {'name': 'Vendor Defined Message Sent',
                                                          'offset': 50,
                                                          'bit length': 1})

        VDMMsgSent.help = """Set when a VDM has been sent."""
        port0ints.addChild(VDMMsgSent)

        discModeComp = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Discover Mode Complete',
                                                            'offset': 51,
                                                            'bit length': 1})

        discModeComp.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully Discovered the available modes of the far end device."""
        port0ints.addChild(discModeComp)

        exitModeComp = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Exit Mode Complete',
                                                            'offset': 52,
                                                            'bit length': 1})

        exitModeComp.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully exited an Alternate Mode."""
        port0ints.addChild(exitModeComp)

        UserSvidModeEntered = register_class.cBooleanDMTerminator(self,
                                                                  {'name': 'User SVID Mode Entered',
                                                                   'offset': 56,
                                                                   'bit length': 1})

        UserSvidModeEntered.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully entered a users SVID mode."""
        port0ints.addChild(UserSvidModeEntered)

        UserSvidModeExited = register_class.cBooleanDMTerminator(self,
                                                                 {'name': 'User SVID Mode Exited',
                                                                  'offset': 57,
                                                                  'bit length': 1})

        UserSvidModeExited.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has exited a users SVID mode."""
        port0ints.addChild(UserSvidModeExited)

        UserSvidAttentionVDMReceived = register_class.cBooleanDMTerminator(self,
                                                                           {'name': 'User SVID Attention VDM Received',
                                                                            'offset': 58,
                                                                            'bit length': 1})

        UserSvidAttentionVDMReceived.help = """when this bit is enabled, an I2C interrupt event will be set when a users SVID structured attention vendor defined message is received."""
        port0ints.addChild(UserSvidAttentionVDMReceived)

        UserSvidOtherVDMReceived = register_class.cBooleanDMTerminator(self,
                                                                       {'name': 'User SVID Other VDM Received',
                                                                        'offset': 59,
                                                                        'bit length': 1})

        UserSvidOtherVDMReceived.help = """when this bit is enabled, an I2C interrupt event will be set when a users SVID structured non-Attention VDM or unstructured VDM has been received."""
        port0ints.addChild(UserSvidOtherVDMReceived)

        DPSIDStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'DP SID Status Update',
                                                                 'offset': 62,
                                                                 'bit length': 1})

        DPSIDStatusUpdate.help = """Set when the contents of the DP SID Status register (0x58) change."""
        port0ints.addChild(DPSIDStatusUpdate)

        IntelVIDStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                                   {'name': 'Intel VID Status Update',
                                                                    'offset': 63,
                                                                    'bit length': 1})
        IntelVIDStatusUpdate.hide()
        IntelVIDStatusUpdate.help = """Set when the contents of the Intel VID Status register (0x59) change."""
        port0ints.addChild(IntelVIDStatusUpdate)

        PD3StatusUpdate = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'PD3 Status Update',
                                                               'offset': 64,
                                                               'bit length': 1})

        PD3StatusUpdate.help = """Set when the contents of the PD3.0 Status register (0x41) change."""
        port0ints.addChild(PD3StatusUpdate)

        TXMemBufferEmpty = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'TX Mem Buffer Empty',
                                                                'offset': 65,
                                                                'bit length': 1})

        TXMemBufferEmpty.help = """Transmit memory buffer empty."""
        port0ints.addChild(TXMemBufferEmpty)

        RXMemBufferFull = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'RX Mem Buffer Full',
                                                               'offset': 66,
                                                               'bit length': 1})

        RXMemBufferFull.help = """Transmit memory buffer empty."""
        port0ints.addChild(RXMemBufferFull)

        CustomDVDMArrive = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'Custom VDM Arrive',
                                                                'offset': 67,
                                                                'bit length': 1})

        CustomDVDMArrive.help = """A custom VDM has arrived"""
        port0ints.addChild(CustomDVDMArrive)

        CustomDAMEntered = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'Custom AM Entered',
                                                                'offset': 68,
                                                                'bit length': 1})

        CustomDAMEntered.help = """A custom Alternate Mode has been entered."""
        port0ints.addChild(CustomDAMEntered)

        CustomDVDMMSGSENT = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Custom VDM Message Sent',
                                                                 'offset': 69,
                                                                 'bit length': 1})

        CustomDVDMMSGSENT.help = """A custom VDM has been sent."""
        port0ints.addChild(CustomDVDMMSGSENT)

        ackTime = register_class.cBooleanDMTerminator(self,
                                                      {'name': 'SOC ACK Timeout',
                                                       'offset': 70,
                                                       'bit length': 1})

        ackTime.help = """ACK Timeout Occurred."""
        port0ints.addChild(ackTime)

        FRSSignalReceived = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'FRS Signal Received',
                                                                 'offset': 76,
                                                                 'bit length': 1})

        FRSSignalReceived.help = """An FRS Message has been received."""
        port0ints.addChild(FRSSignalReceived)

        ChunkResponseReceived = register_class.cBooleanDMTerminator(self,
                                                                    {'name': 'Chunk Response Received',
                                                                     'offset': 77,
                                                                     'bit length': 1})

        ChunkResponseReceived.help = """Chunk Response message received."""
        port0ints.addChild(ChunkResponseReceived)

        ChunkRequestReceived = register_class.cBooleanDMTerminator(self,
                                                                   {'name': 'Chunk Request Received',
                                                                    'offset': 78,
                                                                    'bit length': 1})

        ChunkRequestReceived.help = """Chunk Request message received."""
        port0ints.addChild(ChunkRequestReceived)

        AlertMessageReceived = register_class.cBooleanDMTerminator(self,
                                                                   {'name': 'Alert Message Received',
                                                                    'offset': 79,
                                                                    'bit length': 1})

        AlertMessageReceived.help = """An Alert Messae has been received."""
        port0ints.addChild(AlertMessageReceived)

        commonInts = register_class.cDataModelArray(self, 1,
                                                    {'name': 'Common Interrupt Mask for I2C1',
                                                     'offset': 80,
                                                     'bit length': 8})

        self.dataModel.addChild(commonInts)

        patchLoaded = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'Patch Loaded',
                                                           'offset': 0,
                                                           'bit length': 1})

        patchLoaded.help = """when this bit is enabled, an I2C interrupt event will be set when a patch has been loaded onto the device."""
        commonInts.addChild(patchLoaded)

        readyPatch = register_class.cBooleanDMTerminator(self,
                                                         {'name': 'Ready for Patch',
                                                          'offset': 1,
                                                          'bit length': 1})

        readyPatch.help = """when this bit is enabled, an I2C interrupt event will be set when the device is ready to receive a patch."""
        commonInts.addChild(readyPatch)


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cIntMask3_0x1C_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Interrupt mask for external access',
                                                 'address': 0x1C,
                                                 'byte length': 9,
                                                 'permission': 'DRW'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name': 'Interrupt mask for external access',
                                                         'offset': 0,
                                                         'bit length': 72})

        port0ints = register_class.cDataModelArray(self, 1,
                                                   {'name': 'Interrupt mask for external access',
                                                    'offset': 0,
                                                    'bit length': 72})

        self.dataModel.addChild(port0ints)

        SoftReset = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'Soft Reset',
                                                         'offset': 0,
                                                         'bit length': 1})

        SoftReset.help = """When this bit is enabled, an I2C interrupt event will be set when a PD Soft Reset has been performed. See PD Status.SoftResetType for more information."""
        port0ints.addChild(SoftReset)

        HardReset = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'Hard Reset',
                                                         'offset': 1,
                                                         'bit length': 1})

        HardReset.help = """when this bit is enabled, an I2C interrupt event will be set when a PD Hard Reset has been performed. See PD Status.HardResetDetails for more information."""
        port0ints.addChild(HardReset)

        CableResetEvent = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Cable Reset Event',
                                                               'offset': 2,
                                                               'bit length': 1})

        CableResetEvent.help = """This event occurs when PD Controller sends Cable Reset signaling."""
        port0ints.addChild(CableResetEvent)

        PlugInsertOrRemoval = register_class.cBooleanDMTerminator(self,
                                                                  {'name': 'Plug Insert or Removal',
                                                                   'offset': 3,
                                                                   'bit length': 1})

        PlugInsertOrRemoval.help = """when this bit is enabled, an I2C interrupt event will be set when the user inserts or removes a plug into the Type-C port."""
        port0ints.addChild(PlugInsertOrRemoval)

        PRSwapComplete = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'PR Swap Complete',
                                                              'offset': 4,
                                                              'bit length': 1})

        PRSwapComplete.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller completes a power role swap."""
        port0ints.addChild(PRSwapComplete)

        DRSwapComplete = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'DR Swap Complete',
                                                              'offset': 5,
                                                              'bit length': 1})

        DRSwapComplete.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller completes a data role swap."""
        port0ints.addChild(DRSwapComplete)

        FRSwapComplete = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'FR Swap Complete',
                                                              'offset': 6,
                                                              'bit length': 1})

        FRSwapComplete.help = """A Fast Role Swap has completed."""
        port0ints.addChild(FRSwapComplete)

        RdoReceivedFromSink = register_class.cBooleanDMTerminator(self,
                                                                  {'name': 'RDO Received from Sink',
                                                                   'offset': 7,
                                                                   'bit length': 1})

        RdoReceivedFromSink.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller receives an RDO (Request Data Object) from the sink device."""
        port0ints.addChild(RdoReceivedFromSink)

        Bist = register_class.cBooleanDMTerminator(self,
                                                   {'name': 'Built-In Self Test',
                                                    'offset': 8,
                                                    'bit length': 1})

        Bist.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller completes a Built-In Self Test (BIST). This bit is set whenever the STATUS.BIST changes."""
        port0ints.addChild(Bist)

        Overcurrent = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'Overcurrent Event',
                                                           'offset': 9,
                                                           'bit length': 1})

        Overcurrent.help = """when this bit is enabled, an I2C interrupt event will be set when an Overcurrent Event occurs on VBUS. This bit is set whenever STATUS.Overcurrent changes."""
        port0ints.addChild(Overcurrent)

        AttentionReceived = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Attention Received',
                                                                 'offset': 10,
                                                                 'bit length': 1})

        AttentionReceived.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller received an Attention message."""
        port0ints.addChild(AttentionReceived)

        VDMReceived = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'Vendor-Defined Message Received',
                                                           'offset': 11,
                                                           'bit length': 1})

        VDMReceived.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller receives a Vendor Defined Message from the device it is connected to."""
        port0ints.addChild(VDMReceived)

        NewContractAsCons = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'New Contract as Consumer',
                                                                 'offset': 12,
                                                                 'bit length': 1})

        NewContractAsCons.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller enters a new power contract as a Consumer (Power Sink). This bit is set when an RDO from the far-end device has been accepted and the PD Controller is a Sink. See Active Contract PDO & Active Contract RDO registers for details"""
        port0ints.addChild(NewContractAsCons)

        NewContractAsProv = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'New Contract as Provider',
                                                                 'offset': 13,
                                                                 'bit length': 1})

        NewContractAsProv.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller enters a new power contract as a Provider (Power Source). This bit is set when an RDO from the far-end device has been accepted and the PD Controller is a Source. See Active Contract PDO & Active Contract RDO registers for details"""
        port0ints.addChild(NewContractAsProv)

        SourceCapMsgReady = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Source Capabilities Message Ready',
                                                                 'offset': 14,
                                                                 'bit length': 1})

        SourceCapMsgReady.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller is ready to send its Source Capabilities message has been updated by the far end device."""
        port0ints.addChild(SourceCapMsgReady)

        SinkCapMsgReady = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Sink Capabilities Message Ready',
                                                               'offset': 15,
                                                               'bit length': 1})

        SinkCapMsgReady.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller is ready to send its Sink Capabilities message has been updated by the far end device."""
        port0ints.addChild(SinkCapMsgReady)

        LowVoltageWarning = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Low Voltage Warning',
                                                                 'offset': 16,
                                                                 'bit length': 1})

        LowVoltageWarning.help = """when this bit is enabled, an I2C interrupt event will be set when the voltage level on VBUS is lower than the expected value."""
        port0ints.addChild(LowVoltageWarning)

        PRSwapReq = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'PR Swap Requested',
                                                         'offset': 17,
                                                         'bit length': 1})

        PRSwapReq.help = """when this bit is enabled, an I2C interrupt event will be set when the device attached to the PD controller requests a power role swap."""
        port0ints.addChild(PRSwapReq)

        DRSwapReq = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'DR Swap Requested',
                                                         'offset': 18,
                                                         'bit length': 1})

        DRSwapReq.help = """when this bit is enabled, an I2C interrupt event will be set when the device attached to the PD controller requests a data role swap."""
        port0ints.addChild(DRSwapReq)

        GotoMinReceived = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Goto Min Received',
                                                               'offset': 19,
                                                               'bit length': 1})

        GotoMinReceived.help = """when this bit is enabled, an I2C interrupt event will be set when the PD Controller has received a GotoMin message while in a contract where the GiveBack flag in the RDO was set. The system needs to reduce power consumption down to the level specified in the Auto Negotiate Sink Register (0x37)."""
        port0ints.addChild(GotoMinReceived)

        UsbHostPresent = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'USB Host Present',
                                                              'offset': 20,
                                                              'bit length': 1})

        UsbHostPresent.help = """when this bit is enabled, an I2C interrupt event will be set when there is a USB Host Present on the Type-C port."""
        port0ints.addChild(UsbHostPresent)

        UsbHostPresentNoLonger = register_class.cBooleanDMTerminator(self,
                                                                     {'name': 'USB Host Present no longer',
                                                                      'offset': 21,
                                                                      'bit length': 1})

        UsbHostPresentNoLonger.help = """when this bit is enabled, an I2C interrupt event will be set when a USB Host gets removed from the Type-C port os is no longer available."""
        port0ints.addChild(UsbHostPresentNoLonger)

        HighVoltageWarning = register_class.cBooleanDMTerminator(self,
                                                                 {'name': 'High Voltage Warning',
                                                                  'offset': 22,
                                                                  'bit length': 1})

        HighVoltageWarning.help = """when this bit is enabled, an I2C interrupt event will be set when the voltage on VBUS exceeds the safe threshold."""
        port0ints.addChild(HighVoltageWarning)

        PPswitchChanged = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'PP Switch Changed',
                                                               'offset': 23,
                                                               'bit length': 1})

        PPswitchChanged.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller changes the power path that is currently sourcing or sinking power on VBUS."""
        port0ints.addChild(PPswitchChanged)

        PowerStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Power Status Update',
                                                                 'offset': 24,
                                                                 'bit length': 1})

        PowerStatusUpdate.help = """when this bit is enabled, an I2C interrupt event will be set when the PD Controller updates its power status. This is set when the contents of Register (0x3F) change."""
        port0ints.addChild(PowerStatusUpdate)

        DataStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'Data Status Update',
                                                                'offset': 25,
                                                                'bit length': 1})
        DataStatusUpdate.hide()
        DataStatusUpdate.help = """when this bit is enabled, an I2C interrupt event will be set when the data status is updated on the PD controller. This bit must be set for use with Alpine Ridge thunderbolt controllers. This interrupt is set when the contents of register (0x5F) change."""
        port0ints.addChild(DataStatusUpdate)

        StatusUpdate = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Status Update',
                                                            'offset': 26,
                                                            'bit length': 1})

        StatusUpdate.help = """when this bit is enabled, an I2C interrupt event will be set when the status of the PD controller is updated. This is set when the contents of Register (0x1A) change."""
        port0ints.addChild(StatusUpdate)

        PDStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'PD Status Update',
                                                              'offset': 27,
                                                              'bit length': 1})

        PDStatusUpdate.help = """when this bit is enabled, an I2C interrupt event will be set whenever contents of PD Status register (0x40) change"""
        port0ints.addChild(PDStatusUpdate)

        ADCLowThreshold = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'ADC Low Threshold',
                                                               'offset': 28,
                                                               'bit length': 1})

        ADCLowThreshold.help = """when this bit is enabled, an I2C interrupt event will be set when the ADC Threshold exceeds its lower boundary. (ADC_MON_THR_LO_STAT)"""
        ADCLowThreshold.hide()
        port0ints.addChild(ADCLowThreshold)

        ADCHighThreshold = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'ADC High Threshold',
                                                                'offset': 29,
                                                                'bit length': 1})

        ADCHighThreshold.help = """when this bit is enabled, an I2C interrupt event will be set when the ADC Threshold exceeds its higher boundary. (ADC_MON_THR_HI_STAT)"""
        ADCHighThreshold.hide()
        port0ints.addChild(ADCHighThreshold)

        Cmd1Complete = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'CMD1 Complete',
                                                            'offset': 30,
                                                            'bit length': 1})

        Cmd1Complete.help = """when this bit is enabled, an I2C interrupt event will be set whenever a non-zero value in CMD1 register is set to zero or !CMD."""
        port0ints.addChild(Cmd1Complete)

        Cmd2Complete = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'CMD2 Complete',
                                                            'offset': 31,
                                                            'bit length': 1})

        Cmd2Complete.help = """when this bit is enabled, an I2C interrupt event will be set whenever a non-zero value in CMD2 register is set to zero or !CMD."""
        port0ints.addChild(Cmd2Complete)

        Error_DeviceIncompatible = register_class.cBooleanDMTerminator(self,
                                                                       {'name': 'Error: Device Incompatible',
                                                                        'offset': 32,
                                                                        'bit length': 1})

        Error_DeviceIncompatible.help = """When set to 1, a USB PD device with an incompatible specification version wasconnected. Or the partner device is not USB PD capable."""
        port0ints.addChild(Error_DeviceIncompatible)

        Error_CannotProvideVoltageOrCurrent = register_class.cBooleanDMTerminator(self,
                                                                                  {
                                                                                      'name': 'Error: Cannot Provide Voltage or Current',
                                                                                      'offset': 33,
                                                                                      'bit length': 1})

        Error_CannotProvideVoltageOrCurrent.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller is unable to source the power required for the current PDO."""
        port0ints.addChild(Error_CannotProvideVoltageOrCurrent)

        Error_CanProvideVoltageOrCurrentLater = register_class.cBooleanDMTerminator(self,
                                                                                    {
                                                                                        'name': 'Error: Cannot Provide Voltage or Current Later',
                                                                                        'offset': 34,
                                                                                        'bit length': 1})

        Error_CanProvideVoltageOrCurrentLater.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller is unable to sustain sourcing the power required for the current PDO."""
        port0ints.addChild(Error_CanProvideVoltageOrCurrentLater)

        Error_PowerEventOccurred = register_class.cBooleanDMTerminator(self,
                                                                       {'name': 'Error: Power Event Occurred',
                                                                        'offset': 35,
                                                                        'bit length': 1})

        Error_PowerEventOccurred.help = """when this bit is enabled, an I2C interrupt event will be set when an OVP (Over-Voltage Protection) or short circuit event occured on VBUS"""
        port0ints.addChild(Error_PowerEventOccurred)

        Error_MissingGetCapMessage = register_class.cBooleanDMTerminator(self,
                                                                         {
                                                                             'name': 'Error: Missing Get Capabilities Message',
                                                                             'offset': 36,
                                                                             'bit length': 1})

        Error_MissingGetCapMessage.help = """when this bit is enabled, an I2C interrupt event will be set when he partner device did not respond to the Get_Sink_Cap or Get_Source_Cap message that was sent."""
        port0ints.addChild(Error_MissingGetCapMessage)

        Error_ProtError = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Error: Protocol Error',
                                                               'offset': 38,
                                                               'bit length': 1})

        Error_ProtError.help = """when this bit is enabled, an I2C interrupt event will be set when an unexpected message was received from the partner device."""

        port0ints.addChild(Error_ProtError)

        Error_MessageData = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Error: Message Data',
                                                                 'offset': 39,
                                                                 'bit length': 1})

        Error_MessageData.help = """when this bit is enabled, an I2C interrupt event will be set when a message was received and the CRC failed or the data length in the header (“Number of Data Objects”) did not match the actual amount of data received or its signal level caused the message to be deemed invalid."""
        port0ints.addChild(Error_MessageData)

        Error_DischargeFailed = register_class.cBooleanDMTerminator(self,
                                                                    {'name': 'Error: Discharge Failed',
                                                                     'offset': 41,
                                                                     'bit length': 1})

        Error_DischargeFailed.help = """when this bit is enabled, an I2C interrupt event will be set when the PD Controller fails to discharge VBUS"""
        port0ints.addChild(Error_DischargeFailed)

        SnkTransitionComplete = register_class.cBooleanDMTerminator(self,
                                                                    {'name': 'Sink Transition Complete',
                                                                     'offset': 42,
                                                                     'bit length': 1})

        SnkTransitionComplete.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully transitioned into a power sink."""
        port0ints.addChild(SnkTransitionComplete)

        iclProchot = register_class.cBooleanDMTerminator(self,
                                                         {'name': 'Ice Lake Proc Hot Notification',
                                                          'offset': 44,
                                                          'bit length': 1})
        # port0ints.addChild(ICLProcHot)

        Error_UnableToSource = register_class.cBooleanDMTerminator(self,
                                                                   {'name': 'Error: Unable to Source',
                                                                    'offset': 46,
                                                                    'bit length': 1})

        Error_UnableToSource.help = """when this bit is enabled, an I2C interrupt event will be set when the source device is unable to increase the voltage to the negotiated voltage of the PD contract."""
        port0ints.addChild(Error_UnableToSource)

        Error_BISTIg = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Error: BIST Message Ignored',
                                                            'offset': 47,
                                                            'bit length': 1})

        Error_BISTIg.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller sends a Built-In Self Test message that is ignored by the far end device."""
        port0ints.addChild(Error_BISTIg)

        AMEntryFail = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'AM Entry Failure',
                                                           'offset': 48,
                                                           'bit length': 1})

        AMEntryFail.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller fails to enter an Alternate Mode."""
        port0ints.addChild(AMEntryFail)

        AMEntered = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'AM Entered',
                                                         'offset': 49,
                                                         'bit length': 1})

        AMEntered.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully entered an Alternate Mode."""
        port0ints.addChild(AMEntered)

        VDMMsgSent = register_class.cBooleanDMTerminator(self,
                                                         {'name': 'Vendor Defined Message Sent',
                                                          'offset': 50,
                                                          'bit length': 1})

        VDMMsgSent.help = """Set when a VDM has been sent."""
        port0ints.addChild(VDMMsgSent)

        discModeComp = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Discover Mode Complete',
                                                            'offset': 51,
                                                            'bit length': 1})

        discModeComp.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully Discovered the available modes of the far end device."""
        port0ints.addChild(discModeComp)

        exitModeComp = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Exit Mode Complete',
                                                            'offset': 52,
                                                            'bit length': 1})

        exitModeComp.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully exited an Alternate Mode."""
        port0ints.addChild(exitModeComp)

        UserSvidModeEntered = register_class.cBooleanDMTerminator(self,
                                                                  {'name': 'User SVID Mode Entered',
                                                                   'offset': 56,
                                                                   'bit length': 1})

        UserSvidModeEntered.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully entered a users SVID mode."""
        port0ints.addChild(UserSvidModeEntered)

        UserSvidModeExited = register_class.cBooleanDMTerminator(self,
                                                                 {'name': 'User SVID Mode Exited',
                                                                  'offset': 57,
                                                                  'bit length': 1})

        UserSvidModeExited.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has exited a users SVID mode."""
        port0ints.addChild(UserSvidModeExited)

        UserSvidAttentionVDMReceived = register_class.cBooleanDMTerminator(self,
                                                                           {'name': 'User SVID Attention VDM Received',
                                                                            'offset': 58,
                                                                            'bit length': 1})

        UserSvidAttentionVDMReceived.help = """when this bit is enabled, an I2C interrupt event will be set when a users SVID structured attention vendor defined message is received."""
        port0ints.addChild(UserSvidAttentionVDMReceived)

        UserSvidOtherVDMReceived = register_class.cBooleanDMTerminator(self,
                                                                       {'name': 'User SVID Other VDM Received',
                                                                        'offset': 59,
                                                                        'bit length': 1})

        UserSvidOtherVDMReceived.help = """when this bit is enabled, an I2C interrupt event will be set when a users SVID structured non-Attention VDM or unstructured VDM has been received."""
        port0ints.addChild(UserSvidOtherVDMReceived)

        DPSIDStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'DP SID Status Update',
                                                                 'offset': 62,
                                                                 'bit length': 1})

        DPSIDStatusUpdate.help = """Set when the contents of the DP SID Status register (0x58) change."""
        port0ints.addChild(DPSIDStatusUpdate)

        IntelVIDStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                                   {'name': 'Intel VID Status Update',
                                                                    'offset': 63,
                                                                    'bit length': 1})
        IntelVIDStatusUpdate.hide()
        IntelVIDStatusUpdate.help = """Set when the contents of the Intel VID Status register (0x59) change."""
        port0ints.addChild(IntelVIDStatusUpdate)

        PD3StatusUpdate = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'PD3 Status Update',
                                                               'offset': 64,
                                                               'bit length': 1})

        PD3StatusUpdate.help = """Set when the contents of the PD3.0 Status register (0x41) change."""
        port0ints.addChild(PD3StatusUpdate)

        TXMemBufferEmpty = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'TX Mem Buffer Empty',
                                                                'offset': 65,
                                                                'bit length': 1})

        TXMemBufferEmpty.help = """Transmit memory buffer empty."""
        port0ints.addChild(TXMemBufferEmpty)

        RXMemBufferFull = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'RX Mem Buffer Full',
                                                               'offset': 66,
                                                               'bit length': 1})

        RXMemBufferFull.help = """Transmit memory buffer empty."""
        port0ints.addChild(RXMemBufferFull)

        CustomDVDMArrive = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'Custom VDM Arrive',
                                                                'offset': 67,
                                                                'bit length': 1})

        CustomDVDMArrive.help = """A custom VDM has arrived"""
        port0ints.addChild(CustomDVDMArrive)

        CustomDAMEntered = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'Custom AM Entered',
                                                                'offset': 68,
                                                                'bit length': 1})

        CustomDAMEntered.help = """A custom Alternate Mode has been entered."""
        port0ints.addChild(CustomDAMEntered)

        CustomDVDMMSGSENT = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Custom VDM Message Sent',
                                                                 'offset': 69,
                                                                 'bit length': 1})

        CustomDVDMMSGSENT.help = """A custom VDM has been sent."""
        port0ints.addChild(CustomDVDMMSGSENT)

        ackTime = register_class.cBooleanDMTerminator(self,
                                                      {'name': 'SOC ACK Timeout',
                                                       'offset': 70,
                                                       'bit length': 1})

        ackTime.help = """ACK Timeout Occurred."""
        port0ints.addChild(ackTime)

        FRSSignalReceived = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'FRS Signal Received',
                                                                 'offset': 76,
                                                                 'bit length': 1})

        FRSSignalReceived.help = """An FRS Message has been received."""
        port0ints.addChild(FRSSignalReceived)

        ChunkResponseReceived = register_class.cBooleanDMTerminator(self,
                                                                    {'name': 'Chunk Response Received',
                                                                     'offset': 77,
                                                                     'bit length': 1})

        ChunkResponseReceived.help = """Chunk Response message received."""
        port0ints.addChild(ChunkResponseReceived)

        ChunkRequestReceived = register_class.cBooleanDMTerminator(self,
                                                                   {'name': 'Chunk Request Received',
                                                                    'offset': 78,
                                                                    'bit length': 1})

        ChunkRequestReceived.help = """Chunk Request message received."""
        port0ints.addChild(ChunkRequestReceived)

        AlertMessageReceived = register_class.cBooleanDMTerminator(self,
                                                                   {'name': 'Alert Message Received',
                                                                    'offset': 79,
                                                                    'bit length': 1})

        AlertMessageReceived.help = """An Alert Messae has been received."""
        port0ints.addChild(AlertMessageReceived)

        commonInts = register_class.cDataModelArray(self, 1,
                                                    {'name': 'Common Interrupt Mask for I2C1',
                                                     'offset': 80,
                                                     'bit length': 8})

        self.dataModel.addChild(commonInts)

        patchLoaded = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'Patch Loaded',
                                                           'offset': 0,
                                                           'bit length': 1})

        patchLoaded.help = """when this bit is enabled, an I2C interrupt event will be set when a patch has been loaded onto the device."""
        commonInts.addChild(patchLoaded)

        readyPatch = register_class.cBooleanDMTerminator(self,
                                                         {'name': 'Ready for Patch',
                                                          'offset': 1,
                                                          'bit length': 1})

        readyPatch.help = """when this bit is enabled, an I2C interrupt event will be set when the device is ready to receive a patch."""
        commonInts.addChild(readyPatch)


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cIntClear3_0x1D_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Interrupt clear for IntEvent3',
                                                 'address': 0x1D,
                                                 'byte length': 9,
                                                 'permission': 'DRW'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name': 'Interrupt clear for external access',
                                                         'offset': 0,
                                                         'bit length': 72})

        port0ints = register_class.cDataModelArray(self, 1,
                                                   {'name': 'Interrupt clear for external access',
                                                    'offset': 0,
                                                    'bit length': 72})

        self.dataModel.addChild(port0ints)

        SoftReset = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'Soft Reset',
                                                         'offset': 0,
                                                         'bit length': 1})

        SoftReset.help = """When this bit is enabled, an I2C interrupt event will be set when a PD Soft Reset has been performed. See PD Status.SoftResetType for more information."""
        port0ints.addChild(SoftReset)

        HardReset = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'Hard Reset',
                                                         'offset': 1,
                                                         'bit length': 1})

        HardReset.help = """when this bit is enabled, an I2C interrupt event will be set when a PD Hard Reset has been performed. See PD Status.HardResetDetails for more information."""
        port0ints.addChild(HardReset)

        CableResetEvent = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Cable Reset Event',
                                                               'offset': 2,
                                                               'bit length': 1})

        CableResetEvent.help = """This event occurs when PD Controller sends Cable Reset signaling."""
        port0ints.addChild(CableResetEvent)

        PlugInsertOrRemoval = register_class.cBooleanDMTerminator(self,
                                                                  {'name': 'Plug Insert or Removal',
                                                                   'offset': 3,
                                                                   'bit length': 1})

        PlugInsertOrRemoval.help = """when this bit is enabled, an I2C interrupt event will be set when the user inserts or removes a plug into the Type-C port."""
        port0ints.addChild(PlugInsertOrRemoval)

        PRSwapComplete = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'PR Swap Complete',
                                                              'offset': 4,
                                                              'bit length': 1})

        PRSwapComplete.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller completes a power role swap."""
        port0ints.addChild(PRSwapComplete)

        DRSwapComplete = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'DR Swap Complete',
                                                              'offset': 5,
                                                              'bit length': 1})

        DRSwapComplete.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller completes a data role swap."""
        port0ints.addChild(DRSwapComplete)

        FRSwapComplete = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'FR Swap Complete',
                                                              'offset': 6,
                                                              'bit length': 1})

        FRSwapComplete.help = """A Fast Role Swap has completed."""
        port0ints.addChild(FRSwapComplete)

        RdoReceivedFromSink = register_class.cBooleanDMTerminator(self,
                                                                  {'name': 'RDO Received from Sink',
                                                                   'offset': 7,
                                                                   'bit length': 1})

        RdoReceivedFromSink.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller receives an RDO (Request Data Object) from the sink device."""
        port0ints.addChild(RdoReceivedFromSink)

        Bist = register_class.cBooleanDMTerminator(self,
                                                   {'name': 'Built-In Self Test',
                                                    'offset': 8,
                                                    'bit length': 1})

        Bist.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller completes a Built-In Self Test (BIST). This bit is set whenever the STATUS.BIST changes."""
        port0ints.addChild(Bist)

        Overcurrent = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'Overcurrent Event',
                                                           'offset': 9,
                                                           'bit length': 1})

        Overcurrent.help = """when this bit is enabled, an I2C interrupt event will be set when an Overcurrent Event occurs on VBUS. This bit is set whenever STATUS.Overcurrent changes."""
        port0ints.addChild(Overcurrent)

        AttentionReceived = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Attention Received',
                                                                 'offset': 10,
                                                                 'bit length': 1})

        AttentionReceived.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller received an Attention message."""
        port0ints.addChild(AttentionReceived)

        VDMReceived = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'Vendor-Defined Message Received',
                                                           'offset': 11,
                                                           'bit length': 1})

        VDMReceived.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller receives a Vendor Defined Message from the device it is connected to."""
        port0ints.addChild(VDMReceived)

        NewContractAsCons = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'New Contract as Consumer',
                                                                 'offset': 12,
                                                                 'bit length': 1})

        NewContractAsCons.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller enters a new power contract as a Consumer (Power Sink). This bit is set when an RDO from the far-end device has been accepted and the PD Controller is a Sink. See Active Contract PDO & Active Contract RDO registers for details"""
        port0ints.addChild(NewContractAsCons)

        NewContractAsProv = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'New Contract as Provider',
                                                                 'offset': 13,
                                                                 'bit length': 1})

        NewContractAsProv.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller enters a new power contract as a Provider (Power Source). This bit is set when an RDO from the far-end device has been accepted and the PD Controller is a Source. See Active Contract PDO & Active Contract RDO registers for details"""
        port0ints.addChild(NewContractAsProv)

        SourceCapMsgReady = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Source Capabilities Message Ready',
                                                                 'offset': 14,
                                                                 'bit length': 1})

        SourceCapMsgReady.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller is ready to send its Source Capabilities message has been updated by the far end device."""
        port0ints.addChild(SourceCapMsgReady)

        SinkCapMsgReady = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Sink Capabilities Message Ready',
                                                               'offset': 15,
                                                               'bit length': 1})

        SinkCapMsgReady.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller is ready to send its Sink Capabilities message has been updated by the far end device."""
        port0ints.addChild(SinkCapMsgReady)

        LowVoltageWarning = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Low Voltage Warning',
                                                                 'offset': 16,
                                                                 'bit length': 1})

        LowVoltageWarning.help = """when this bit is enabled, an I2C interrupt event will be set when the voltage level on VBUS is lower than the expected value."""
        port0ints.addChild(LowVoltageWarning)

        PRSwapReq = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'PR Swap Requested',
                                                         'offset': 17,
                                                         'bit length': 1})

        PRSwapReq.help = """when this bit is enabled, an I2C interrupt event will be set when the device attached to the PD controller requests a power role swap."""
        port0ints.addChild(PRSwapReq)

        DRSwapReq = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'DR Swap Requested',
                                                         'offset': 18,
                                                         'bit length': 1})

        DRSwapReq.help = """when this bit is enabled, an I2C interrupt event will be set when the device attached to the PD controller requests a data role swap."""
        port0ints.addChild(DRSwapReq)

        GotoMinReceived = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Goto Min Received',
                                                               'offset': 19,
                                                               'bit length': 1})

        GotoMinReceived.help = """when this bit is enabled, an I2C interrupt event will be set when the PD Controller has received a GotoMin message while in a contract where the GiveBack flag in the RDO was set. The system needs to reduce power consumption down to the level specified in the Auto Negotiate Sink Register (0x37)."""
        port0ints.addChild(GotoMinReceived)

        UsbHostPresent = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'USB Host Present',
                                                              'offset': 20,
                                                              'bit length': 1})

        UsbHostPresent.help = """when this bit is enabled, an I2C interrupt event will be set when there is a USB Host Present on the Type-C port."""
        port0ints.addChild(UsbHostPresent)

        UsbHostPresentNoLonger = register_class.cBooleanDMTerminator(self,
                                                                     {'name': 'USB Host Present no longer',
                                                                      'offset': 21,
                                                                      'bit length': 1})

        UsbHostPresentNoLonger.help = """when this bit is enabled, an I2C interrupt event will be set when a USB Host gets removed from the Type-C port os is no longer available."""
        port0ints.addChild(UsbHostPresentNoLonger)

        HighVoltageWarning = register_class.cBooleanDMTerminator(self,
                                                                 {'name': 'High Voltage Warning',
                                                                  'offset': 22,
                                                                  'bit length': 1})

        HighVoltageWarning.help = """when this bit is enabled, an I2C interrupt event will be set when the voltage on VBUS exceeds the safe threshold."""
        port0ints.addChild(HighVoltageWarning)

        PPswitchChanged = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'PP Switch Changed',
                                                               'offset': 23,
                                                               'bit length': 1})

        PPswitchChanged.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller changes the power path that is currently sourcing or sinking power on VBUS."""
        port0ints.addChild(PPswitchChanged)

        PowerStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Power Status Update',
                                                                 'offset': 24,
                                                                 'bit length': 1})

        PowerStatusUpdate.help = """when this bit is enabled, an I2C interrupt event will be set when the PD Controller updates its power status. This is set when the contents of Register (0x3F) change."""
        port0ints.addChild(PowerStatusUpdate)

        DataStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'Data Status Update',
                                                                'offset': 25,
                                                                'bit length': 1})
        DataStatusUpdate.hide()
        DataStatusUpdate.help = """when this bit is enabled, an I2C interrupt event will be set when the data status is updated on the PD controller. This bit must be set for use with Alpine Ridge thunderbolt controllers. This interrupt is set when the contents of register (0x5F) change."""
        port0ints.addChild(DataStatusUpdate)

        StatusUpdate = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Status Update',
                                                            'offset': 26,
                                                            'bit length': 1})

        StatusUpdate.help = """when this bit is enabled, an I2C interrupt event will be set when the status of the PD controller is updated. This is set when the contents of Register (0x1A) change."""
        port0ints.addChild(StatusUpdate)

        PDStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'PD Status Update',
                                                              'offset': 27,
                                                              'bit length': 1})

        PDStatusUpdate.help = """when this bit is enabled, an I2C interrupt event will be set whenever contents of PD Status register (0x40) change"""
        port0ints.addChild(PDStatusUpdate)

        ADCLowThreshold = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'ADC Low Threshold',
                                                               'offset': 28,
                                                               'bit length': 1})

        ADCLowThreshold.help = """when this bit is enabled, an I2C interrupt event will be set when the ADC Threshold exceeds its lower boundary. (ADC_MON_THR_LO_STAT)"""
        ADCLowThreshold.hide()
        port0ints.addChild(ADCLowThreshold)

        ADCHighThreshold = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'ADC High Threshold',
                                                                'offset': 29,
                                                                'bit length': 1})

        ADCHighThreshold.help = """when this bit is enabled, an I2C interrupt event will be set when the ADC Threshold exceeds its higher boundary. (ADC_MON_THR_HI_STAT)"""
        ADCHighThreshold.hide()
        port0ints.addChild(ADCHighThreshold)

        Cmd1Complete = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'CMD1 Complete',
                                                            'offset': 30,
                                                            'bit length': 1})

        Cmd1Complete.help = """when this bit is enabled, an I2C interrupt event will be set whenever a non-zero value in CMD1 register is set to zero or !CMD."""
        port0ints.addChild(Cmd1Complete)

        Cmd2Complete = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'CMD2 Complete',
                                                            'offset': 31,
                                                            'bit length': 1})

        Cmd2Complete.help = """when this bit is enabled, an I2C interrupt event will be set whenever a non-zero value in CMD2 register is set to zero or !CMD."""
        port0ints.addChild(Cmd2Complete)

        Error_DeviceIncompatible = register_class.cBooleanDMTerminator(self,
                                                                       {'name': 'Error: Device Incompatible',
                                                                        'offset': 32,
                                                                        'bit length': 1})

        Error_DeviceIncompatible.help = """When set to 1, a USB PD device with an incompatible specification version wasconnected. Or the partner device is not USB PD capable."""
        port0ints.addChild(Error_DeviceIncompatible)

        Error_CannotProvideVoltageOrCurrent = register_class.cBooleanDMTerminator(self,
                                                                                  {
                                                                                      'name': 'Error: Cannot Provide Voltage or Current',
                                                                                      'offset': 33,
                                                                                      'bit length': 1})

        Error_CannotProvideVoltageOrCurrent.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller is unable to source the power required for the current PDO."""
        port0ints.addChild(Error_CannotProvideVoltageOrCurrent)

        Error_CanProvideVoltageOrCurrentLater = register_class.cBooleanDMTerminator(self,
                                                                                    {
                                                                                        'name': 'Error: Cannot Provide Voltage or Current Later',
                                                                                        'offset': 34,
                                                                                        'bit length': 1})

        Error_CanProvideVoltageOrCurrentLater.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller is unable to sustain sourcing the power required for the current PDO."""
        port0ints.addChild(Error_CanProvideVoltageOrCurrentLater)

        Error_PowerEventOccurred = register_class.cBooleanDMTerminator(self,
                                                                       {'name': 'Error: Power Event Occurred',
                                                                        'offset': 35,
                                                                        'bit length': 1})

        Error_PowerEventOccurred.help = """when this bit is enabled, an I2C interrupt event will be set when an OVP (Over-Voltage Protection) or short circuit event occured on VBUS"""
        port0ints.addChild(Error_PowerEventOccurred)

        Error_MissingGetCapMessage = register_class.cBooleanDMTerminator(self,
                                                                         {
                                                                             'name': 'Error: Missing Get Capabilities Message',
                                                                             'offset': 36,
                                                                             'bit length': 1})

        Error_MissingGetCapMessage.help = """when this bit is enabled, an I2C interrupt event will be set when he partner device did not respond to the Get_Sink_Cap or Get_Source_Cap message that was sent."""
        port0ints.addChild(Error_MissingGetCapMessage)

        Error_ProtError = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Error: Protocol Error',
                                                               'offset': 38,
                                                               'bit length': 1})

        Error_ProtError.help = """when this bit is enabled, an I2C interrupt event will be set when an unexpected message was received from the partner device."""

        port0ints.addChild(Error_ProtError)

        Error_MessageData = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Error: Message Data',
                                                                 'offset': 39,
                                                                 'bit length': 1})

        Error_MessageData.help = """when this bit is enabled, an I2C interrupt event will be set when a message was received and the CRC failed or the data length in the header (“Number of Data Objects”) did not match the actual amount of data received or its signal level caused the message to be deemed invalid."""
        port0ints.addChild(Error_MessageData)

        Error_DischargeFailed = register_class.cBooleanDMTerminator(self,
                                                                    {'name': 'Error: Discharge Failed',
                                                                     'offset': 41,
                                                                     'bit length': 1})

        Error_DischargeFailed.help = """when this bit is enabled, an I2C interrupt event will be set when the PD Controller fails to discharge VBUS"""
        port0ints.addChild(Error_DischargeFailed)

        SnkTransitionComplete = register_class.cBooleanDMTerminator(self,
                                                                    {'name': 'Sink Transition Complete',
                                                                     'offset': 42,
                                                                     'bit length': 1})

        SnkTransitionComplete.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully transitioned into a power sink."""
        port0ints.addChild(SnkTransitionComplete)

        iclProchot = register_class.cBooleanDMTerminator(self,
                                                         {'name': 'Ice Lake Proc Hot Notification',
                                                          'offset': 44,
                                                          'bit length': 1})
        # port0ints.addChild(ICLProcHot)

        Error_UnableToSource = register_class.cBooleanDMTerminator(self,
                                                                   {'name': 'Error: Unable to Source',
                                                                    'offset': 46,
                                                                    'bit length': 1})

        Error_UnableToSource.help = """when this bit is enabled, an I2C interrupt event will be set when the source device is unable to increase the voltage to the negotiated voltage of the PD contract."""
        port0ints.addChild(Error_UnableToSource)

        Error_BISTIg = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Error: BIST Message Ignored',
                                                            'offset': 47,
                                                            'bit length': 1})

        Error_BISTIg.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller sends a Built-In Self Test message that is ignored by the far end device."""
        port0ints.addChild(Error_BISTIg)

        AMEntryFail = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'AM Entry Failure',
                                                           'offset': 48,
                                                           'bit length': 1})

        AMEntryFail.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller fails to enter an Alternate Mode."""
        port0ints.addChild(AMEntryFail)

        AMEntered = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'AM Entered',
                                                         'offset': 49,
                                                         'bit length': 1})

        AMEntered.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully entered an Alternate Mode."""
        port0ints.addChild(AMEntered)

        VDMMsgSent = register_class.cBooleanDMTerminator(self,
                                                         {'name': 'Vendor Defined Message Sent',
                                                          'offset': 50,
                                                          'bit length': 1})

        VDMMsgSent.help = """Set when a VDM has been sent."""
        port0ints.addChild(VDMMsgSent)

        discModeComp = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Discover Mode Complete',
                                                            'offset': 51,
                                                            'bit length': 1})

        discModeComp.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully Discovered the available modes of the far end device."""
        port0ints.addChild(discModeComp)

        exitModeComp = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Exit Mode Complete',
                                                            'offset': 52,
                                                            'bit length': 1})

        exitModeComp.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully exited an Alternate Mode."""
        port0ints.addChild(exitModeComp)

        UserSvidModeEntered = register_class.cBooleanDMTerminator(self,
                                                                  {'name': 'User SVID Mode Entered',
                                                                   'offset': 56,
                                                                   'bit length': 1})

        UserSvidModeEntered.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully entered a users SVID mode."""
        port0ints.addChild(UserSvidModeEntered)

        UserSvidModeExited = register_class.cBooleanDMTerminator(self,
                                                                 {'name': 'User SVID Mode Exited',
                                                                  'offset': 57,
                                                                  'bit length': 1})

        UserSvidModeExited.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has exited a users SVID mode."""
        port0ints.addChild(UserSvidModeExited)

        UserSvidAttentionVDMReceived = register_class.cBooleanDMTerminator(self,
                                                                           {'name': 'User SVID Attention VDM Received',
                                                                            'offset': 58,
                                                                            'bit length': 1})

        UserSvidAttentionVDMReceived.help = """when this bit is enabled, an I2C interrupt event will be set when a users SVID structured attention vendor defined message is received."""
        port0ints.addChild(UserSvidAttentionVDMReceived)

        UserSvidOtherVDMReceived = register_class.cBooleanDMTerminator(self,
                                                                       {'name': 'User SVID Other VDM Received',
                                                                        'offset': 59,
                                                                        'bit length': 1})

        UserSvidOtherVDMReceived.help = """when this bit is enabled, an I2C interrupt event will be set when a users SVID structured non-Attention VDM or unstructured VDM has been received."""
        port0ints.addChild(UserSvidOtherVDMReceived)

        DPSIDStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'DP SID Status Update',
                                                                 'offset': 62,
                                                                 'bit length': 1})

        DPSIDStatusUpdate.help = """Set when the contents of the DP SID Status register (0x58) change."""
        port0ints.addChild(DPSIDStatusUpdate)

        IntelVIDStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                                   {'name': 'Intel VID Status Update',
                                                                    'offset': 63,
                                                                    'bit length': 1})
        IntelVIDStatusUpdate.hide()
        IntelVIDStatusUpdate.help = """Set when the contents of the Intel VID Status register (0x59) change."""
        port0ints.addChild(IntelVIDStatusUpdate)

        PD3StatusUpdate = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'PD3 Status Update',
                                                               'offset': 64,
                                                               'bit length': 1})

        PD3StatusUpdate.help = """Set when the contents of the PD3.0 Status register (0x41) change."""
        port0ints.addChild(PD3StatusUpdate)

        TXMemBufferEmpty = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'TX Mem Buffer Empty',
                                                                'offset': 65,
                                                                'bit length': 1})

        TXMemBufferEmpty.help = """Transmit memory buffer empty."""
        port0ints.addChild(TXMemBufferEmpty)

        RXMemBufferFull = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'RX Mem Buffer Full',
                                                               'offset': 66,
                                                               'bit length': 1})

        RXMemBufferFull.help = """Transmit memory buffer empty."""
        port0ints.addChild(RXMemBufferFull)

        CustomDVDMArrive = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'Custom VDM Arrive',
                                                                'offset': 67,
                                                                'bit length': 1})

        CustomDVDMArrive.help = """A custom VDM has arrived"""
        port0ints.addChild(CustomDVDMArrive)

        CustomDAMEntered = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'Custom AM Entered',
                                                                'offset': 68,
                                                                'bit length': 1})

        CustomDAMEntered.help = """A custom Alternate Mode has been entered."""
        port0ints.addChild(CustomDAMEntered)

        CustomDVDMMSGSENT = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Custom VDM Message Sent',
                                                                 'offset': 69,
                                                                 'bit length': 1})

        CustomDVDMMSGSENT.help = """A custom VDM has been sent."""
        port0ints.addChild(CustomDVDMMSGSENT)

        ackTime = register_class.cBooleanDMTerminator(self,
                                                      {'name': 'SOC ACK Timeout',
                                                       'offset': 70,
                                                       'bit length': 1})

        ackTime.help = """ACK Timeout Occurred."""
        port0ints.addChild(ackTime)

        FRSSignalReceived = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'FRS Signal Received',
                                                                 'offset': 76,
                                                                 'bit length': 1})

        FRSSignalReceived.help = """An FRS Message has been received."""
        port0ints.addChild(FRSSignalReceived)

        ChunkResponseReceived = register_class.cBooleanDMTerminator(self,
                                                                    {'name': 'Chunk Response Received',
                                                                     'offset': 77,
                                                                     'bit length': 1})

        ChunkResponseReceived.help = """Chunk Response message received."""
        port0ints.addChild(ChunkResponseReceived)

        ChunkRequestReceived = register_class.cBooleanDMTerminator(self,
                                                                   {'name': 'Chunk Request Received',
                                                                    'offset': 78,
                                                                    'bit length': 1})

        ChunkRequestReceived.help = """Chunk Request message received."""
        port0ints.addChild(ChunkRequestReceived)

        AlertMessageReceived = register_class.cBooleanDMTerminator(self,
                                                                   {'name': 'Alert Message Received',
                                                                    'offset': 79,
                                                                    'bit length': 1})

        AlertMessageReceived.help = """An Alert Messae has been received."""
        port0ints.addChild(AlertMessageReceived)

        commonInts = register_class.cDataModelArray(self, 1,
                                                    {'name': 'Common Interrupt Mask for I2C1',
                                                     'offset': 80,
                                                     'bit length': 8})

        self.dataModel.addChild(commonInts)

        patchLoaded = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'Patch Loaded',
                                                           'offset': 0,
                                                           'bit length': 1})

        patchLoaded.help = """when this bit is enabled, an I2C interrupt event will be set when a patch has been loaded onto the device."""
        commonInts.addChild(patchLoaded)

        readyPatch = register_class.cBooleanDMTerminator(self,
                                                         {'name': 'Ready for Patch',
                                                          'offset': 1,
                                                          'bit length': 1})

        readyPatch.help = """when this bit is enabled, an I2C interrupt event will be set when the device is ready to receive a patch."""
        commonInts.addChild(readyPatch)


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cData3_0x1F_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Data Register for CMD3',
                                                 'address': 0x1F,
                                                 'byte length': 4,
                                                 'permission': 'DRW'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'Data Register for CMD1',
                                                         'offset': 0,
                                                         'bit length': 32})

        word1 = register_class.cHexDMTerminator(self,
                                                {'name': 'Word 1 (Least Significant)',
                                                 'offset': 0,
                                                 'bit length': 32})

        self.dataModel.addChild(word1)


#        word2 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 2',
#                                                                     'offset' : 32,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word2)

#        word3 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 3',
#                                                                     'offset' : 64,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word3)

#        word4 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 4',
#                                                                     'offset' : 96,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word4)

#        word5 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 5',
#                                                                     'offset' : 128,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word5)

#        word6 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 6',
#                                                                     'offset' : 160,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word6)

#        word7 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 7',
#                                                                     'offset' : 192,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word7)

#        word8 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 8',
#                                                                     'offset' : 224,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word8)

#        word9 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 9',
#                                                                     'offset' : 256,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word9)

#        word10 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 10',
#                                                                     'offset' : 288,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word10)

#        word11 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 11',
#                                                                     'offset' : 320,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word11)

#        word12 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 12',
#                                                                     'offset' : 352,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word12)

#        word13 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 13',
#                                                                     'offset' : 384,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word13)

#        word14 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 14',
#                                                                     'offset' : 416,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word14)

#        word15 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 15',
#                                                                     'offset' : 448,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word15)

#        word16 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 16',
#                                                                     'offset' : 480,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word16)


########################################################################################################################
########################################################################################################################
########################################################################################################################


class cIntMask2_0x17_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Interrupt Mask for I2C2',
                                                 'address': 0x17,
                                                 'byte length': 11,
                                                 'permission': 'RW'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name': 'Interrupt Mask for I2C2',
                                                         'offset': 0,
                                                         'bit length': 88})

        port1ints = register_class.cDataModelArray(self, 1,
                                                   {'name': 'Interrupt Mask for I2C2',
                                                    'offset': 0,
                                                    'bit length': 80})

        self.dataModel.addChild(port1ints)

        SoftReset = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'Soft Reset',
                                                         'offset': 0,
                                                         'bit length': 1})

        SoftReset.help = """When this bit is enabled, an I2C interrupt event will be set when a PD Soft Reset has been performed. See PD Status.SoftResetType for more information."""
        port1ints.addChild(SoftReset)

        HardReset = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'Hard Reset',
                                                         'offset': 1,
                                                         'bit length': 1})

        HardReset.help = """when this bit is enabled, an I2C interrupt event will be set when a PD Hard Reset has been performed. See PD Status.HardResetDetails for more information."""
        port1ints.addChild(HardReset)

        CableResetEvent = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Cable Reset Event',
                                                               'offset': 2,
                                                               'bit length': 1})

        CableResetEvent.help = """This event occurs when PD Controller sends Cable Reset signaling."""
        port1ints.addChild(CableResetEvent)

        PlugInsertOrRemoval = register_class.cBooleanDMTerminator(self,
                                                                  {'name': 'Plug Insert or Removal',
                                                                   'offset': 3,
                                                                   'bit length': 1})

        PlugInsertOrRemoval.help = """when this bit is enabled, an I2C interrupt event will be set when the user inserts or removes a plug into the Type-C port."""
        port1ints.addChild(PlugInsertOrRemoval)

        PRSwapComplete = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'PR Swap Complete',
                                                              'offset': 4,
                                                              'bit length': 1})

        PRSwapComplete.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller completes a power role swap."""
        port1ints.addChild(PRSwapComplete)

        DRSwapComplete = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'DR Swap Complete',
                                                              'offset': 5,
                                                              'bit length': 1})

        DRSwapComplete.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller completes a data role swap."""
        port1ints.addChild(DRSwapComplete)

        FRSwapComplete = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'FR Swap Complete',
                                                              'offset': 6,
                                                              'bit length': 1})

        FRSwapComplete.help = """A Fast Role Swap has completed."""
        port1ints.addChild(FRSwapComplete)

        RdoReceivedFromSink = register_class.cBooleanDMTerminator(self,
                                                                  {'name': 'RDO Received from Sink',
                                                                   'offset': 7,
                                                                   'bit length': 1})

        RdoReceivedFromSink.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller receives an RDO (Request Data Object) from the sink device."""
        port1ints.addChild(RdoReceivedFromSink)

        Bist = register_class.cBooleanDMTerminator(self,
                                                   {'name': 'Built-In Self Test',
                                                    'offset': 8,
                                                    'bit length': 1})

        Bist.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller completes a Built-In Self Test (BIST). This bit is set whenever the STATUS.BIST changes."""
        port1ints.addChild(Bist)

        Overcurrent = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'Overcurrent Event',
                                                           'offset': 9,
                                                           'bit length': 1})

        Overcurrent.help = """when this bit is enabled, an I2C interrupt event will be set when an Overcurrent Event occurs on VBUS. This bit is set whenever STATUS.Overcurrent changes."""
        port1ints.addChild(Overcurrent)

        AttentionReceived = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Attention Received',
                                                                 'offset': 10,
                                                                 'bit length': 1})

        AttentionReceived.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller received an Attention message."""
        port1ints.addChild(AttentionReceived)

        VDMReceived = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'Vendor-Defined Message Received',
                                                           'offset': 11,
                                                           'bit length': 1})

        VDMReceived.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller receives a Vendor Defined Message from the device it is connected to."""
        port1ints.addChild(VDMReceived)

        NewContractAsCons = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'New Contract as Consumer',
                                                                 'offset': 12,
                                                                 'bit length': 1})

        NewContractAsCons.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller enters a new power contract as a Consumer (Power Sink). This bit is set when an RDO from the far-end device has been accepted and the PD Controller is a Sink. See Active Contract PDO & Active Contract RDO registers for details"""
        port1ints.addChild(NewContractAsCons)

        NewContractAsProv = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'New Contract as Provider',
                                                                 'offset': 13,
                                                                 'bit length': 1})

        NewContractAsProv.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller enters a new power contract as a Provider (Power Source). This bit is set when an RDO from the far-end device has been accepted and the PD Controller is a Source. See Active Contract PDO & Active Contract RDO registers for details"""
        port1ints.addChild(NewContractAsProv)

        SourceCapMsgReady = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Source Capabilities Message Ready',
                                                                 'offset': 14,
                                                                 'bit length': 1})

        SourceCapMsgReady.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller is ready to send its Source Capabilities message has been updated by the far end device."""
        port1ints.addChild(SourceCapMsgReady)

        SinkCapMsgReady = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Sink Capabilities Message Ready',
                                                               'offset': 15,
                                                               'bit length': 1})

        SinkCapMsgReady.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller is ready to send its Sink Capabilities message has been updated by the far end device."""
        port1ints.addChild(SinkCapMsgReady)

        LowVoltageWarning = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Low Voltage Warning',
                                                                 'offset': 16,
                                                                 'bit length': 1})

        LowVoltageWarning.help = """when this bit is enabled, an I2C interrupt event will be set when the voltage level on VBUS is lower than the expected value."""
        port1ints.addChild(LowVoltageWarning)

        PRSwapReq = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'PR Swap Requested',
                                                         'offset': 17,
                                                         'bit length': 1})

        PRSwapReq.help = """when this bit is enabled, an I2C interrupt event will be set when the device attached to the PD controller requests a power role swap."""
        port1ints.addChild(PRSwapReq)

        DRSwapReq = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'DR Swap Requested',
                                                         'offset': 18,
                                                         'bit length': 1})

        DRSwapReq.help = """when this bit is enabled, an I2C interrupt event will be set when the device attached to the PD controller requests a data role swap."""
        port1ints.addChild(DRSwapReq)

        GotoMinReceived = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Goto Min Received',
                                                               'offset': 19,
                                                               'bit length': 1})

        GotoMinReceived.help = """when this bit is enabled, an I2C interrupt event will be set when the PD Controller has received a GotoMin message while in a contract where the GiveBack flag in the RDO was set. The system needs to reduce power consumption down to the level specified in the Auto Negotiate Sink Register (0x37)."""
        port1ints.addChild(GotoMinReceived)

        UsbHostPresent = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'USB Host Present',
                                                              'offset': 20,
                                                              'bit length': 1})

        UsbHostPresent.help = """when this bit is enabled, an I2C interrupt event will be set when there is a USB Host Present on the Type-C port."""
        port1ints.addChild(UsbHostPresent)

        UsbHostPresentNoLonger = register_class.cBooleanDMTerminator(self,
                                                                     {'name': 'USB Host Present no longer',
                                                                      'offset': 21,
                                                                      'bit length': 1})

        UsbHostPresentNoLonger.help = """when this bit is enabled, an I2C interrupt event will be set when a USB Host gets removed from the Type-C port os is no longer available."""
        port1ints.addChild(UsbHostPresentNoLonger)

        HighVoltageWarning = register_class.cBooleanDMTerminator(self,
                                                                 {'name': 'High Voltage Warning',
                                                                  'offset': 22,
                                                                  'bit length': 1})

        HighVoltageWarning.help = """when this bit is enabled, an I2C interrupt event will be set when the voltage on VBUS exceeds the safe threshold."""
        port1ints.addChild(HighVoltageWarning)

        PPswitchChanged = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'PP Switch Changed',
                                                               'offset': 23,
                                                               'bit length': 1})

        PPswitchChanged.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller changes the power path that is currently sourcing or sinking power on VBUS."""
        port1ints.addChild(PPswitchChanged)

        PowerStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Power Status Update',
                                                                 'offset': 24,
                                                                 'bit length': 1})

        PowerStatusUpdate.help = """when this bit is enabled, an I2C interrupt event will be set when the PD Controller updates its power status. This is set when the contents of Register (0x3F) change."""
        port1ints.addChild(PowerStatusUpdate)

        DataStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'Data Status Update',
                                                                'offset': 25,
                                                                'bit length': 1})
        DataStatusUpdate.hide()
        DataStatusUpdate.help = """when this bit is enabled, an I2C interrupt event will be set when the data status is updated on the PD controller. This bit must be set for use with Alpine Ridge thunderbolt controllers. This interrupt is set when the contents of register (0x5F) change."""
        port1ints.addChild(DataStatusUpdate)

        StatusUpdate = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Status Update',
                                                            'offset': 26,
                                                            'bit length': 1})

        StatusUpdate.help = """when this bit is enabled, an I2C interrupt event will be set when the status of the PD controller is updated. This is set when the contents of Register (0x1A) change."""
        port1ints.addChild(StatusUpdate)

        PDStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'PD Status Update',
                                                              'offset': 27,
                                                              'bit length': 1})

        PDStatusUpdate.help = """when this bit is enabled, an I2C interrupt event will be set whenever contents of PD Status register (0x40) change"""
        port1ints.addChild(PDStatusUpdate)

        ADCLowThreshold = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'ADC Low Threshold',
                                                               'offset': 28,
                                                               'bit length': 1})

        ADCLowThreshold.help = """when this bit is enabled, an I2C interrupt event will be set when the ADC Threshold exceeds its lower boundary. (ADC_MON_THR_LO_STAT)"""
        ADCLowThreshold.hide()
        port1ints.addChild(ADCLowThreshold)

        ADCHighThreshold = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'ADC High Threshold',
                                                                'offset': 29,
                                                                'bit length': 1})

        ADCHighThreshold.help = """when this bit is enabled, an I2C interrupt event will be set when the ADC Threshold exceeds its higher boundary. (ADC_MON_THR_HI_STAT)"""
        ADCHighThreshold.hide()
        port1ints.addChild(ADCHighThreshold)

        Cmd1Complete = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'CMD1 Complete',
                                                            'offset': 30,
                                                            'bit length': 1})

        Cmd1Complete.help = """when this bit is enabled, an I2C interrupt event will be set whenever a non-zero value in CMD1 register is set to zero or !CMD."""
        port1ints.addChild(Cmd1Complete)

        Cmd2Complete = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'CMD2 Complete',
                                                            'offset': 31,
                                                            'bit length': 1})

        Cmd2Complete.help = """when this bit is enabled, an I2C interrupt event will be set whenever a non-zero value in CMD2 register is set to zero or !CMD."""
        port1ints.addChild(Cmd2Complete)

        Error_DeviceIncompatible = register_class.cBooleanDMTerminator(self,
                                                                       {'name': 'Error: Device Incompatible',
                                                                        'offset': 32,
                                                                        'bit length': 1})

        Error_DeviceIncompatible.help = """When set to 1, a USB PD device with an incompatible specification version wasconnected. Or the partner device is not USB PD capable."""
        port1ints.addChild(Error_DeviceIncompatible)

        Error_CannotProvideVoltageOrCurrent = register_class.cBooleanDMTerminator(self,
                                                                                  {
                                                                                      'name': 'Error: Cannot Provide Voltage or Current',
                                                                                      'offset': 33,
                                                                                      'bit length': 1})

        Error_CannotProvideVoltageOrCurrent.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller is unable to source the power required for the current PDO."""
        port1ints.addChild(Error_CannotProvideVoltageOrCurrent)

        Error_CanProvideVoltageOrCurrentLater = register_class.cBooleanDMTerminator(self,
                                                                                    {
                                                                                        'name': 'Error: Cannot Provide Voltage or Current Later',
                                                                                        'offset': 34,
                                                                                        'bit length': 1})

        Error_CanProvideVoltageOrCurrentLater.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller is unable to sustain sourcing the power required for the current PDO."""
        port1ints.addChild(Error_CanProvideVoltageOrCurrentLater)

        Error_PowerEventOccurred = register_class.cBooleanDMTerminator(self,
                                                                       {'name': 'Error: Power Event Occurred',
                                                                        'offset': 35,
                                                                        'bit length': 1})

        Error_PowerEventOccurred.help = """when this bit is enabled, an I2C interrupt event will be set when an OVP (Over-Voltage Protection) or short circuit event occured on VBUS"""
        port1ints.addChild(Error_PowerEventOccurred)

        Error_MissingGetCapMessage = register_class.cBooleanDMTerminator(self,
                                                                         {
                                                                             'name': 'Error: Missing Get Capabilities Message',
                                                                             'offset': 36,
                                                                             'bit length': 1})

        Error_MissingGetCapMessage.help = """when this bit is enabled, an I2C interrupt event will be set when he partner device did not respond to the Get_Sink_Cap or Get_Source_Cap message that was sent."""
        port1ints.addChild(Error_MissingGetCapMessage)

        Error_ProtError = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Error: Protocol Error',
                                                               'offset': 38,
                                                               'bit length': 1})

        Error_ProtError.help = """when this bit is enabled, an I2C interrupt event will be set when an unexpected message was received from the partner device."""

        port1ints.addChild(Error_ProtError)

        Error_MessageData = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Error: Message Data',
                                                                 'offset': 39,
                                                                 'bit length': 1})

        Error_MessageData.help = """when this bit is enabled, an I2C interrupt event will be set when a message was received and the CRC failed or the data length in the header (“Number of Data Objects”) did not match the actual amount of data received or its signal level caused the message to be deemed invalid."""
        port1ints.addChild(Error_MessageData)

        Error_DischargeFailed = register_class.cBooleanDMTerminator(self,
                                                                    {'name': 'Error: Discharge Failed',
                                                                     'offset': 41,
                                                                     'bit length': 1})

        Error_DischargeFailed.help = """when this bit is enabled, an I2C interrupt event will be set when the PD Controller fails to discharge VBUS"""
        port1ints.addChild(Error_DischargeFailed)

        SnkTransitionComplete = register_class.cBooleanDMTerminator(self,
                                                                    {'name': 'Sink Transition Complete',
                                                                     'offset': 42,
                                                                     'bit length': 1})

        SnkTransitionComplete.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully transitioned into a power sink."""
        port1ints.addChild(SnkTransitionComplete)

        iclProchot = register_class.cBooleanDMTerminator(self,
                                                         {'name': 'Ice Lake Proc Hot Notification',
                                                          'offset': 44,
                                                          'bit length': 1})
        port1ints.addChild(iclProchot)

        Error_UnableToSource = register_class.cBooleanDMTerminator(self,
                                                                   {'name': 'Error: Unable to Source',
                                                                    'offset': 46,
                                                                    'bit length': 1})

        Error_UnableToSource.help = """when this bit is enabled, an I2C interrupt event will be set when the source device is unable to increase the voltage to the negotiated voltage of the PD contract."""
        port1ints.addChild(Error_UnableToSource)

        Error_BISTIg = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Error: BIST Message Ignored',
                                                            'offset': 47,
                                                            'bit length': 1})

        Error_BISTIg.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller sends a Built-In Self Test message that is ignored by the far end device."""
        port1ints.addChild(Error_BISTIg)

        AMEntryFail = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'AM Entry Failure',
                                                           'offset': 48,
                                                           'bit length': 1})

        AMEntryFail.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller fails to enter an Alternate Mode."""
        port1ints.addChild(AMEntryFail)

        AMEntered = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'AM Entered',
                                                         'offset': 49,
                                                         'bit length': 1})

        AMEntered.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully entered an Alternate Mode."""
        port1ints.addChild(AMEntered)

        VDMMsgSent = register_class.cBooleanDMTerminator(self,
                                                         {'name': 'Vendor Defined Message Sent',
                                                          'offset': 50,
                                                          'bit length': 1})

        VDMMsgSent.help = """Set when a VDM has been sent."""
        port1ints.addChild(VDMMsgSent)

        discModeComp = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Discover Mode Complete',
                                                            'offset': 51,
                                                            'bit length': 1})

        discModeComp.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully Discovered the available modes of the far end device."""
        port1ints.addChild(discModeComp)

        exitModeComp = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Exit Mode Complete',
                                                            'offset': 52,
                                                            'bit length': 1})

        exitModeComp.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully exited an Alternate Mode."""
        port1ints.addChild(exitModeComp)

        UserSvidModeEntered = register_class.cBooleanDMTerminator(self,
                                                                  {'name': 'User SVID Mode Entered',
                                                                   'offset': 56,
                                                                   'bit length': 1})

        UserSvidModeEntered.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully entered a users SVID mode."""
        port1ints.addChild(UserSvidModeEntered)

        UserSvidModeExited = register_class.cBooleanDMTerminator(self,
                                                                 {'name': 'User SVID Mode Exited',
                                                                  'offset': 57,
                                                                  'bit length': 1})

        UserSvidModeExited.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has exited a users SVID mode."""
        port1ints.addChild(UserSvidModeExited)

        UserSvidAttentionVDMReceived = register_class.cBooleanDMTerminator(self,
                                                                           {'name': 'User SVID Attention VDM Received',
                                                                            'offset': 58,
                                                                            'bit length': 1})

        UserSvidAttentionVDMReceived.help = """when this bit is enabled, an I2C interrupt event will be set when a users SVID structured attention vendor defined message is received."""
        port1ints.addChild(UserSvidAttentionVDMReceived)

        UserSvidOtherVDMReceived = register_class.cBooleanDMTerminator(self,
                                                                       {'name': 'User SVID Other VDM Received',
                                                                        'offset': 59,
                                                                        'bit length': 1})

        UserSvidOtherVDMReceived.help = """when this bit is enabled, an I2C interrupt event will be set when a users SVID structured non-Attention VDM or unstructured VDM has been received."""
        port1ints.addChild(UserSvidOtherVDMReceived)

        DPSIDStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'DP SID Status Update',
                                                                 'offset': 62,
                                                                 'bit length': 1})

        DPSIDStatusUpdate.help = """Set when the contents of the DP SID Status register (0x58) change."""
        port1ints.addChild(DPSIDStatusUpdate)

        IntelVIDStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                                   {'name': 'Intel VID Status Update',
                                                                    'offset': 63,
                                                                    'bit length': 1})
        IntelVIDStatusUpdate.hide()
        IntelVIDStatusUpdate.help = """Set when the contents of the Intel VID Status register (0x59) change."""
        port1ints.addChild(IntelVIDStatusUpdate)

        PD3StatusUpdate = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'PD3 Status Update',
                                                               'offset': 64,
                                                               'bit length': 1})

        PD3StatusUpdate.help = """Set when the contents of the PD3.0 Status register (0x41) change."""
        port1ints.addChild(PD3StatusUpdate)

        TXMemBufferEmpty = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'TX Mem Buffer Empty',
                                                                'offset': 65,
                                                                'bit length': 1})

        TXMemBufferEmpty.help = """Transmit memory buffer empty."""
        port1ints.addChild(TXMemBufferEmpty)

        RXMemBufferFull = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'RX Mem Buffer Full',
                                                               'offset': 66,
                                                               'bit length': 1})

        RXMemBufferFull.help = """Transmit memory buffer empty."""
        port1ints.addChild(RXMemBufferFull)

        CustomDVDMArrive = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'Custom VDM Arrive',
                                                                'offset': 67,
                                                                'bit length': 1})

        CustomDVDMArrive.help = """A custom VDM has arrived"""
        port1ints.addChild(CustomDVDMArrive)

        CustomDAMEntered = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'Custom AM Entered',
                                                                'offset': 68,
                                                                'bit length': 1})

        CustomDAMEntered.help = """A custom Alternate Mode has been entered."""
        port1ints.addChild(CustomDAMEntered)

        CustomDVDMMSGSENT = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Custom VDM Message Sent',
                                                                 'offset': 69,
                                                                 'bit length': 1})

        CustomDVDMMSGSENT.help = """A custom VDM has been sent."""
        port1ints.addChild(CustomDVDMMSGSENT)

        ackTime = register_class.cBooleanDMTerminator(self,
                                                      {'name': 'SOC ACK Timeout',
                                                       'offset': 70,
                                                       'bit length': 1})

        ackTime.help = """ACK Timeout Occurred."""
        port1ints.addChild(ackTime)

        FRSSignalReceived = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'FRS Signal Received',
                                                                 'offset': 76,
                                                                 'bit length': 1})

        FRSSignalReceived.help = """An FRS Message has been received."""
        port1ints.addChild(FRSSignalReceived)

        ChunkResponseReceived = register_class.cBooleanDMTerminator(self,
                                                                    {'name': 'Chunk Response Received',
                                                                     'offset': 77,
                                                                     'bit length': 1})

        ChunkResponseReceived.help = """Chunk Response message received."""
        port1ints.addChild(ChunkResponseReceived)

        ChunkRequestReceived = register_class.cBooleanDMTerminator(self,
                                                                   {'name': 'Chunk Request Received',
                                                                    'offset': 78,
                                                                    'bit length': 1})

        ChunkRequestReceived.help = """Chunk Request message received."""
        port1ints.addChild(ChunkRequestReceived)

        AlertMessageReceived = register_class.cBooleanDMTerminator(self,
                                                                   {'name': 'Alert Message Received',
                                                                    'offset': 79,
                                                                    'bit length': 1})

        AlertMessageReceived.help = """An Alert Messae has been received."""
        port1ints.addChild(AlertMessageReceived)

        commonInts = register_class.cDataModelArray(self, 1,
                                                    {'name': 'Common Interrupt Mask for I2C1',
                                                     'offset': 80,
                                                     'bit length': 8})

        self.dataModel.addChild(commonInts)

        patchLoaded = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'Patch Loaded',
                                                           'offset': 0,
                                                           'bit length': 1})

        patchLoaded.help = """when this bit is enabled, an I2C interrupt event will be set when a patch has been loaded onto the device."""
        commonInts.addChild(patchLoaded)

        readyPatch = register_class.cBooleanDMTerminator(self,
                                                         {'name': 'Ready for Patch',
                                                          'offset': 1,
                                                          'bit length': 1})

        readyPatch.help = """when this bit is enabled, an I2C interrupt event will be set when the device is ready to receive a patch."""
        commonInts.addChild(readyPatch)


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cIntClear1_0x18_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Interrupt Clear for I2C1',
                                                 'address': 0x18,
                                                 'byte length': 11,
                                                 'permission': 'DRW'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name': 'Interrupt Clear for I2C1',
                                                         'offset': 0,
                                                         'bit length': 88})

        port0ints = register_class.cDataModelArray(self, 1,
                                                   {'name': 'Interrupt Clear for I2C1',
                                                    'offset': 0,
                                                    'bit length': 80})

        self.dataModel.addChild(port0ints)

        SoftReset = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'Soft Reset',
                                                         'offset': 0,
                                                         'bit length': 1})

        SoftReset.help = """When this bit is enabled, an I2C interrupt event will be set when a PD Soft Reset has been performed. See PD Status.SoftResetType for more information."""
        port0ints.addChild(SoftReset)

        HardReset = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'Hard Reset',
                                                         'offset': 1,
                                                         'bit length': 1})

        HardReset.help = """when this bit is enabled, an I2C interrupt event will be set when a PD Hard Reset has been performed. See PD Status.HardResetDetails for more information."""
        port0ints.addChild(HardReset)

        CableResetEvent = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Cable Reset Event',
                                                               'offset': 2,
                                                               'bit length': 1})

        CableResetEvent.help = """This event occurs when PD Controller sends Cable Reset signaling."""
        port0ints.addChild(CableResetEvent)

        PlugInsertOrRemoval = register_class.cBooleanDMTerminator(self,
                                                                  {'name': 'Plug Insert or Removal',
                                                                   'offset': 3,
                                                                   'bit length': 1})

        PlugInsertOrRemoval.help = """when this bit is enabled, an I2C interrupt event will be set when the user inserts or removes a plug into the Type-C port."""
        port0ints.addChild(PlugInsertOrRemoval)

        PRSwapComplete = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'PR Swap Complete',
                                                              'offset': 4,
                                                              'bit length': 1})

        PRSwapComplete.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller completes a power role swap."""
        port0ints.addChild(PRSwapComplete)

        DRSwapComplete = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'DR Swap Complete',
                                                              'offset': 5,
                                                              'bit length': 1})

        DRSwapComplete.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller completes a data role swap."""
        port0ints.addChild(DRSwapComplete)

        FRSwapComplete = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'FR Swap Complete',
                                                              'offset': 6,
                                                              'bit length': 1})

        FRSwapComplete.help = """A Fast Role Swap has completed."""
        port0ints.addChild(FRSwapComplete)

        RdoReceivedFromSink = register_class.cBooleanDMTerminator(self,
                                                                  {'name': 'RDO Received from Sink',
                                                                   'offset': 7,
                                                                   'bit length': 1})

        RdoReceivedFromSink.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller receives an RDO (Request Data Object) from the sink device."""
        port0ints.addChild(RdoReceivedFromSink)

        Bist = register_class.cBooleanDMTerminator(self,
                                                   {'name': 'Built-In Self Test',
                                                    'offset': 8,
                                                    'bit length': 1})

        Bist.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller completes a Built-In Self Test (BIST). This bit is set whenever the STATUS.BIST changes."""
        port0ints.addChild(Bist)

        Overcurrent = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'Overcurrent Event',
                                                           'offset': 9,
                                                           'bit length': 1})

        Overcurrent.help = """when this bit is enabled, an I2C interrupt event will be set when an Overcurrent Event occurs on VBUS. This bit is set whenever STATUS.Overcurrent changes."""
        port0ints.addChild(Overcurrent)

        AttentionReceived = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Attention Received',
                                                                 'offset': 10,
                                                                 'bit length': 1})

        AttentionReceived.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller received an Attention message."""
        port0ints.addChild(AttentionReceived)

        VDMReceived = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'Vendor-Defined Message Received',
                                                           'offset': 11,
                                                           'bit length': 1})

        VDMReceived.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller receives a Vendor Defined Message from the device it is connected to."""
        port0ints.addChild(VDMReceived)

        NewContractAsCons = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'New Contract as Consumer',
                                                                 'offset': 12,
                                                                 'bit length': 1})

        NewContractAsCons.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller enters a new power contract as a Consumer (Power Sink). This bit is set when an RDO from the far-end device has been accepted and the PD Controller is a Sink. See Active Contract PDO & Active Contract RDO registers for details"""
        port0ints.addChild(NewContractAsCons)

        NewContractAsProv = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'New Contract as Provider',
                                                                 'offset': 13,
                                                                 'bit length': 1})

        NewContractAsProv.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller enters a new power contract as a Provider (Power Source). This bit is set when an RDO from the far-end device has been accepted and the PD Controller is a Source. See Active Contract PDO & Active Contract RDO registers for details"""
        port0ints.addChild(NewContractAsProv)

        SourceCapMsgReady = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Source Capabilities Message Ready',
                                                                 'offset': 14,
                                                                 'bit length': 1})

        SourceCapMsgReady.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller is ready to send its Source Capabilities message has been updated by the far end device."""
        port0ints.addChild(SourceCapMsgReady)

        SinkCapMsgReady = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Sink Capabilities Message Ready',
                                                               'offset': 15,
                                                               'bit length': 1})

        SinkCapMsgReady.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller is ready to send its Sink Capabilities message has been updated by the far end device."""
        port0ints.addChild(SinkCapMsgReady)

        LowVoltageWarning = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Low Voltage Warning',
                                                                 'offset': 16,
                                                                 'bit length': 1})

        LowVoltageWarning.help = """when this bit is enabled, an I2C interrupt event will be set when the voltage level on VBUS is lower than the expected value."""
        port0ints.addChild(LowVoltageWarning)

        PRSwapReq = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'PR Swap Requested',
                                                         'offset': 17,
                                                         'bit length': 1})

        PRSwapReq.help = """when this bit is enabled, an I2C interrupt event will be set when the device attached to the PD controller requests a power role swap."""
        port0ints.addChild(PRSwapReq)

        DRSwapReq = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'DR Swap Requested',
                                                         'offset': 18,
                                                         'bit length': 1})

        DRSwapReq.help = """when this bit is enabled, an I2C interrupt event will be set when the device attached to the PD controller requests a data role swap."""
        port0ints.addChild(DRSwapReq)

        GotoMinReceived = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Goto Min Received',
                                                               'offset': 19,
                                                               'bit length': 1})

        GotoMinReceived.help = """when this bit is enabled, an I2C interrupt event will be set when the PD Controller has received a GotoMin message while in a contract where the GiveBack flag in the RDO was set. The system needs to reduce power consumption down to the level specified in the Auto Negotiate Sink Register (0x37)."""
        port0ints.addChild(GotoMinReceived)

        UsbHostPresent = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'USB Host Present',
                                                              'offset': 20,
                                                              'bit length': 1})

        UsbHostPresent.help = """when this bit is enabled, an I2C interrupt event will be set when there is a USB Host Present on the Type-C port."""
        port0ints.addChild(UsbHostPresent)

        UsbHostPresentNoLonger = register_class.cBooleanDMTerminator(self,
                                                                     {'name': 'USB Host Present no longer',
                                                                      'offset': 21,
                                                                      'bit length': 1})

        UsbHostPresentNoLonger.help = """when this bit is enabled, an I2C interrupt event will be set when a USB Host gets removed from the Type-C port os is no longer available."""
        port0ints.addChild(UsbHostPresentNoLonger)

        HighVoltageWarning = register_class.cBooleanDMTerminator(self,
                                                                 {'name': 'High Voltage Warning',
                                                                  'offset': 22,
                                                                  'bit length': 1})

        HighVoltageWarning.help = """when this bit is enabled, an I2C interrupt event will be set when the voltage on VBUS exceeds the safe threshold."""
        port0ints.addChild(HighVoltageWarning)

        PPswitchChanged = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'PP Switch Changed',
                                                               'offset': 23,
                                                               'bit length': 1})

        PPswitchChanged.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller changes the power path that is currently sourcing or sinking power on VBUS."""
        port0ints.addChild(PPswitchChanged)

        PowerStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Power Status Update',
                                                                 'offset': 24,
                                                                 'bit length': 1})

        PowerStatusUpdate.help = """when this bit is enabled, an I2C interrupt event will be set when the PD Controller updates its power status. This is set when the contents of Register (0x3F) change."""
        port0ints.addChild(PowerStatusUpdate)

        DataStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'Data Status Update',
                                                                'offset': 25,
                                                                'bit length': 1})
        DataStatusUpdate.hide()
        DataStatusUpdate.help = """when this bit is enabled, an I2C interrupt event will be set when the data status is updated on the PD controller. This bit must be set for use with Alpine Ridge thunderbolt controllers. This interrupt is set when the contents of register (0x5F) change."""
        port0ints.addChild(DataStatusUpdate)

        StatusUpdate = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Status Update',
                                                            'offset': 26,
                                                            'bit length': 1})

        StatusUpdate.help = """when this bit is enabled, an I2C interrupt event will be set when the status of the PD controller is updated. This is set when the contents of Register (0x1A) change."""
        port0ints.addChild(StatusUpdate)

        PDStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'PD Status Update',
                                                              'offset': 27,
                                                              'bit length': 1})

        PDStatusUpdate.help = """when this bit is enabled, an I2C interrupt event will be set whenever contents of PD Status register (0x40) change"""
        port0ints.addChild(PDStatusUpdate)

        ADCLowThreshold = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'ADC Low Threshold',
                                                               'offset': 28,
                                                               'bit length': 1})

        ADCLowThreshold.help = """when this bit is enabled, an I2C interrupt event will be set when the ADC Threshold exceeds its lower boundary. (ADC_MON_THR_LO_STAT)"""
        ADCLowThreshold.hide()
        port0ints.addChild(ADCLowThreshold)

        ADCHighThreshold = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'ADC High Threshold',
                                                                'offset': 29,
                                                                'bit length': 1})

        ADCHighThreshold.help = """when this bit is enabled, an I2C interrupt event will be set when the ADC Threshold exceeds its higher boundary. (ADC_MON_THR_HI_STAT)"""
        ADCHighThreshold.hide()
        port0ints.addChild(ADCHighThreshold)

        Cmd1Complete = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'CMD1 Complete',
                                                            'offset': 30,
                                                            'bit length': 1})

        Cmd1Complete.help = """when this bit is enabled, an I2C interrupt event will be set whenever a non-zero value in CMD1 register is set to zero or !CMD."""
        port0ints.addChild(Cmd1Complete)

        Cmd2Complete = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'CMD2 Complete',
                                                            'offset': 31,
                                                            'bit length': 1})

        Cmd2Complete.help = """when this bit is enabled, an I2C interrupt event will be set whenever a non-zero value in CMD2 register is set to zero or !CMD."""
        port0ints.addChild(Cmd2Complete)

        Error_DeviceIncompatible = register_class.cBooleanDMTerminator(self,
                                                                       {'name': 'Error: Device Incompatible',
                                                                        'offset': 32,
                                                                        'bit length': 1})

        Error_DeviceIncompatible.help = """When set to 1, a USB PD device with an incompatible specification version wasconnected. Or the partner device is not USB PD capable."""
        port0ints.addChild(Error_DeviceIncompatible)

        Error_CannotProvideVoltageOrCurrent = register_class.cBooleanDMTerminator(self,
                                                                                  {
                                                                                      'name': 'Error: Cannot Provide Voltage or Current',
                                                                                      'offset': 33,
                                                                                      'bit length': 1})

        Error_CannotProvideVoltageOrCurrent.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller is unable to source the power required for the current PDO."""
        port0ints.addChild(Error_CannotProvideVoltageOrCurrent)

        Error_CanProvideVoltageOrCurrentLater = register_class.cBooleanDMTerminator(self,
                                                                                    {
                                                                                        'name': 'Error: Cannot Provide Voltage or Current Later',
                                                                                        'offset': 34,
                                                                                        'bit length': 1})

        Error_CanProvideVoltageOrCurrentLater.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller is unable to sustain sourcing the power required for the current PDO."""
        port0ints.addChild(Error_CanProvideVoltageOrCurrentLater)

        Error_PowerEventOccurred = register_class.cBooleanDMTerminator(self,
                                                                       {'name': 'Error: Power Event Occurred',
                                                                        'offset': 35,
                                                                        'bit length': 1})

        Error_PowerEventOccurred.help = """when this bit is enabled, an I2C interrupt event will be set when an OVP (Over-Voltage Protection) or short circuit event occured on VBUS"""
        port0ints.addChild(Error_PowerEventOccurred)

        Error_MissingGetCapMessage = register_class.cBooleanDMTerminator(self,
                                                                         {
                                                                             'name': 'Error: Missing Get Capabilities Message',
                                                                             'offset': 36,
                                                                             'bit length': 1})

        Error_MissingGetCapMessage.help = """when this bit is enabled, an I2C interrupt event will be set when he partner device did not respond to the Get_Sink_Cap or Get_Source_Cap message that was sent."""
        port0ints.addChild(Error_MissingGetCapMessage)

        Error_ProtError = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Error: Protocol Error',
                                                               'offset': 38,
                                                               'bit length': 1})

        Error_ProtError.help = """when this bit is enabled, an I2C interrupt event will be set when an unexpected message was received from the partner device."""

        port0ints.addChild(Error_ProtError)

        Error_MessageData = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Error: Message Data',
                                                                 'offset': 39,
                                                                 'bit length': 1})

        Error_MessageData.help = """when this bit is enabled, an I2C interrupt event will be set when a message was received and the CRC failed or the data length in the header (“Number of Data Objects”) did not match the actual amount of data received or its signal level caused the message to be deemed invalid."""
        port0ints.addChild(Error_MessageData)

        Error_DischargeFailed = register_class.cBooleanDMTerminator(self,
                                                                    {'name': 'Error: Discharge Failed',
                                                                     'offset': 41,
                                                                     'bit length': 1})

        Error_DischargeFailed.help = """when this bit is enabled, an I2C interrupt event will be set when the PD Controller fails to discharge VBUS"""
        port0ints.addChild(Error_DischargeFailed)

        SnkTransitionComplete = register_class.cBooleanDMTerminator(self,
                                                                    {'name': 'Sink Transition Complete',
                                                                     'offset': 42,
                                                                     'bit length': 1})

        SnkTransitionComplete.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully transitioned into a power sink."""
        port0ints.addChild(SnkTransitionComplete)

        iclProchot = register_class.cBooleanDMTerminator(self,
                                                         {'name': 'Ice Lake Proc Hot Notification',
                                                          'offset': 44,
                                                          'bit length': 1})
        # port0ints.addChild(ICLProcHot)

        Error_UnableToSource = register_class.cBooleanDMTerminator(self,
                                                                   {'name': 'Error: Unable to Source',
                                                                    'offset': 46,
                                                                    'bit length': 1})

        Error_UnableToSource.help = """when this bit is enabled, an I2C interrupt event will be set when the source device is unable to increase the voltage to the negotiated voltage of the PD contract."""
        port0ints.addChild(Error_UnableToSource)

        Error_BISTIg = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Error: BIST Message Ignored',
                                                            'offset': 47,
                                                            'bit length': 1})

        Error_BISTIg.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller sends a Built-In Self Test message that is ignored by the far end device."""
        port0ints.addChild(Error_BISTIg)

        AMEntryFail = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'AM Entry Failure',
                                                           'offset': 48,
                                                           'bit length': 1})

        AMEntryFail.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller fails to enter an Alternate Mode."""
        port0ints.addChild(AMEntryFail)

        AMEntered = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'AM Entered',
                                                         'offset': 49,
                                                         'bit length': 1})

        AMEntered.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully entered an Alternate Mode."""
        port0ints.addChild(AMEntered)

        VDMMsgSent = register_class.cBooleanDMTerminator(self,
                                                         {'name': 'Vendor Defined Message Sent',
                                                          'offset': 50,
                                                          'bit length': 1})

        VDMMsgSent.help = """Set when a VDM has been sent."""
        port0ints.addChild(VDMMsgSent)

        discModeComp = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Discover Mode Complete',
                                                            'offset': 51,
                                                            'bit length': 1})

        discModeComp.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully Discovered the available modes of the far end device."""
        port0ints.addChild(discModeComp)

        exitModeComp = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Exit Mode Complete',
                                                            'offset': 52,
                                                            'bit length': 1})

        exitModeComp.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully exited an Alternate Mode."""
        port0ints.addChild(exitModeComp)

        UserSvidModeEntered = register_class.cBooleanDMTerminator(self,
                                                                  {'name': 'User SVID Mode Entered',
                                                                   'offset': 56,
                                                                   'bit length': 1})

        UserSvidModeEntered.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully entered a users SVID mode."""
        port0ints.addChild(UserSvidModeEntered)

        UserSvidModeExited = register_class.cBooleanDMTerminator(self,
                                                                 {'name': 'User SVID Mode Exited',
                                                                  'offset': 57,
                                                                  'bit length': 1})

        UserSvidModeExited.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has exited a users SVID mode."""
        port0ints.addChild(UserSvidModeExited)

        UserSvidAttentionVDMReceived = register_class.cBooleanDMTerminator(self,
                                                                           {'name': 'User SVID Attention VDM Received',
                                                                            'offset': 58,
                                                                            'bit length': 1})

        UserSvidAttentionVDMReceived.help = """when this bit is enabled, an I2C interrupt event will be set when a users SVID structured attention vendor defined message is received."""
        port0ints.addChild(UserSvidAttentionVDMReceived)

        UserSvidOtherVDMReceived = register_class.cBooleanDMTerminator(self,
                                                                       {'name': 'User SVID Other VDM Received',
                                                                        'offset': 59,
                                                                        'bit length': 1})

        UserSvidOtherVDMReceived.help = """when this bit is enabled, an I2C interrupt event will be set when a users SVID structured non-Attention VDM or unstructured VDM has been received."""
        port0ints.addChild(UserSvidOtherVDMReceived)

        DPSIDStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'DP SID Status Update',
                                                                 'offset': 62,
                                                                 'bit length': 1})

        DPSIDStatusUpdate.help = """Set when the contents of the DP SID Status register (0x58) change."""
        port0ints.addChild(DPSIDStatusUpdate)

        IntelVIDStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                                   {'name': 'Intel VID Status Update',
                                                                    'offset': 63,
                                                                    'bit length': 1})
        IntelVIDStatusUpdate.hide()
        IntelVIDStatusUpdate.help = """Set when the contents of the Intel VID Status register (0x59) change."""
        port0ints.addChild(IntelVIDStatusUpdate)

        PD3StatusUpdate = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'PD3 Status Update',
                                                               'offset': 64,
                                                               'bit length': 1})

        PD3StatusUpdate.help = """Set when the contents of the PD3.0 Status register (0x41) change."""
        port0ints.addChild(PD3StatusUpdate)

        TXMemBufferEmpty = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'TX Mem Buffer Empty',
                                                                'offset': 65,
                                                                'bit length': 1})

        TXMemBufferEmpty.help = """Transmit memory buffer empty."""
        port0ints.addChild(TXMemBufferEmpty)

        RXMemBufferFull = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'RX Mem Buffer Full',
                                                               'offset': 66,
                                                               'bit length': 1})

        RXMemBufferFull.help = """Transmit memory buffer empty."""
        port0ints.addChild(RXMemBufferFull)

        CustomDVDMArrive = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'Custom VDM Arrive',
                                                                'offset': 67,
                                                                'bit length': 1})

        CustomDVDMArrive.help = """A custom VDM has arrived"""
        port0ints.addChild(CustomDVDMArrive)

        CustomDAMEntered = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'Custom AM Entered',
                                                                'offset': 68,
                                                                'bit length': 1})

        CustomDAMEntered.help = """A custom Alternate Mode has been entered."""
        port0ints.addChild(CustomDAMEntered)

        CustomDVDMMSGSENT = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Custom VDM Message Sent',
                                                                 'offset': 69,
                                                                 'bit length': 1})

        CustomDVDMMSGSENT.help = """A custom VDM has been sent."""
        port0ints.addChild(CustomDVDMMSGSENT)

        ackTime = register_class.cBooleanDMTerminator(self,
                                                      {'name': 'SOC ACK Timeout',
                                                       'offset': 70,
                                                       'bit length': 1})

        ackTime.help = """ACK Timeout Occurred."""
        port0ints.addChild(ackTime)

        FRSSignalReceived = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'FRS Signal Received',
                                                                 'offset': 76,
                                                                 'bit length': 1})

        FRSSignalReceived.help = """An FRS Message has been received."""
        port0ints.addChild(FRSSignalReceived)

        ChunkResponseReceived = register_class.cBooleanDMTerminator(self,
                                                                    {'name': 'Chunk Response Received',
                                                                     'offset': 77,
                                                                     'bit length': 1})

        ChunkResponseReceived.help = """Chunk Response message received."""
        port0ints.addChild(ChunkResponseReceived)

        ChunkRequestReceived = register_class.cBooleanDMTerminator(self,
                                                                   {'name': 'Chunk Request Received',
                                                                    'offset': 78,
                                                                    'bit length': 1})

        ChunkRequestReceived.help = """Chunk Request message received."""
        port0ints.addChild(ChunkRequestReceived)

        AlertMessageReceived = register_class.cBooleanDMTerminator(self,
                                                                   {'name': 'Alert Message Received',
                                                                    'offset': 79,
                                                                    'bit length': 1})

        AlertMessageReceived.help = """An Alert Messae has been received."""
        port0ints.addChild(AlertMessageReceived)

        commonInts = register_class.cDataModelArray(self, 1,
                                                    {'name': 'Common Interrupt Mask for I2C1',
                                                     'offset': 80,
                                                     'bit length': 8})

        self.dataModel.addChild(commonInts)

        patchLoaded = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'Patch Loaded',
                                                           'offset': 0,
                                                           'bit length': 1})

        patchLoaded.help = """when this bit is enabled, an I2C interrupt event will be set when a patch has been loaded onto the device."""
        commonInts.addChild(patchLoaded)

        readyPatch = register_class.cBooleanDMTerminator(self,
                                                         {'name': 'Ready for Patch',
                                                          'offset': 1,
                                                          'bit length': 1})

        readyPatch.help = """when this bit is enabled, an I2C interrupt event will be set when the device is ready to receive a patch."""
        commonInts.addChild(readyPatch)


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cIntClear2_0x19_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Interrupt Clear for I2C2',
                                                 'address': 0x19,
                                                 'byte length': 11,
                                                 'permission': 'DRW'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name': 'Interrupt Clear for I2C2',
                                                         'offset': 0,
                                                         'bit length': 88})

        port1ints = register_class.cDataModelArray(self, 1,
                                                   {'name': 'Interrupt Clear for I2C2',
                                                    'offset': 0,
                                                    'bit length': 80})

        self.dataModel.addChild(port1ints)

        SoftReset = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'Soft Reset',
                                                         'offset': 0,
                                                         'bit length': 1})

        SoftReset.help = """When this bit is enabled, an I2C interrupt event will be set when a PD Soft Reset has been performed. See PD Status.SoftResetType for more information."""
        port1ints.addChild(SoftReset)

        HardReset = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'Hard Reset',
                                                         'offset': 1,
                                                         'bit length': 1})

        HardReset.help = """when this bit is enabled, an I2C interrupt event will be set when a PD Hard Reset has been performed. See PD Status.HardResetDetails for more information."""
        port1ints.addChild(HardReset)

        CableResetEvent = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Cable Reset Event',
                                                               'offset': 2,
                                                               'bit length': 1})

        CableResetEvent.help = """This event occurs when PD Controller sends Cable Reset signaling."""
        port1ints.addChild(CableResetEvent)

        PlugInsertOrRemoval = register_class.cBooleanDMTerminator(self,
                                                                  {'name': 'Plug Insert or Removal',
                                                                   'offset': 3,
                                                                   'bit length': 1})

        PlugInsertOrRemoval.help = """when this bit is enabled, an I2C interrupt event will be set when the user inserts or removes a plug into the Type-C port."""
        port1ints.addChild(PlugInsertOrRemoval)

        PRSwapComplete = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'PR Swap Complete',
                                                              'offset': 4,
                                                              'bit length': 1})

        PRSwapComplete.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller completes a power role swap."""
        port1ints.addChild(PRSwapComplete)

        DRSwapComplete = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'DR Swap Complete',
                                                              'offset': 5,
                                                              'bit length': 1})

        DRSwapComplete.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller completes a data role swap."""
        port1ints.addChild(DRSwapComplete)

        FRSwapComplete = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'FR Swap Complete',
                                                              'offset': 6,
                                                              'bit length': 1})

        FRSwapComplete.help = """A Fast Role Swap has completed."""
        port1ints.addChild(FRSwapComplete)

        RdoReceivedFromSink = register_class.cBooleanDMTerminator(self,
                                                                  {'name': 'RDO Received from Sink',
                                                                   'offset': 7,
                                                                   'bit length': 1})

        RdoReceivedFromSink.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller receives an RDO (Request Data Object) from the sink device."""
        port1ints.addChild(RdoReceivedFromSink)

        Bist = register_class.cBooleanDMTerminator(self,
                                                   {'name': 'Built-In Self Test',
                                                    'offset': 8,
                                                    'bit length': 1})

        Bist.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller completes a Built-In Self Test (BIST). This bit is set whenever the STATUS.BIST changes."""
        port1ints.addChild(Bist)

        Overcurrent = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'Overcurrent Event',
                                                           'offset': 9,
                                                           'bit length': 1})

        Overcurrent.help = """when this bit is enabled, an I2C interrupt event will be set when an Overcurrent Event occurs on VBUS. This bit is set whenever STATUS.Overcurrent changes."""
        port1ints.addChild(Overcurrent)

        AttentionReceived = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Attention Received',
                                                                 'offset': 10,
                                                                 'bit length': 1})

        AttentionReceived.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller received an Attention message."""
        port1ints.addChild(AttentionReceived)

        VDMReceived = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'Vendor-Defined Message Received',
                                                           'offset': 11,
                                                           'bit length': 1})

        VDMReceived.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller receives a Vendor Defined Message from the device it is connected to."""
        port1ints.addChild(VDMReceived)

        NewContractAsCons = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'New Contract as Consumer',
                                                                 'offset': 12,
                                                                 'bit length': 1})

        NewContractAsCons.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller enters a new power contract as a Consumer (Power Sink). This bit is set when an RDO from the far-end device has been accepted and the PD Controller is a Sink. See Active Contract PDO & Active Contract RDO registers for details"""
        port1ints.addChild(NewContractAsCons)

        NewContractAsProv = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'New Contract as Provider',
                                                                 'offset': 13,
                                                                 'bit length': 1})

        NewContractAsProv.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller enters a new power contract as a Provider (Power Source). This bit is set when an RDO from the far-end device has been accepted and the PD Controller is a Source. See Active Contract PDO & Active Contract RDO registers for details"""
        port1ints.addChild(NewContractAsProv)

        SourceCapMsgReady = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Source Capabilities Message Ready',
                                                                 'offset': 14,
                                                                 'bit length': 1})

        SourceCapMsgReady.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller is ready to send its Source Capabilities message has been updated by the far end device."""
        port1ints.addChild(SourceCapMsgReady)

        SinkCapMsgReady = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Sink Capabilities Message Ready',
                                                               'offset': 15,
                                                               'bit length': 1})

        SinkCapMsgReady.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller is ready to send its Sink Capabilities message has been updated by the far end device."""
        port1ints.addChild(SinkCapMsgReady)

        LowVoltageWarning = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Low Voltage Warning',
                                                                 'offset': 16,
                                                                 'bit length': 1})

        LowVoltageWarning.help = """when this bit is enabled, an I2C interrupt event will be set when the voltage level on VBUS is lower than the expected value."""
        port1ints.addChild(LowVoltageWarning)

        PRSwapReq = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'PR Swap Requested',
                                                         'offset': 17,
                                                         'bit length': 1})

        PRSwapReq.help = """when this bit is enabled, an I2C interrupt event will be set when the device attached to the PD controller requests a power role swap."""
        port1ints.addChild(PRSwapReq)

        DRSwapReq = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'DR Swap Requested',
                                                         'offset': 18,
                                                         'bit length': 1})

        DRSwapReq.help = """when this bit is enabled, an I2C interrupt event will be set when the device attached to the PD controller requests a data role swap."""
        port1ints.addChild(DRSwapReq)

        GotoMinReceived = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Goto Min Received',
                                                               'offset': 19,
                                                               'bit length': 1})

        GotoMinReceived.help = """when this bit is enabled, an I2C interrupt event will be set when the PD Controller has received a GotoMin message while in a contract where the GiveBack flag in the RDO was set. The system needs to reduce power consumption down to the level specified in the Auto Negotiate Sink Register (0x37)."""
        port1ints.addChild(GotoMinReceived)

        UsbHostPresent = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'USB Host Present',
                                                              'offset': 20,
                                                              'bit length': 1})

        UsbHostPresent.help = """when this bit is enabled, an I2C interrupt event will be set when there is a USB Host Present on the Type-C port."""
        port1ints.addChild(UsbHostPresent)

        UsbHostPresentNoLonger = register_class.cBooleanDMTerminator(self,
                                                                     {'name': 'USB Host Present no longer',
                                                                      'offset': 21,
                                                                      'bit length': 1})

        UsbHostPresentNoLonger.help = """when this bit is enabled, an I2C interrupt event will be set when a USB Host gets removed from the Type-C port os is no longer available."""
        port1ints.addChild(UsbHostPresentNoLonger)

        HighVoltageWarning = register_class.cBooleanDMTerminator(self,
                                                                 {'name': 'High Voltage Warning',
                                                                  'offset': 22,
                                                                  'bit length': 1})

        HighVoltageWarning.help = """when this bit is enabled, an I2C interrupt event will be set when the voltage on VBUS exceeds the safe threshold."""
        port1ints.addChild(HighVoltageWarning)

        PPswitchChanged = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'PP Switch Changed',
                                                               'offset': 23,
                                                               'bit length': 1})

        PPswitchChanged.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller changes the power path that is currently sourcing or sinking power on VBUS."""
        port1ints.addChild(PPswitchChanged)

        PowerStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Power Status Update',
                                                                 'offset': 24,
                                                                 'bit length': 1})

        PowerStatusUpdate.help = """when this bit is enabled, an I2C interrupt event will be set when the PD Controller updates its power status. This is set when the contents of Register (0x3F) change."""
        port1ints.addChild(PowerStatusUpdate)

        DataStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'Data Status Update',
                                                                'offset': 25,
                                                                'bit length': 1})
        DataStatusUpdate.hide()
        DataStatusUpdate.help = """when this bit is enabled, an I2C interrupt event will be set when the data status is updated on the PD controller. This bit must be set for use with Alpine Ridge thunderbolt controllers. This interrupt is set when the contents of register (0x5F) change."""
        port1ints.addChild(DataStatusUpdate)

        StatusUpdate = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Status Update',
                                                            'offset': 26,
                                                            'bit length': 1})

        StatusUpdate.help = """when this bit is enabled, an I2C interrupt event will be set when the status of the PD controller is updated. This is set when the contents of Register (0x1A) change."""
        port1ints.addChild(StatusUpdate)

        PDStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'PD Status Update',
                                                              'offset': 27,
                                                              'bit length': 1})

        PDStatusUpdate.help = """when this bit is enabled, an I2C interrupt event will be set whenever contents of PD Status register (0x40) change"""
        port1ints.addChild(PDStatusUpdate)

        ADCLowThreshold = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'ADC Low Threshold',
                                                               'offset': 28,
                                                               'bit length': 1})

        ADCLowThreshold.help = """when this bit is enabled, an I2C interrupt event will be set when the ADC Threshold exceeds its lower boundary. (ADC_MON_THR_LO_STAT)"""
        ADCLowThreshold.hide()
        port1ints.addChild(ADCLowThreshold)

        ADCHighThreshold = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'ADC High Threshold',
                                                                'offset': 29,
                                                                'bit length': 1})

        ADCHighThreshold.help = """when this bit is enabled, an I2C interrupt event will be set when the ADC Threshold exceeds its higher boundary. (ADC_MON_THR_HI_STAT)"""
        ADCHighThreshold.hide()
        port1ints.addChild(ADCHighThreshold)

        Cmd1Complete = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'CMD1 Complete',
                                                            'offset': 30,
                                                            'bit length': 1})

        Cmd1Complete.help = """when this bit is enabled, an I2C interrupt event will be set whenever a non-zero value in CMD1 register is set to zero or !CMD."""
        port1ints.addChild(Cmd1Complete)

        Cmd2Complete = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'CMD2 Complete',
                                                            'offset': 31,
                                                            'bit length': 1})

        Cmd2Complete.help = """when this bit is enabled, an I2C interrupt event will be set whenever a non-zero value in CMD2 register is set to zero or !CMD."""
        port1ints.addChild(Cmd2Complete)

        Error_DeviceIncompatible = register_class.cBooleanDMTerminator(self,
                                                                       {'name': 'Error: Device Incompatible',
                                                                        'offset': 32,
                                                                        'bit length': 1})

        Error_DeviceIncompatible.help = """When set to 1, a USB PD device with an incompatible specification version wasconnected. Or the partner device is not USB PD capable."""
        port1ints.addChild(Error_DeviceIncompatible)

        Error_CannotProvideVoltageOrCurrent = register_class.cBooleanDMTerminator(self,
                                                                                  {
                                                                                      'name': 'Error: Cannot Provide Voltage or Current',
                                                                                      'offset': 33,
                                                                                      'bit length': 1})

        Error_CannotProvideVoltageOrCurrent.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller is unable to source the power required for the current PDO."""
        port1ints.addChild(Error_CannotProvideVoltageOrCurrent)

        Error_CanProvideVoltageOrCurrentLater = register_class.cBooleanDMTerminator(self,
                                                                                    {
                                                                                        'name': 'Error: Cannot Provide Voltage or Current Later',
                                                                                        'offset': 34,
                                                                                        'bit length': 1})

        Error_CanProvideVoltageOrCurrentLater.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller is unable to sustain sourcing the power required for the current PDO."""
        port1ints.addChild(Error_CanProvideVoltageOrCurrentLater)

        Error_PowerEventOccurred = register_class.cBooleanDMTerminator(self,
                                                                       {'name': 'Error: Power Event Occurred',
                                                                        'offset': 35,
                                                                        'bit length': 1})

        Error_PowerEventOccurred.help = """when this bit is enabled, an I2C interrupt event will be set when an OVP (Over-Voltage Protection) or short circuit event occured on VBUS"""
        port1ints.addChild(Error_PowerEventOccurred)

        Error_MissingGetCapMessage = register_class.cBooleanDMTerminator(self,
                                                                         {
                                                                             'name': 'Error: Missing Get Capabilities Message',
                                                                             'offset': 36,
                                                                             'bit length': 1})

        Error_MissingGetCapMessage.help = """when this bit is enabled, an I2C interrupt event will be set when he partner device did not respond to the Get_Sink_Cap or Get_Source_Cap message that was sent."""
        port1ints.addChild(Error_MissingGetCapMessage)

        Error_ProtError = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Error: Protocol Error',
                                                               'offset': 38,
                                                               'bit length': 1})

        Error_ProtError.help = """when this bit is enabled, an I2C interrupt event will be set when an unexpected message was received from the partner device."""

        port1ints.addChild(Error_ProtError)

        Error_MessageData = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Error: Message Data',
                                                                 'offset': 39,
                                                                 'bit length': 1})

        Error_MessageData.help = """when this bit is enabled, an I2C interrupt event will be set when a message was received and the CRC failed or the data length in the header (“Number of Data Objects”) did not match the actual amount of data received or its signal level caused the message to be deemed invalid."""
        port1ints.addChild(Error_MessageData)

        Error_DischargeFailed = register_class.cBooleanDMTerminator(self,
                                                                    {'name': 'Error: Discharge Failed',
                                                                     'offset': 41,
                                                                     'bit length': 1})

        Error_DischargeFailed.help = """when this bit is enabled, an I2C interrupt event will be set when the PD Controller fails to discharge VBUS"""
        port1ints.addChild(Error_DischargeFailed)

        SnkTransitionComplete = register_class.cBooleanDMTerminator(self,
                                                                    {'name': 'Sink Transition Complete',
                                                                     'offset': 42,
                                                                     'bit length': 1})

        SnkTransitionComplete.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully transitioned into a power sink."""
        port1ints.addChild(SnkTransitionComplete)

        iclProchot = register_class.cBooleanDMTerminator(self,
                                                         {'name': 'Ice Lake Proc Hot Notification',
                                                          'offset': 44,
                                                          'bit length': 1})
        port1ints.addChild(iclProchot)

        Error_UnableToSource = register_class.cBooleanDMTerminator(self,
                                                                   {'name': 'Error: Unable to Source',
                                                                    'offset': 46,
                                                                    'bit length': 1})

        Error_UnableToSource.help = """when this bit is enabled, an I2C interrupt event will be set when the source device is unable to increase the voltage to the negotiated voltage of the PD contract."""
        port1ints.addChild(Error_UnableToSource)

        Error_BISTIg = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Error: BIST Message Ignored',
                                                            'offset': 47,
                                                            'bit length': 1})

        Error_BISTIg.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller sends a Built-In Self Test message that is ignored by the far end device."""
        port1ints.addChild(Error_BISTIg)

        AMEntryFail = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'AM Entry Failure',
                                                           'offset': 48,
                                                           'bit length': 1})

        AMEntryFail.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller fails to enter an Alternate Mode."""
        port1ints.addChild(AMEntryFail)

        AMEntered = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'AM Entered',
                                                         'offset': 49,
                                                         'bit length': 1})

        AMEntered.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully entered an Alternate Mode."""
        port1ints.addChild(AMEntered)

        VDMMsgSent = register_class.cBooleanDMTerminator(self,
                                                         {'name': 'Vendor Defined Message Sent',
                                                          'offset': 50,
                                                          'bit length': 1})

        VDMMsgSent.help = """Set when a VDM has been sent."""
        port1ints.addChild(VDMMsgSent)

        discModeComp = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Discover Mode Complete',
                                                            'offset': 51,
                                                            'bit length': 1})

        discModeComp.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully Discovered the available modes of the far end device."""
        port1ints.addChild(discModeComp)

        exitModeComp = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Exit Mode Complete',
                                                            'offset': 52,
                                                            'bit length': 1})

        exitModeComp.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully exited an Alternate Mode."""
        port1ints.addChild(exitModeComp)

        UserSvidModeEntered = register_class.cBooleanDMTerminator(self,
                                                                  {'name': 'User SVID Mode Entered',
                                                                   'offset': 56,
                                                                   'bit length': 1})

        UserSvidModeEntered.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has succesfully entered a users SVID mode."""
        port1ints.addChild(UserSvidModeEntered)

        UserSvidModeExited = register_class.cBooleanDMTerminator(self,
                                                                 {'name': 'User SVID Mode Exited',
                                                                  'offset': 57,
                                                                  'bit length': 1})

        UserSvidModeExited.help = """when this bit is enabled, an I2C interrupt event will be set when the PD controller has exited a users SVID mode."""
        port1ints.addChild(UserSvidModeExited)

        UserSvidAttentionVDMReceived = register_class.cBooleanDMTerminator(self,
                                                                           {'name': 'User SVID Attention VDM Received',
                                                                            'offset': 58,
                                                                            'bit length': 1})

        UserSvidAttentionVDMReceived.help = """when this bit is enabled, an I2C interrupt event will be set when a users SVID structured attention vendor defined message is received."""
        port1ints.addChild(UserSvidAttentionVDMReceived)

        UserSvidOtherVDMReceived = register_class.cBooleanDMTerminator(self,
                                                                       {'name': 'User SVID Other VDM Received',
                                                                        'offset': 59,
                                                                        'bit length': 1})

        UserSvidOtherVDMReceived.help = """when this bit is enabled, an I2C interrupt event will be set when a users SVID structured non-Attention VDM or unstructured VDM has been received."""
        port1ints.addChild(UserSvidOtherVDMReceived)

        DPSIDStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'DP SID Status Update',
                                                                 'offset': 62,
                                                                 'bit length': 1})

        DPSIDStatusUpdate.help = """Set when the contents of the DP SID Status register (0x58) change."""
        port1ints.addChild(DPSIDStatusUpdate)

        IntelVIDStatusUpdate = register_class.cBooleanDMTerminator(self,
                                                                   {'name': 'Intel VID Status Update',
                                                                    'offset': 63,
                                                                    'bit length': 1})
        IntelVIDStatusUpdate.hide()
        IntelVIDStatusUpdate.help = """Set when the contents of the Intel VID Status register (0x59) change."""
        port1ints.addChild(IntelVIDStatusUpdate)

        PD3StatusUpdate = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'PD3 Status Update',
                                                               'offset': 64,
                                                               'bit length': 1})

        PD3StatusUpdate.help = """Set when the contents of the PD3.0 Status register (0x41) change."""
        port1ints.addChild(PD3StatusUpdate)

        TXMemBufferEmpty = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'TX Mem Buffer Empty',
                                                                'offset': 65,
                                                                'bit length': 1})

        TXMemBufferEmpty.help = """Transmit memory buffer empty."""
        port1ints.addChild(TXMemBufferEmpty)

        RXMemBufferFull = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'RX Mem Buffer Full',
                                                               'offset': 66,
                                                               'bit length': 1})

        RXMemBufferFull.help = """Transmit memory buffer empty."""
        port1ints.addChild(RXMemBufferFull)

        CustomDVDMArrive = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'Custom VDM Arrive',
                                                                'offset': 67,
                                                                'bit length': 1})

        CustomDVDMArrive.help = """A custom VDM has arrived"""
        port1ints.addChild(CustomDVDMArrive)

        CustomDAMEntered = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'Custom AM Entered',
                                                                'offset': 68,
                                                                'bit length': 1})

        CustomDAMEntered.help = """A custom Alternate Mode has been entered."""
        port1ints.addChild(CustomDAMEntered)

        CustomDVDMMSGSENT = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Custom VDM Message Sent',
                                                                 'offset': 69,
                                                                 'bit length': 1})

        CustomDVDMMSGSENT.help = """A custom VDM has been sent."""
        port1ints.addChild(CustomDVDMMSGSENT)

        ackTime = register_class.cBooleanDMTerminator(self,
                                                      {'name': 'SOC ACK Timeout',
                                                       'offset': 70,
                                                       'bit length': 1})

        ackTime.help = """ACK Timeout Occurred."""
        port0ints.addChild(ackTime)

        FRSSignalReceived = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'FRS Signal Received',
                                                                 'offset': 76,
                                                                 'bit length': 1})

        FRSSignalReceived.help = """An FRS Message has been received."""
        port1ints.addChild(FRSSignalReceived)

        ChunkResponseReceived = register_class.cBooleanDMTerminator(self,
                                                                    {'name': 'Chunk Response Received',
                                                                     'offset': 77,
                                                                     'bit length': 1})

        ChunkResponseReceived.help = """Chunk Response message received."""
        port1ints.addChild(ChunkResponseReceived)

        ChunkRequestReceived = register_class.cBooleanDMTerminator(self,
                                                                   {'name': 'Chunk Request Received',
                                                                    'offset': 78,
                                                                    'bit length': 1})

        ChunkRequestReceived.help = """Chunk Request message received."""
        port1ints.addChild(ChunkRequestReceived)

        AlertMessageReceived = register_class.cBooleanDMTerminator(self,
                                                                   {'name': 'Alert Message Received',
                                                                    'offset': 79,
                                                                    'bit length': 1})

        AlertMessageReceived.help = """An Alert Messae has been received."""
        port1ints.addChild(AlertMessageReceived)

        commonInts = register_class.cDataModelArray(self, 1,
                                                    {'name': 'Common Interrupt Mask for I2C1',
                                                     'offset': 80,
                                                     'bit length': 8})

        self.dataModel.addChild(commonInts)

        patchLoaded = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'Patch Loaded',
                                                           'offset': 0,
                                                           'bit length': 1})

        patchLoaded.help = """when this bit is enabled, an I2C interrupt event will be set when a patch has been loaded onto the device."""
        commonInts.addChild(patchLoaded)

        readyPatch = register_class.cBooleanDMTerminator(self,
                                                         {'name': 'Ready for Patch',
                                                          'offset': 1,
                                                          'bit length': 1})

        readyPatch.help = """when this bit is enabled, an I2C interrupt event will be set when the device is ready to receive a patch."""
        commonInts.addChild(readyPatch)


########################################################################################################################
########################################################################################################################
########################################################################################################################


class cSystemPowerState_0x20_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'System Power State',
                                                 'address': 0x20,
                                                 'byte length': 1,
                                                 'permission': 'RW'})

        self.setAsShared()

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'System Power State',
                                                         'offset': 0,
                                                         'bit length': 8})

        sysPowState = register_class.cDataModelTerminator(self,
                                                          {'name': 'System Power State',
                                                           'offset': 0,
                                                           'bit length': 8})

        self.dataModel.addChild(sysPowState)


########################################################################################################################
########################################################################################################################
########################################################################################################################


class cWakeMask_0x22_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Wake Mask',
                                                 'address': 0x22,
                                                 'byte length': 8,
                                                 'permission': 'DRW'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'Wake Mask',
                                                         'offset': 0,
                                                         'bit length': 64})

        plug1 = register_class.cHexDMTerminator(self,
                                                {'name': 'Plug1',
                                                 'offset': 0,
                                                 'bit length': 1})
        plug1.help = """USB-C plug detection Port 1"""
        self.dataModel.addChild(plug1)

        unplug1 = register_class.cHexDMTerminator(self,
                                                  {'name': 'Unplug1',
                                                   'offset': 1,
                                                   'bit length': 1})
        unplug1.help = """USB-C unplug detection Port 1"""
        self.dataModel.addChild(unplug1)

        pdactivity1 = register_class.cHexDMTerminator(self,
                                                      {'name': 'PDactivity1',
                                                       'offset': 2,
                                                       'bit length': 1})
        pdactivity1.help = """PD activity detection Port 1"""
        self.dataModel.addChild(pdactivity1)

        hpd1Low = register_class.cHexDMTerminator(self,
                                                  {'name': 'HPD1low',
                                                   'offset': 3,
                                                   'bit length': 1})
        hpd1Low.help = """HPD Low received (GPIO if HPD RX, or PD message if HPD TX) Port 1"""
        self.dataModel.addChild(hpd1Low)

        hpd1High = register_class.cHexDMTerminator(self,
                                                   {'name': 'HPD1high',
                                                    'offset': 4,
                                                    'bit length': 1})
        hpd1High.help = """HPD High received (GPIO if HPD RX, or PD message if HPD TX) Port 1"""
        self.dataModel.addChild(hpd1High)

        irqHPD1 = register_class.cHexDMTerminator(self,
                                                  {'name': 'IRQ_HPD1',
                                                   'offset': 5,
                                                   'bit length': 1})
        irqHPD1.help = """IRQ_HPD received (GPIO if HPD RX, or PD message if HPD TX) Port 1"""
        self.dataModel.addChild(irqHPD1)

        plug2 = register_class.cHexDMTerminator(self,
                                                {'name': 'Plug2',
                                                 'offset': 16,
                                                 'bit length': 1})
        plug2.help = """USB-C plug detection Port 1"""
        self.dataModel.addChild(plug2)

        unplug2 = register_class.cHexDMTerminator(self,
                                                  {'name': 'Unplug2',
                                                   'offset': 17,
                                                   'bit length': 1})
        unplug2.help = """USB-C unplug detection Port 2"""
        self.dataModel.addChild(unplug2)

        pdactivity2 = register_class.cHexDMTerminator(self,
                                                      {'name': 'PDactivity2',
                                                       'offset': 18,
                                                       'bit length': 1})
        pdactivity2.help = """PD activity detection Port 2"""
        self.dataModel.addChild(pdactivity2)

        hpd2Low = register_class.cHexDMTerminator(self,
                                                  {'name': 'HPD2low',
                                                   'offset': 19,
                                                   'bit length': 1})
        hpd2Low.help = """HPD Low received (GPIO if HPD RX, or PD message if HPD TX) Port 2"""
        self.dataModel.addChild(hpd2Low)

        hpd2High = register_class.cHexDMTerminator(self,
                                                   {'name': 'HPD2high',
                                                    'offset': 20,
                                                    'bit length': 1})
        hpd2High.help = """HPD High received (GPIO if HPD RX, or PD message if HPD TX) Port 2"""
        self.dataModel.addChild(hpd2High)

        irqHPD2 = register_class.cHexDMTerminator(self,
                                                  {'name': 'IRQ_HPD2',
                                                   'offset': 21,
                                                   'bit length': 1})
        irqHPD2.help = """IRQ_HPD received (GPIO if HPD RX, or PD message if HPD TX) Port 2"""
        self.dataModel.addChild(irqHPD2)

        for i in range(22):
            GPIO = register_class.cHexDMTerminator(self,
                                                   {'name': 'GPIO%d' % (i),
                                                    'offset': i + 32,
                                                    'bit length': 1})
            GPIO.help = """Edge Detected on GPIO%d""" % (i)
            self.dataModel.addChild(GPIO)


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cPowerPathStatus_0x26_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Power Path Status',
                                                 'address': 0x26,
                                                 'byte length': 6,
                                                 'permission': 'DRO'})

        self.setAsShared()

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'Power Path Status',
                                                         'offset': 0,
                                                         'bit length': 48})
        for i in range(2):
            PPCableSwitch = register_class.cListDMTerminator(self,
                                                             {'name': 'PP%d_Cableswitch' % (i + 1),
                                                              'offset': 0 + i * 2,
                                                              'bit length': 2})
            PPCableSwitch.setReportList(['PP%d_CABLE switch disabled.' % (i + 1), \
                                         'PP%d_CABLE switch currently disabled due to fault.' % (i + 1), \
                                         'PP%d_CABLE switch CC1 enabled (system output).' % (i + 1), \
                                         'PP%d_CABLE switch CC2 enabled (system output).' % (i + 1)])
            PPCableSwitch.help = """Indicates current state of PP%d_CABLE switch.""" % (i + 1)
            self.dataModel.addChild(PPCableSwitch)

        for i in range(4):
            PPSwitch = register_class.cListDMTerminator(self,
                                                        {'name': 'PP%dswitch' % (i + 1),
                                                         'offset': 6 + i * 3,
                                                         'bit length': 3})
            PPSwitch.setReportList(['PP%d switch disabled.' % (i + 1), \
                                    'PP%d switch currently disabled due to fault.' % (i + 1), \
                                    'PP%d switch enabled (system output).' % (i + 1), \
                                    'PP%d switch enabled (system input).' % (i + 1)])
            PPSwitch.help = """Indicates current state of PP%d switch.""" % (i + 1)
            self.dataModel.addChild(PPSwitch)

        for i in range(2):
            PPCableEn = register_class.cListDMTerminator(self,
                                                         {'name': 'PP%d_CABLE Enable' % (i + 1),
                                                          'offset': 24 + i * 1,
                                                          'bit length': 1})
            PPCableEn.setReportList(['PP%d_CABLE power not enabled' % (i + 1), \
                                     'PP%d_CABLE power enabled' % (i + 1)])
            PPCableEn.help = """Indicates current state of PP%d_CABLE power.""" % (i + 1)
            self.dataModel.addChild(PPCableEn)

        for i in range(2):
            PPOC = register_class.cListDMTerminator(self,
                                                    {'name': 'PP%d Overcurrent' % (i + 1),
                                                     'offset': 28 + i * 1,
                                                     'bit length': 1})
            PPOC.setReportList(['No overcurrent condition exists on PP%d switch' % (i + 1), \
                                'PP%d switch is in overcurrent condition.' % (i + 1)])
            PPOC.help = """Indicates current state of PP%d switch.""" % (i + 1)
            self.dataModel.addChild(PPOC)

        for i in range(2):
            PPCableOC = register_class.cListDMTerminator(self,
                                                         {'name': 'PP%d_CABLE Overcurrent' % (i + 1),
                                                          'offset': 34 + i * 1,
                                                          'bit length': 1})
            PPCableOC.setReportList(['No overcurrent condition exists on PP%d_CABLE switch' % (i + 1), \
                                     'PP%d_CABLE a switch is in overcurrent condition.' % (i + 1)])
            PPCableOC.help = """Indicates current state of PP%d Cable switch.""" % (i + 1)
            self.dataModel.addChild(PPCableOC)

        powerSource = register_class.cListDMTerminator(self,
                                                       {'name': 'PowerSource',
                                                        'offset': 38,
                                                        'bit length': 2})
        powerSource.setReportList(['Reserved', 'PD Controller is powered from VIN_3P3.', \
                                   'Dead Battery flag is set (PD Controller is powered from VBUS).', \
                                   'PD Controller is powered from VBUS and Dead Battery flag is not set.'])
        powerSource.help = """Indicates current PD Controller power source. \
                              \n\nNOTE: Since the Dead Battery flag forces PD Controller to be powered from VBUS, only 10b is valid when this flag is set. Any other setting indicates that the Dead Battery flag is not set."""
        self.dataModel.addChild(powerSource)

        for i in range(2):
            PPRCP = register_class.cHexDMTerminator(self,
                                                    {'name': 'PP%d_RCP' % (i + 1),
                                                     'offset': 40 + i * 1,
                                                     'bit length': 1})
            PPRCP.help = """Indicates if reverse current protection is detected on PP%d switch.""" % (i + 1)
            self.dataModel.addChild(PPRCP)


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cGlobalSysConfig_0x27_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Global System Configuration',
                                                 'address': 0x27,
                                                 'byte length': 14,
                                                 'permission': 'RW'})

        self.setAsShared()

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'Global System Configuration',
                                                         'offset': 0,
                                                         'bit length': 112})

        ppCableList = ['PP Cable Switch Not Used', 'PP Cable Switch as Output, Guaranteed 4.5-5.5V',
                       'PP Cable Switch as Output, 2.7-5.5V']

        pp1Cable = register_class.cListDMTerminator(self,
                                                    {'name': 'PP Cable 1 Switch Config',
                                                     'offset': 0,
                                                     'bit length': 2})
        pp1Cable.help = """Provides VCONN power for E-Marked cables on Port A. For most systems, PP Cable is tied to 5V using the 4.5-5.5V setting. 2.7-5.5V is only used for operating in PoweredAccessory state."""
        pp1Cable.setMaxValue(2)
        pp1Cable.setReportList(ppCableList)
        self.dataModel.addChild(pp1Cable)

        pp2Cable = register_class.cListDMTerminator(self,
                                                    {'name': 'PP Cable 2 Switch Config',
                                                     'offset': 2,
                                                     'bit length': 2})
        pp2Cable.setMaxValue(2)
        pp2Cable.setReportList(ppCableList)
        pp2Cable.help = """Provides VCONN power for E-Marked cables on Port A. For most systems, PP Cable is tied to 5V using the 4.5-5.5V setting. 2.7-5.5V is only used for operating in PoweredAccessory state."""

        pp2CableFS = register_class.cForceSetDMTerminator(self,
                                                          {'name': 'PP Cable 2 Switch Config',
                                                           'offset': 2,
                                                           'bit length': 2,
                                                           'force value': int(0),
                                                           'force display': 'PP Cable Switch Not Used',
                                                           'display widget': pp2Cable})

        pp2CableFS.hide()
        pp2CableFS.help = """Provides VCONN power for E-Marked cables on Port A. For most systems, PP Cable is tied to 5V using the 4.5-5.5V setting. 2.7-5.5V is only used for operating in PoweredAccessory state."""
        self.dataModel.addChild(pp2CableFS)

        ppSwitchList = ['PP Switch Disabled', 'PP Switch as Source Only (Output)', 'PP Switch as Sink Only (Input)',
                        'PP Switch as Sink Only, wait for SRDY', 'PP Switch as Sink or Source',
                        'PP Switch as Sink or Source, wait for SRDY']

        ppSwitch1 = register_class.cListDMTerminator(self,
                                                     {'name': 'PP 1 Switch Config',
                                                      'offset': 16,
                                                      'bit length': 3})

        ppSwitch1.help = """This setting allows the user to decide if they want to use power path 1 to source power, sink power, sink power after SRDY, or to disable this power path. """
        ppSwitch1.setMaxValue(5)
        ppSwitch1.setReportList(ppSwitchList)
        self.dataModel.addChild(ppSwitch1)

        ppSwitch2 = register_class.cListDMTerminator(self,
                                                     {'name': 'PP 2 Switch Config',
                                                      'offset': 19,
                                                      'bit length': 3})

        ppSwitch2.help = """This setting allows the user to decide if they want to use power path 2 to source power, sink power, sink power after SRDY, or to disable this power path. """
        ppSwitch2.setMaxValue(5)
        ppSwitch2.setReportList(ppSwitchList)
        self.dataModel.addChild(ppSwitch2)

        ppSwitch3 = register_class.cListDMTerminator(self,
                                                     {'name': 'PP 3 Switch Config',
                                                      'offset': 32,
                                                      'bit length': 3})

        ppSwitch3.help = """This setting allows the user to decide if they want to use power path 3 to source power, sink power, sink power after SRDY, or to disable this power path. """
        ppSwitch3.setMaxValue(5)
        ppSwitch3.setReportList(ppSwitchList)
        self.dataModel.addChild(ppSwitch3)

        ppSwitch4 = register_class.cListDMTerminator(self,
                                                     {'name': 'PP 4 Switch Config',
                                                      'offset': 35,
                                                      'bit length': 3})

        ppSwitch4.help = """This setting allows the user to decide if they want to use power path 4 to source power, sink power, sink power after SRDY, or to disable this power path. """
        ppSwitch4.setMaxValue(5)
        ppSwitch4.setReportList(ppSwitchList)
        self.dataModel.addChild(ppSwitch4)

        POWERDUO87 = register_class.cBooleanDMTerminator(self,
                                                         {'name': 'Power Duo Mode',
                                                          'offset': 52,
                                                          'bit length': 1})

        POWERDUO87.help = """When set, this bit causes a TPS65987D to close both of its internal power paths in parallel to act as either a source or sink depending on the PP1 Switch Config and PP2 Switch Config settings. The PP1 and PP2 Switch configs must match."""
        self.dataModel.addChild(POWERDUO87)

        emu87 = register_class.cBooleanDMTerminator(self,
                                                    {'name': '87 Emulation Mode',
                                                     'offset': 55,
                                                     'bit length': 1})

        emu87.hide()
        emu87.help = """When set, this bit causes a TPS65988 device to operate as a TPS65987. This requires shorting of VBUS1 to VBUS2. The bit is ignored for TPS65987 devices.  This bit is latched and has no effect if changed at runtime."""
        self.dataModel.addChild(emu87)

        vbusMapList = ['VBUS 1', 'VBUS 2']

        pp1ToVBUSMap = register_class.cListDMTerminator(self,
                                                        {'name': 'PP1 Switch to VBUS Map',
                                                         'offset': 56,
                                                         'bit length': 1})

        pp1ToVBUSMap.setReportList(vbusMapList)
        pp1ToVBUSMap.help = """Select which Type-C port Power Path 1 will be routed to."""

        pp1ToVBUSMapFS = register_class.cForceSetDMTerminator(self,
                                                              {'name': 'PP1 Switch to VBUS Map',
                                                               'offset': 56,
                                                               'bit length': 1,
                                                               'force value': int(0),
                                                               'force display': 'VBUS 1',
                                                               'display widget': pp1ToVBUSMap})

        pp1ToVBUSMapFS.hide()
        pp1ToVBUSMapFS.help = """Select which Type-C port Power Path 1 will be routed to."""
        self.dataModel.addChild(pp1ToVBUSMapFS)

        pp2ToVBUSMap = register_class.cListDMTerminator(self,
                                                        {'name': 'PP2 Switch to VBUS Map',
                                                         'offset': 57,
                                                         'bit length': 1})

        pp2ToVBUSMap.setReportList(vbusMapList)
        pp2ToVBUSMap.help = """Select which Type-C port Power Path 2 will be routed to."""

        pp2ToVBUSMapFS = register_class.cForceSetDMTerminator(self,
                                                              {'name': 'PP2 Switch to VBUS Map',
                                                               'offset': 57,
                                                               'bit length': 1,
                                                               'force value': int(0),
                                                               'force display': 'VBUS 1',
                                                               'display widget': pp2ToVBUSMap})

        pp2ToVBUSMapFS.hide()
        pp2ToVBUSMapFS.help = """Select which Type-C port Power Path 2 will be routed to."""
        self.dataModel.addChild(pp2ToVBUSMapFS)

        pp3ToVBUSMap = register_class.cListDMTerminator(self,
                                                        {'name': 'PP3 Switch to VBUS Map',
                                                         'offset': 58,
                                                         'bit length': 1})

        pp3ToVBUSMap.setReportList(vbusMapList)
        pp3ToVBUSMap.help = """Select which Type-C port Power Path 3 will be routed to."""

        pp3ToVBUSMapFS = register_class.cForceSetDMTerminator(self,
                                                              {'name': 'PP3 Switch to VBUS Map',
                                                               'offset': 58,
                                                               'bit length': 1,
                                                               'force value': int(0),
                                                               'force display': 'VBUS 1',
                                                               'display widget': pp3ToVBUSMap})

        pp3ToVBUSMapFS.hide()
        pp3ToVBUSMapFS.help = """Select which Type-C port Power Path 3 will be routed to."""
        self.dataModel.addChild(pp3ToVBUSMapFS)

        pp4ToVBUSMap = register_class.cListDMTerminator(self,
                                                        {'name': 'PP4 Switch to VBUS Map',
                                                         'offset': 59,
                                                         'bit length': 1})

        pp4ToVBUSMap.setReportList(vbusMapList)
        pp4ToVBUSMap.help = """Select which Type-C port Power Path 4 will be routed to."""

        pp4ToVBUSMapFS = register_class.cForceSetDMTerminator(self,
                                                              {'name': 'PP4 Switch to VBUS Map',
                                                               'offset': 59,
                                                               'bit length': 1,
                                                               'force value': int(0),
                                                               'force display': 'VBUS 1',
                                                               'display widget': pp4ToVBUSMap})

        pp4ToVBUSMapFS.hide()
        pp4ToVBUSMapFS.help = """Select which Type-C port Power Path 4 will be routed to."""
        self.dataModel.addChild(pp4ToVBUSMapFS)

        reserved = register_class.cForceSetDMTerminator(self,
                                                        {'name': 'Reserved',
                                                         'offset': 60,
                                                         'bit length': 4,
                                                         'force value': int(0),
                                                         'force display': 'Reserved, set 0'})
        reserved.hide()
        self.dataModel.addChild(reserved)

        PP1OCTFV = register_class.cForceSetDMTerminator(self,
                                                        {'name': 'PP Switch 1 Overcurrent Timeout',
                                                         'offset': 64,
                                                         'bit length': 4,
                                                         'force value': int(4),
                                                         'force display': '640 uS'})

        PP1OCTFV.hide()
        PP1OCTFV.help = """Amount of time it will take to disconnect VBUS from Power Path 1 once an Overcurrent event has occured."""
        self.dataModel.addChild(PP1OCTFV)

        PPSwitch1TimeOutEnableFV = register_class.cForceSetDMTerminator(self,
                                                                        {
                                                                            'name': 'PP Switch 1 Overcurrent Timeout Enable',
                                                                            'offset': 68,
                                                                            'bit length': 1,
                                                                            'force value': int(1),
                                                                            'force display': 'Enabled'})

        PPSwitch1TimeOutEnableFV.hide()
        PPSwitch1TimeOutEnableFV.help = """Enables user to add a delay between an Overcurrent event on Port A and disconnecting VBUS. With this bit disabled, VBUS will immediately disconnect once an Overcurrent event occurs."""
        self.dataModel.addChild(PPSwitch1TimeOutEnableFV)

        PP2OCTFV = register_class.cForceSetDMTerminator(self,
                                                        {'name': 'PP Switch 2 Overcurrent Timeout',
                                                         'offset': 72,
                                                         'bit length': 4,
                                                         'force value': int(4),
                                                         'force display': '640 uS'})

        PP2OCTFV.hide()
        PP2OCTFV.help = """Amount of time it will take to disconnect VBUS from Power Path 2 once an Overcurrent event has occured."""
        self.dataModel.addChild(PP2OCTFV)

        PPSwitch2TimeOutEnableFV = register_class.cForceSetDMTerminator(self,
                                                                        {
                                                                            'name': 'PP Switch 2 Overcurrent Timeout Enable',
                                                                            'offset': 76,
                                                                            'bit length': 1,
                                                                            'force value': int(1),
                                                                            'force display': 'Enabled'})

        PPSwitch2TimeOutEnableFV.hide()
        PPSwitch2TimeOutEnableFV.help = """Enables user to add a delay between an Overcurrent event on Port B and disconnecting VBUS. With this bit disabled, VBUS will immediately disconnect once an Overcurrent event occurs."""
        self.dataModel.addChild(PPSwitch2TimeOutEnableFV)

        i2cMaster = register_class.cListDMTerminator(self,
                                                     {'name': 'I2C Master',
                                                      'offset': 81,
                                                      'bit length': 2})
        i2cMaster.setMaxValue(1)
        i2cMaster.setReportList(['Disabled', 'I2C1 as Master'])

        i2cMasterFS = register_class.cForceSetDMTerminator(self,
                                                           {'name': 'I2C Master',
                                                            'offset': 81,
                                                            'bit length': 2,
                                                            'force value': int(0),
                                                            'force display': 'Disabled',
                                                            'display widget': i2cMaster})

        i2cMasterFS.hide()
        self.dataModel.addChild(i2cMasterFS)

        sinkPolList = ['Both sink paths will close switch', 'Only highest power sink path closes switch']

        sinkPol = register_class.cListDMTerminator(self,
                                                   {'name': 'Multiport Sink Policy',
                                                    'offset': 96,
                                                    'bit length': 2})
        sinkPol.setMaxValue(1)
        sinkPol.setReportList(sinkPolList)

        sinkPolFS = register_class.cForceSetDMTerminator(self,
                                                         {'name': 'Multiport Sink Policy',
                                                          'offset': 96,
                                                          'bit length': 2,
                                                          'force value': int(0),
                                                          'force display': 'Both sink paths will close switch',
                                                          'display widget': sinkPol})

        sinkPolFS.hide()
        self.dataModel.addChild(sinkPolFS)

        spNOList = ['1 mSec', '5 mSec', '10 mSec', '15 mSec']

        spNonOver = register_class.cListDMTerminator(self,
                                                     {'name': 'Sink Policy Non-overlap Time',
                                                      'offset': 105,
                                                      'bit length': 2})
        spNonOver.setReportList(spNOList)

        spNonOverFS = register_class.cForceSetDMTerminator(self,
                                                           {'name': 'Sink Policy Non-overlap Time',
                                                            'offset': 105,
                                                            'bit length': 2,
                                                            'force value': int(0),
                                                            'force display': '1 mSec',
                                                            'display widget': spNonOver})

        spNonOverFS.hide()
        self.dataModel.addChild(spNonOverFS)

        amPolList = ['Both ports can enter the same alternate mode', 'Only one port can enter a given alternate mode']

        amPol = register_class.cListDMTerminator(self,
                                                 {'name': 'Multiport Alternate Mode Policy',
                                                  'offset': 98,
                                                  'bit length': 2})
        amPol.setMaxValue(1)
        amPol.setReportList(amPolList)
        amPol.help = """Controls Alternate Mode behavior for two port operation """

        amPolFS = register_class.cForceSetDMTerminator(self,
                                                       {'name': 'Multiport Alternate Mode Policy',
                                                        'offset': 98,
                                                        'bit length': 2,
                                                        'force value': int(0),
                                                        'force display': 'Both ports can enter the same alternate mode',
                                                        'display widget': amPol})

        amPolFS.hide()
        self.dataModel.addChild(amPolFS)

        extProcList = ['Default', 'Alpine Ridge', 'Titan Ridge', 'Ice Lake']

        extProc = register_class.cListDMTerminator(self,
                                                   {'name': 'External Processor',
                                                    'offset': 100,
                                                    'bit length': 2})
        extProc.setReportList(extProcList)
        extProc.help = """Used to select which external processor the device will interface to"""
        self.dataModel.addChild(extProc)

        iloUfpenable = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Ice Lake Enable One UFP Policy',
                                                            'offset': 102,
                                                            'bit length': 1})

        iclOneUFP = register_class.cForceSetDMTerminator(self,
                                                         {'name': 'Ice Lake Enable One UFP Policy',
                                                          'offset': 102,
                                                          'bit length': 1,
                                                          'force value': int(0),
                                                          'force display': 'Disable One UFP Policy',
                                                          'display widget': iloUfpenable})

        iclOneUFP.hide()
        self.dataModel.addChild(iclOneUFP)

        ilSpmenable = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'Ice Lake Enable Simple Source Policy Manager',
                                                           'offset': 103,
                                                           'bit length': 1})

        iclSpm = register_class.cForceSetDMTerminator(self,
                                                      {'name': 'Ice Lake Enable Simple Source Policy Manager',
                                                       'offset': 103,
                                                       'bit length': 1,
                                                       'force value': int(0),
                                                       'force display': 'Disable Simple Source Policy Manager',
                                                       'display widget': ilSpmenable})

        iclSpm.hide()
        self.dataModel.addChild(iclSpm)

        tbtPortList = ['I2C2', 'I2C1']

        tbtPort = register_class.cListDMTerminator(self,
                                                   {'name': 'TBT Controller I2C Port',
                                                    'offset': 107,
                                                    'bit length': 1})
        tbtPort.setReportList(tbtPortList)

        self.dataModel.addChild(tbtPort)

        i2cTimeoutList = ['25 mS', '50 mS (default)', '75 mS', '100 mS', '125 mS', '150 mS', '175 mS', '1 S']
        i2cTimeout = register_class.cListDMTerminator(self,
                                                      {'name': 'I2C Timeout',
                                                       'offset': 108,
                                                       'bit length': 3})
        i2cTimeout.setReportList(i2cTimeoutList)
        i2cTimeout.help = """If an I2C write/read is initiated, this timeout begins. If the read or write is not completed by the end of the timeout, the I2C read/write is reset."""

        i2cTimeoutFV = register_class.cForceSetDMTerminator(self,
                                                            {'name': 'I2C Timeout',
                                                             'offset': 108,
                                                             'bit length': 3,
                                                             'force value': int(7),
                                                             'force display': '1 S',
                                                             'display widget': i2cTimeout})

        i2cTimeoutFV.hide()
        i2cTimeoutFV.help = """If an I2C write/read is initiated, this timeout begins. If the read or write is not completed by the end of the timeout, the I2C read/write is reset."""
        self.dataModel.addChild(i2cTimeoutFV)

        SPIReadOnly = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'SPI Read Only',
                                                           'offset': 111,
                                                           'bit length': 1})
        SPIReadOnly.help = """This disables SPI flash updating over the host interface."""

        SPIReadOnlyFV = register_class.cForceSetDMTerminator(self,
                                                             {'name': 'SPI Read Only',
                                                              'offset': 111,
                                                              'bit length': 1,
                                                              'force value': int(0),
                                                              'force display': 'Read and Write SPI Flash',
                                                              'display widget': SPIReadOnly})

        SPIReadOnlyFV.hide()
        SPIReadOnlyFV.help = """This disables SPI flash updating over the host interface."""
        self.dataModel.addChild(SPIReadOnlyFV)


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cPortConfig_0x28_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Port Configuration',
                                                 'address': 0x28,
                                                 'byte length': 5,
                                                 'permission': 'RW'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'Port Configuration',
                                                         'offset': 0,
                                                         'bit length': 40})

        portTypeList = ['UFP', 'DFP', 'DRP', 'Disabled']

        portType = register_class.cListDMTerminator(self,
                                                    {'name': 'Port Configuration',
                                                     'offset': 0,
                                                     'bit length': 2})

        portType.help = """Sets the Type-C to be a DRP,DFP, or UFP."""
        portType.setReportList(portTypeList)
        self.dataModel.addChild(portType)

        reserved = register_class.cForceSetDMTerminator(self,
                                                        {'name': 'Reserved',
                                                         'offset': 2,
                                                         'bit length': 1,
                                                         'force value': int(0),
                                                         'force display': 'Reserved, set 0'})
        reserved.hide()
        self.dataModel.addChild(reserved)

        ReceptType = register_class.cListDMTerminator(self,
                                                      {'name': 'Receptacle Type',
                                                       'offset': 3,
                                                       'bit length': 3})

        ReceptType.help = """Select the feature set available on the Type-C port. Most cases will use standard Fully-Featured USB-C Receptacle."""
        ReceptType.setMaxValue(1)
        ReceptType.setReportList(['Standard USB2-only USB-C receptacle', \
                                  'Standard fully-featured USB-C receptacle', \
                                  ])

        ReceptTypeFV = register_class.cForceSetDMTerminator(self,
                                                            {'name': 'Receptacle Type',
                                                             'offset': 3,
                                                             'bit length': 3,
                                                             'force value': int(1),
                                                             'force display': 'Standard fully-featured USB-C receptacle',
                                                             'display widget': ReceptType})

        ReceptTypeFV.hide()
        ReceptTypeFV.help = """Select the feature set available on the Type-C port. Most cases will use standard Fully-Featured USB-C Receptacle."""
        self.dataModel.addChild(ReceptTypeFV)

        AudioAccesorySupport = register_class.cBooleanDMTerminator(self,
                                                                   {'name': 'Audio Accessory Support',
                                                                    'offset': 6,
                                                                    'bit length': 1})
        AudioAccesorySupport.help = """Allows the Type-C port to support an Audio Accessory such as a 3.5mm to Type-C adapter."""
        self.dataModel.addChild(AudioAccesorySupport)

        DebugAccessorySupport = register_class.cBooleanDMTerminator(self,
                                                                    {'name': 'Debug Accessory Support',
                                                                     'offset': 7,
                                                                     'bit length': 1})
        DebugAccessorySupport.help = """Allows the device to support Debug Accessory devices attached to the Type-C port."""
        self.dataModel.addChild(DebugAccessorySupport)

        typeCOptList = ['No Options', \
                        'Try.Src', \
                        'Try.Snk', \
                        'Powered Accessory', \
                        ]

        typeCOpt = register_class.cListDMTerminator(self,
                                                    {'name': 'Type-C Supported Options',
                                                     'offset': 8,
                                                     'bit length': 2})
        typeCOpt.help = """Enables the Try Source, Try Sink, or powered accessory support on the Type-C Port."""
        typeCOpt.setReportList(typeCOptList)
        self.dataModel.addChild(typeCOpt)

        reserved = register_class.cForceSetDMTerminator(self,
                                                        {'name': 'Reserved',
                                                         'offset': 10,
                                                         'bit length': 1,
                                                         'force value': int(0),
                                                         'force display': 'Reserved, set 0'})
        reserved.hide()
        self.dataModel.addChild(reserved)

        vconnSupportList = ['VCONN not supported (disabled)', \
                            'Reserved', \
                            'VCONN supported as DFP only (reject VCONN_Swap requests)', \
                            'VCONN supported as DFP/UFP (accept VCONN_Swap requests)', \
                            ]

        # deprecated
        #        vconnSupport = register_class.cListDMTerminator(self,
        #                                                                    {'name' : 'VConn Supported',
        #                                                                     'offset' : 11,
        #                                                                     'bit length' : 2 })
        #        vconnSupport.help = """Select VCONN support options for E-Marked cables or captive cable accessories."""
        #        vconnSupport.setReportList(vconnSupportList)
        #        self.dataModel.addChild(vconnSupport)

        USB3Rate = register_class.cListDMTerminator(self,
                                                    {'name': 'USB3.0/3.1 Rate',
                                                     'offset': 13,
                                                     'bit length': 2})
        USB3Rate.help = """Set the USB 3 capabilities on the Type-C port."""
        USB3Rate.setMaxValue(2)
        USB3Rate.setReportList(['USB3 not supported', \
                                'USB3 Gen1 signaling rate supported', \
                                'USB3 Gen2 signaling rate supported', \
                                ])

        self.dataModel.addChild(USB3Rate)

        reserved = register_class.cForceSetDMTerminator(self,
                                                        {'name': 'Reserved',
                                                         'offset': 15,
                                                         'bit length': 1,
                                                         'force value': int(0),
                                                         'force display': 'Reserved, set 0'})
        reserved.hide()
        self.dataModel.addChild(reserved)

        SetUVP = register_class.cBooleanDMTerminator(self,
                                                     {'name': 'Set UVP to 4.5 V',
                                                      'offset': 16,
                                                      'bit length': 1})
        SetUVP.help = """Set the undervoltage protection on VBUS to 4.5V."""

        SetUVPFV = register_class.cForceSetDMTerminator(self,
                                                        {'name': 'Set UVP to 4.5 V',
                                                         'offset': 16,
                                                         'bit length': 1,
                                                         'force value': int(0),
                                                         'force display': 'False',
                                                         'display widget': SetUVP})

        SetUVPFV.hide()
        SetUVPFV.help = """Select the feature set available on the Type-C port. Most cases will use standard Fully-Featured USB-C Receptacle."""
        self.dataModel.addChild(SetUVPFV)

        UvpTripPoint5V = register_class.cListDMTerminator(self,
                                                          {'name': 'Under-voltage Protection Trip Point, 5V',
                                                           'offset': 17,
                                                           'bit length': 3})

        UvpTripPoint5V.help = """Set the voltage at which VBUS will disconnect if the supply voltage drops below a certain percentage of the active PDO. For example, if set to 50%, VBUS will disconnect if the 5V source drops below 2.5V."""
        UvpTripPoint5V.setReportList(['5%', \
                                      '10%', \
                                      '15%', \
                                      '20%', \
                                      '25%', \
                                      '30%', \
                                      '40%', \
                                      '50%', \
                                      ])

        UvpTripPoint5VFV = register_class.cForceSetDMTerminator(self,
                                                                {'name': 'Under-voltage Protection Trip Point, 5V',
                                                                 'offset': 17,
                                                                 'bit length': 3,
                                                                 'force value': int(3),
                                                                 'force display': '20%',
                                                                 'display widget': UvpTripPoint5V})

        UvpTripPoint5VFV.hide()
        UvpTripPoint5VFV.help = """Set the voltage at which VBUS will disconnect if the supply voltage drops below a certain percentage of the active PDO. For example, if set to 50%, VBUS will disconnect if the 5V source drops below 2.5V."""
        self.dataModel.addChild(UvpTripPoint5VFV)

        UvpUsageHV = register_class.cListDMTerminator(self,
                                                      {'name': 'Under-voltage Protection Trip Point, >5V',
                                                       'offset': 20,
                                                       'bit length': 3})

        UvpUsageHV.help = """Set the voltage at which VBUS will disconnect if the supply voltage drops below a certain percentage of the active PDO. For example, if set to 50%, and the PD Controller is in a 20V Contract, VBUS will disconnect if the 20V source drops below 10V."""
        UvpUsageHV.setReportList(['5%', \
                                  '10%', \
                                  '15%', \
                                  '20%', \
                                  '25%', \
                                  '30%', \
                                  '40%', \
                                  '50%', \
                                  ])

        UvpUsageHVFV = register_class.cForceSetDMTerminator(self,
                                                            {'name': 'Under-voltage Protection Trip Point, >5V',
                                                             'offset': 20,
                                                             'bit length': 3,
                                                             'force value': int(3),
                                                             'force display': '20%',
                                                             'display widget': UvpUsageHV})

        UvpUsageHVFV.hide()
        UvpUsageHVFV.help = """Set the voltage at which VBUS will disconnect if the supply voltage drops below a certain percentage of the active PDO. For example, if set to 50%, VBUS will disconnect if the 5V source drops below 2.5V."""
        self.dataModel.addChild(UvpUsageHVFV)

        OVPtrip = cOVPVoltageField(self,
                                   {'name': 'Over Voltage Protection Trip Point',
                                    'offset': 23,
                                    'bit length': 6})

        OVPtrip.help = """Sets the voltage at which VBUS will disconnect if voltage exceeds this value."""

        OVPtripFV = register_class.cForceSetDMTerminator(self,
                                                         {'name': 'Over Voltage Protection Trip Point',
                                                          'offset': 23,
                                                          'bit length': 6,
                                                          'force value': int(0x3F),
                                                          'force display': '24V',
                                                          'display widget': OVPtrip})

        OVPtripFV.hide()
        OVPtripFV.help = """Sets the voltage at which VBUS will disconnect if voltage exceeds this value."""
        self.dataModel.addChild(OVPtripFV)

        OVPUsage = register_class.cListDMTerminator(self,
                                                    {'name': 'Over Voltage Protection Usage',
                                                     'offset': 29,
                                                     'bit length': 2})

        OVPUsage.help = """Select when VBUS should disconnect when an Over-Voltage event occurs."""
        OVPUsage.setReportList(['Disconnect VBUS if voltage exceeds OVPTripPoint', \
                                'Disconnect VBUS if voltage exceeds 5% of expected max.', \
                                'Disconnect VBUS if voltage exceeds 10% of expected max.', \
                                'Disconnect VBUS if voltage exceeds 15% of expected max.', \
                                ])

        OVPUsageFV = register_class.cForceSetDMTerminator(self,
                                                          {'name': 'Over Voltage Protection Trip Point',
                                                           'offset': 29,
                                                           'bit length': 2,
                                                           'force value': int(2),
                                                           'force display': 'Disconnect VBUS if voltage exceeds 10% of expected max.',
                                                           'display widget': OVPUsage})

        OVPUsageFV.hide()
        OVPUsageFV.help = """Sets the voltage at which VBUS will disconnect if voltage exceeds this value."""
        self.dataModel.addChild(OVPUsageFV)

        HVWarn = register_class.cListDMTerminator(self,
                                                  {'name': 'High Voltage Warning Level',
                                                   'offset': 31,
                                                   'bit length': 1})

        HVWarn.help = """Select when the PD Controller will issue a warning when VBUS exceeds a percentage of its nominal value."""
        HVWarn.setReportList(['Warning when source VBUS voltage exceeds 10% from nominal', \
                              'Warning when source VBUS voltage exceeds 20% from nominal', \
                              ])

        HVWarnFV = register_class.cForceSetDMTerminator(self,
                                                        {'name': 'Over Voltage Protection Trip Point',
                                                         'offset': 31,
                                                         'bit length': 1,
                                                         'force value': int(1),
                                                         'force display': 'Warning when source VBUS voltage exceeds 20% from nominal',
                                                         'display widget': HVWarn})

        HVWarnFV.hide()
        HVWarnFV.help = """Select when the PD Controller will issue a warning when VBUS exceeds a percentage of its nominal value."""
        self.dataModel.addChild(HVWarnFV)

        LVWarn = register_class.cListDMTerminator(self,
                                                  {'name': 'Low Voltage Warning Level',
                                                   'offset': 32,
                                                   'bit length': 1})

        LVWarn.help = """Select when the PD Controller will issue a warning when VBUS is below a percentage of its nominal value."""
        LVWarn.setReportList(['Warning when source VBUS Voltage dips below 10% from nominal', \
                              'Warning when source VBUS Voltage dips below 20% from nominal', \
                              ])
        # Check with Steve for correctness of list descriptions

        LVWarnFV = register_class.cForceSetDMTerminator(self,
                                                        {'name': 'Over Voltage Protection Trip Point',
                                                         'offset': 32,
                                                         'bit length': 1,
                                                         'force value': int(1),
                                                         'force display': 'Warning when source VBUS voltage dips below 20% from nominal',
                                                         'display widget': LVWarn})

        LVWarnFV.hide()
        LVWarnFV.help = """Select when the PD Controller will issue a warning when VBUS is below a percentage of its nominal value."""
        self.dataModel.addChild(LVWarnFV)

        softStartList = ['0.41 V/mS typical', '0.79 V/mS typical', '1.57 V/mS typical', '3.39 V/mS typical']

        softStart = register_class.cListDMTerminator(self,
                                                     {'name': 'Soft Start Slew Rate',
                                                      'offset': 33,
                                                      'bit length': 2})

        softStart.help = """Adjusts timing of the soft start for the internal power path."""
        softStart.setReportList(softStartList)

        softStartFV = register_class.cForceSetDMTerminator(self,
                                                           {'name': 'Over Voltage Protection Trip Point',
                                                            'offset': 33,
                                                            'bit length': 2,
                                                            'force value': int(0),
                                                            'force display': '0.41 V/mS typical',
                                                            'display widget': softStart})

        softStartFV.hide()
        softStartFV.help = """Select when the PD Controller will issue a warning when VBUS is below a percentage of its nominal value."""
        self.dataModel.addChild(softStartFV)

        reserved = register_class.cForceSetDMTerminator(self,
                                                        {'name': 'Reserved',
                                                         'offset': 35,
                                                         'bit length': 5,
                                                         'force value': int(0),
                                                         'force display': 'Reserved, set 0'})
        reserved.hide()
        self.dataModel.addChild(reserved)

        vthSnk = register_class.cDecimalDMTerminator(self,
                                                     {'name': 'Voltage Threshold as Sink Contract',
                                                      'offset': 40,
                                                      'bit length': 8})
        vthSnk.help = """Voltage threshold setting for triggering GPIO output event indicating Sink under contract \
                         with a voltage greater than or equal to the programmed threshold setting. \n\n
                         Voltage threshold = (VoltageThresSinkContractPort) * 200 mV ."""
        self.dataModel.addChild(vthSnk)


########################################################################################################################
########################################################################################################################
########################################################################################################################


# four arguments:
# [0] process swap to sink
# [1] initiate swap to sink
# [2] process swap to source
# [3] initiate swap to source
def powSwapDerivedFxn(argumentList):
    procSink = argumentList[0].valueToInt()
    initSink = argumentList[1].valueToInt()
    procSource = argumentList[2].valueToInt()
    initSource = argumentList[3].valueToInt()

    # arg 0-3 (0 is lsb) -->
    # 'No Preference, Rejects All Swaps', 'No Preference, Supports All Swaps', 'Prefers Power Source', 'Prefers Power Sink'

    inputInt = (procSink & 0x1) | (initSink & 0x1) << 1 | (procSource & 0x1) << 2 | (initSource & 0x1) << 3

    translationDict = {0b0000: 0b00,
                       0b0001: 0b00,
                       0b0010: 0b11,
                       0b0011: 0b11,
                       0b0100: 0b00,
                       0b0101: 0b01,
                       0b0110: 0b00,
                       0b0111: 0b11,
                       0b1000: 0b10,
                       0b1001: 0b10,
                       0b1010: 0b00,
                       0b1011: 0b11,
                       0b1100: 0b10,
                       0b1101: 0b10,
                       0b1110: 0b00,
                       0b1111: 0b00
                       }

    return translationDict[inputInt]


# four arguments:
# [0] process swap to sink
# [1] initiate swap to sink
# [2] process swap to source
# [3] initiate swap to source
def powSwapUpdateFxn(value, argumentList):
    # 'No Preference, Rejects All Swaps', 'No Preference, Supports All Swaps', 'Prefers Power Source', 'Prefers Power Sink'
    # --> arg 0-3 (0 is lsb)
    revTranslationDict = {0b00: 0b0000,
                          0b01: 0b0101,
                          0b10: 0b1100,
                          0b11: 0b0011
                          }

    outBits = revTranslationDict[value]

    argumentList[0].setFromInt(outBits & (0b0001))
    argumentList[1].setFromInt((outBits & (0b0010)) >> 1)
    argumentList[2].setFromInt((outBits & (0b0100)) >> 2)
    argumentList[3].setFromInt((outBits & (0b1000)) >> 3)


# four arguments:
# [0] process swap to UFP
# [1] initiate swap to UFP
# [2] process swap to DFP
# [3] initiate swap to DFP
def dataSwapDerivedFxn(argumentList):
    procUFP = argumentList[0].valueToInt()
    initUFP = argumentList[1].valueToInt()
    procDFP = argumentList[2].valueToInt()
    initDFP = argumentList[3].valueToInt()

    # arg 0-3 (0 is lsb) -->
    # 'No Preference, Rejects All Swaps', 'No Preference, Supports All Swaps', 'Prefers Data DFP (host)', 'Prefers Data UFP (device)'

    inputInt = (procUFP & 0x1) | (initUFP & 0x1) << 1 | (procDFP & 0x1) << 2 | (initDFP & 0x1) << 3

    translationDict = {0b0000: 0b00,
                       0b0001: 0b00,
                       0b0010: 0b11,
                       0b0011: 0b11,
                       0b0100: 0b00,
                       0b0101: 0b01,
                       0b0110: 0b00,
                       0b0111: 0b11,
                       0b1000: 0b10,
                       0b1001: 0b10,
                       0b1010: 0b00,
                       0b1011: 0b11,
                       0b1100: 0b10,
                       0b1101: 0b10,
                       0b1110: 0b00,
                       0b1111: 0b00
                       }

    return translationDict[inputInt]


# four arguments:
# [0] process swap to sink
# [1] initiate swap to sink
# [2] process swap to source
# [3] initiate swap to source
def dataSwapUpdateFxn(value, argumentList):
    # 'No Preference, Rejects All Swaps', 'No Preference, Supports All Swaps', 'Prefers Data DFP (host)', 'Prefers Data UFP (device)'
    # --> arg 0-3 (0 is lsb)
    revTranslationDict = {0b00: 0b0000,
                          0b01: 0b0101,
                          0b10: 0b1100,
                          0b11: 0b0011
                          }

    outBits = revTranslationDict[value]

    argumentList[0].setFromInt(outBits & (0b0001))
    argumentList[1].setFromInt((outBits & (0b0010)) >> 1)
    argumentList[2].setFromInt((outBits & (0b0100)) >> 2)
    argumentList[3].setFromInt((outBits & (0b1000)) >> 3)


class cPortControl_0x29_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Port Control',
                                                 'address': 0x29,
                                                 'byte length': 4,
                                                 'permission': 'RW'})

        hide_simplified = True

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'Port Control',
                                                         'offset': 0,
                                                         'bit length': 40})

        TypeCCurr = register_class.cListDMTerminator(self,
                                                     {'name': 'Type-C Current',
                                                      'offset': 0,
                                                      'bit length': 2})
        TypeCCurr.help = """Sets the Type-C current available on the port"""
        TypeCCurr.setMaxValue(2)
        TypeCCurr.setReportList(['Default Current (weakest pullup)', \
                                 '1.5 A (medium pullup)', \
                                 '3 A (strongest pullup)', \
                                 ])

        self.dataModel.addChild(TypeCCurr)

        disablePD = register_class.cListDMTerminator(self,
                                                     {'name': 'PD Mode',
                                                      'offset': 2,
                                                      'bit length': 2})

        disablePD.help = """This will be set to Normal PD Behavior in most applications. If it is desirable to emulate a Legacy Device with the PD controller, select Legacy USB Source or Sink."""
        disablePD.setMaxValue(2)

        disablePD.setReportList(['Normal PD Behavior', \
                                 'Legacy USB Host/Source', \
                                 'Legacy USB Device/Sink'
                                 ])

        disablePDFV = register_class.cForceSetDMTerminator(self, {'name': 'PD Mode',
                                                                  'offset': 2,
                                                                  'bit length': 2,
                                                                  'force value': int(0),
                                                                  'force display': 'Normal PD Behavior',
                                                                  'display widget': disablePD})

        self.dataModel.addChild(disablePDFV)
        disablePDFV.setFromInt(0)
        if hide_simplified:
            disablePDFV.hide()

        powSwap = register_class.cVirtualListDMTerminator(self,
                                                          {'name': 'Power Swap Strategy',
                                                           'offset': 0,
                                                           'bit length': 2})

        powSwap.setReportList(
            ['No Preference, Rejects All Swaps', 'No Preference, Supports All Swaps', 'Prefers Power Source',
             'Prefers Power Sink'])
        powSwap.registerAsDerivedField(powSwapDerivedFxn, powSwapUpdateFxn,
                                       [ \
                                           ['Port Control', 'Process Swap To Sink'], \
                                           ['Port Control', 'Initiate Swap To Sink'], \
                                           ['Port Control', 'Process Swap To Source'], \
                                           ['Port Control', 'Initiate Swap To Source'], \
                                           ])

        powSwap.addUpdateRegisterByName("self")

        self.dataModel.addChild(powSwap)

        processSwTSk = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Process Swap To Sink',
                                                            'offset': 4,
                                                            'bit length': 1})

        processSwTSk.help = """With this bit enabled, the PD controller will swap to a sink when the far end device requests to become a source."""
        self.dataModel.addChild(processSwTSk)
        processSwTSk.hide()

        initSwTSk = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'Initiate Swap To Sink',
                                                         'offset': 5,
                                                         'bit length': 1})

        initSwTSk.help = """With this bit enabled, the PD controller will request to become a sink if appropriate when it is a source."""
        self.dataModel.addChild(initSwTSk)
        initSwTSk.hide()

        processSwTSr = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Process Swap To Source',
                                                            'offset': 6,
                                                            'bit length': 1})

        processSwTSr.help = """With this bit enabled, the PD controller will swap to a source when the far end device requests to become a sink."""
        self.dataModel.addChild(processSwTSr)
        processSwTSr.hide()

        initSwTSr = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'Initiate Swap To Source',
                                                         'offset': 7,
                                                         'bit length': 1})

        initSwTSr.help = """With this bit enabled, the PD controller will request to become a source if approriate when it is a sink."""
        self.dataModel.addChild(initSwTSr)
        initSwTSr.hide()

        rdoInt = register_class.cForceSetDMTerminator(self, {'name': 'Reserved',
                                                             'offset': 8,
                                                             'bit length': 1,
                                                             'force value': int(0),
                                                             'force display': 'Reserved, Set 0'})

        self.dataModel.addChild(rdoInt)
        rdoInt.setFromInt(0)
        if hide_simplified:
            rdoInt.hide()

        pdoInt = register_class.cForceSetDMTerminator(self, {'name': 'Reserved',
                                                             'offset': 9,
                                                             'bit length': 1,
                                                             'force value': int(0),
                                                             'force display': 'Reserved, Set 0'})

        self.dataModel.addChild(pdoInt)
        pdoInt.setFromInt(0)
        if hide_simplified:
            pdoInt.hide()

        procVconnSw = register_class.cForceSetDMTerminator(self, {'name': 'Process VCONN Swap',
                                                                  'offset': 10,
                                                                  'bit length': 1,
                                                                  'force value': int(1),
                                                                  'force display': 'Enabled'})

        self.dataModel.addChild(procVconnSw)
        procVconnSw.help = """The PD Controller will accept VCONN Swap requests received from the far end device. """
        procVconnSw.setFromInt(1)
        if hide_simplified:
            procVconnSw.hide()

        # deprecated
        #        initVconnSw = register_class.cForceSetDMTerminator( self,  { 'name' : 'Initiate VCONN Swap',
        #                                                                'offset' : 11,
        #                                                                'bit length' : 1,
        #                                                                'force value' : int(0),
        #                                                                'force display' : 'Disabled'})

        #        self.dataModel.addChild(initVconnSw)
        #        initVconnSw.help = """The PD Controller will send VCONN Swap requests to the far end device."""
        #        initVconnSw.setFromInt(0)
        #        if hide_simplified :
        #            initVconnSw.hide()

        dataSwap = register_class.cVirtualListDMTerminator(self,
                                                           {'name': 'Data Swap Strategy',
                                                            'offset': 0,
                                                            'bit length': 2})

        dataSwap.setReportList(
            ['No Preference, Rejects All Swaps', 'No Preference, Supports All Swaps', 'Prefers Data DFP (host)',
             'Prefers Data UFP (device)'])
        dataSwap.registerAsDerivedField(dataSwapDerivedFxn, dataSwapUpdateFxn,
                                        [ \
                                            ['Port Control', 'Process Swap To UFP'], \
                                            ['Port Control', 'Initiate Swap To UFP'], \
                                            ['Port Control', 'Process Swap To DFP'], \
                                            ['Port Control', 'Initiate Swap To DFP'], \
                                            ])

        dataSwap.addUpdateRegisterByName("self")

        self.dataModel.addChild(dataSwap)

        procSwUFP = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'Process Swap To UFP',
                                                         'offset': 12,
                                                         'bit length': 1})

        procSwUFP.help = """The PD Controller will process a swap to UFP request sent from the far end device."""
        self.dataModel.addChild(procSwUFP)
        procSwUFP.hide()

        initSwUFP = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'Initiate Swap To UFP',
                                                         'offset': 13,
                                                         'bit length': 1})

        initSwUFP.help = """If the PD Controller is a DFP, it will send a DR_Swap to become UFP to the far end device."""
        self.dataModel.addChild(initSwUFP)
        initSwUFP.hide()

        procSwDFP = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'Process Swap To DFP',
                                                         'offset': 14,
                                                         'bit length': 1})

        procSwDFP.help = """The PD Controller will process a swap to DFP request sent from the far end device."""
        self.dataModel.addChild(procSwDFP)
        procSwDFP.hide()

        initSwDFP = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'Initiate Swap To DFP',
                                                         'offset': 15,
                                                         'bit length': 1})

        initSwDFP.help = """If the PD Controller is a UFP, it will send a DR_Swap to become DFP to the far end device."""
        self.dataModel.addChild(initSwDFP)
        initSwDFP.hide()

        autoID = register_class.cForceSetDMTerminator(self, {'name': 'Automatic ID Request',
                                                             'offset': 16,
                                                             'bit length': 1,
                                                             'force value': int(1),
                                                             'force display': 'Enabled'})

        self.dataModel.addChild(autoID)
        autoID.setFromInt(1)
        if hide_simplified:
            autoID.hide()

        intAM = register_class.cForceSetDMTerminator(self, {'name': 'Reserved',
                                                            'offset': 17,
                                                            'bit length': 1,
                                                            'force value': int(0),
                                                            'force display': 'Reserved, set 0'})

        self.dataModel.addChild(intAM)
        intAM.setFromInt(0)
        if hide_simplified:
            intAM.hide()

        forceUSBGen1 = register_class.cForceSetDMTerminator(self, {'name': 'Force USB Generation 1',
                                                                   'offset': 18,
                                                                   'bit length': 1,
                                                                   'force value': 0,
                                                                   'force display': 'False'})

        self.dataModel.addChild(forceUSBGen1)
        forceUSBGen1.setFromInt(1)
        if hide_simplified:
            forceUSBGen1.hide()

        externallyPowered = register_class.cBooleanDMTerminator(self,
                                                                {'name': 'Externally Powered',
                                                                 'offset': 19,
                                                                 'bit length': 1})

        externallyPowered.help = """When enabled, The system is receiving external power from a source other than VBUS for this PD Controller . When disabled, VBUS is the only means of applying power externally."""
        self.dataModel.addChild(externallyPowered)

        AutomaticSinkCap = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'Automatic Sink Cap',
                                                                'offset': 20,
                                                                'bit length': 1})

        AutomaticSinkCap.help = """Automatically send sink capabilities message."""

        AutomaticSinkCapFV = register_class.cForceSetDMTerminator(self, {'name': 'Automatic Sink Cap',
                                                                         'offset': 20,
                                                                         'bit length': 1,
                                                                         'force value': 1,
                                                                         'force display': 'True',
                                                                         'display widget': AutomaticSinkCap})

        self.dataModel.addChild(AutomaticSinkCapFV)
        AutomaticSinkCapFV.help = """Automatically send sink capabilities message."""
        AutomaticSinkCapFV.setFromInt(1)
        if hide_simplified:
            AutomaticSinkCapFV.hide()

        USBDisable = register_class.cBooleanDMTerminator(self,
                                                         {'name': 'USB Disable',
                                                          'offset': 29,
                                                          'bit length': 1})

        USBDisable.help = """Maintain normal USB PD behavior or stop USB PD activities and either behave as a Legacy USB source or a Legacy USB Sink."""

        USBDisableFV = register_class.cForceSetDMTerminator(self, {'name': 'USB Disable',
                                                                   'offset': 29,
                                                                   'bit length': 1,
                                                                   'force value': 0,
                                                                   'force display': 'False',
                                                                   'display widget': USBDisable})

        self.dataModel.addChild(USBDisableFV)
        USBDisableFV.help = """Maintain normal USB PD behavior or stop USB PD activities and either behave as a Legacy USB source or a Legacy USB Sink."""
        USBDisableFV.setFromInt(0)
        if hide_simplified:
            USBDisableFV.hide()

        # Remove for ROM 1.5
        #        reserved = register_class.cForceSetDMTerminator(self,
        #                                                                    {'name' : 'Reserved',
        #                                                                     'offset' : 21,
        #                                                                     'bit length' : 8,
        #                                                                     'force value' : int(0),
        #                                                                     'force display' : 'Reserved, set 0'})
        #        reserved.hide()
        #        self.dataModel.addChild(reserved)

        SinkControlBit = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'Sink Control Bit',
                                                              'offset': 21,
                                                              'bit length': 1})

        SinkControlBit.help = """When enabled, the sink switch is not closed when the externally powered bit is set in the port control register.  This keeps systems that are wall powered from unnecessarily drawing power over type-c connection."""
        self.dataModel.addChild(SinkControlBit)

        reserved2 = register_class.cForceSetDMTerminator(self,
                                                         {'name': 'Reserved',
                                                          'offset': 22,
                                                          'bit length': 2,
                                                          'force value': int(0),
                                                          'force display': 'Reserved, set 0'})
        reserved2.hide()
        self.dataModel.addChild(reserved2)

        Resistor15kPresent = register_class.cBooleanDMTerminator(self,
                                                                 {'name': '15 kOhm Resistor Present',
                                                                  'offset': 24,
                                                                  'bit length': 1})

        Resistor15kPresent.help = """15 kOhm resistor present on D+/D-."""
        Resistor15kPresent.hide()

        Resistor15kPresentFV = register_class.cForceSetDMTerminator(self, {'name': '15 kOhm Resistor Present',
                                                                           'offset': 24,
                                                                           'bit length': 1,
                                                                           'force value': 0,
                                                                           'force display': 'False',
                                                                           'display widget': Resistor15kPresent})
        Resistor15kPresentFV.hide()
        self.dataModel.addChild(Resistor15kPresentFV)

        DCDEnable = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'Data Contact Detection Enable',
                                                         'offset': 25,
                                                         'bit length': 1})

        DCDEnable.help = """Enable data contact detection in BC1.2 detection."""
        DCDEnable.hide()

        DCDEnableFV = register_class.cForceSetDMTerminator(self, {'name': 'Data Contact Detection Enable',
                                                                  'offset': 25,
                                                                  'bit length': 1,
                                                                  'force value': 0,
                                                                  'force display': 'False',
                                                                  'display widget': DCDEnable})
        DCDEnableFV.hide()
        self.dataModel.addChild(DCDEnableFV)

        ChargerAdvertiseEnableList = ['Charger Advertise Disabled', 'BC1.2 CDP Advertisement',
                                      'BC1.2 DCP Advertisement', 'DCP 1.2V Advertisememnt',
                                      'DCP Divider3 Advertisement', 'DCP Auto Mode 1 (Divider3, BC1.2 short)',
                                      'DCP Auto Mode 2 (Divider3, 1.2V, BC1.2 short)']

        ChargerAdvertiseEnable = register_class.cListDMTerminator(self,
                                                                  {'name': 'Charger Advertise Enable',
                                                                   'offset': 26,
                                                                   'bit length': 3})

        ChargerAdvertiseEnable.setMaxValue(2)
        ChargerAdvertiseEnable.setReportList(ChargerAdvertiseEnableList)
        self.dataModel.addChild(ChargerAdvertiseEnable)

        #        ChargerAdvertiseEnableFV = register_class.cForceSetDMTerminator( self,  { 'name' : 'Charger Advertise Enable',
        #                                                            'offset' : 26,
        #                                                            'bit length' : 3,
        #                                                            'force value' : 0,
        #                                                            'force display' : 'False',
        #                                                            'display widget' : ChargerAdvertiseEnable })
        #        ChargerAdvertiseEnableFV.hide()
        #        self.dataModel.addChild(ChargerAdvertiseEnableFV)

        ChargerDetectEnableList = ['Charger Detect Disabled', 'BC1.2 Detection', 'Proprietary Detection',
                                   'BC1.2 and Proprietary Detection']

        ChargerDetectEnable = register_class.cListDMTerminator(self,
                                                               {'name': 'Charger Detect Enable',
                                                                'offset': 30,
                                                                'bit length': 2})

        ChargerDetectEnable.setMaxValue(1)
        ChargerDetectEnable.setReportList(ChargerDetectEnableList)
        #        ChargerDetectEnable.hide()
        self.dataModel.addChild(ChargerDetectEnable)


#        ChargerDetectEnableFV = register_class.cForceSetDMTerminator( self,  { 'name' : 'Charger Detect Enable',
#                                                            'offset' : 30,
#                                                            'bit length' : 2,
#                                                            'force value' : 3,
#                                                            'force display' : 'BC1.2 and Proprietary Detection',
#                                                            'display widget' : ChargerDetectEnable })
#        ChargerDetectEnableFV.hide()
#        self.dataModel.addChild(ChargerDetectEnableFV)


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cBootFlags_0x2D_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Boot Flags',
                                                 'address': 0x2D,
                                                 'byte length': 12,
                                                 'permission': 'DRO'})

        self.setAsShared()

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'Boot Flags',
                                                         'offset': 0,
                                                         'bit length': 96})

        PatchHeaderErr = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'Patch Header Error',
                                                              'offset': 0,
                                                              'bit length': 1})

        PatchHeaderErr.help = """Patch Bundle Header error had occurred."""
        self.dataModel.addChild(PatchHeaderErr)

        DeadBatteryFlag = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Dead Battery Flag',
                                                               'offset': 2,
                                                               'bit length': 1})

        DeadBatteryFlag.help = """The Device has booted in Dead Battery Mode"""
        self.dataModel.addChild(DeadBatteryFlag)

        SpiFlashPresent = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'SPI Flash Present',
                                                               'offset': 3,
                                                               'bit length': 1})

        SpiFlashPresent.help = """SPI_MISO pin was not grounded at boot, response received from SPI flash device. PD Controller is the primary device"""
        self.dataModel.addChild(SpiFlashPresent)

        Region0 = register_class.cBooleanDMTerminator(self,
                                                      {'name': 'Region 0',
                                                       'offset': 4,
                                                       'bit length': 1})

        Region0.help = """Region 0 of the SPI Memory was attempted."""
        self.dataModel.addChild(Region0)

        Region1 = register_class.cBooleanDMTerminator(self,
                                                      {'name': 'Region 1',
                                                       'offset': 5,
                                                       'bit length': 1})

        Region1.help = """Region 1 of the SPI Memory was attempted."""
        self.dataModel.addChild(Region1)

        Region0Invalid = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'Region 0 Invalid',
                                                              'offset': 6,
                                                              'bit length': 1})

        Region0Invalid.help = """Region 0 of the SPI Memory was invalid"""
        self.dataModel.addChild(Region0Invalid)

        Region1Invalid = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'Region 1 Invalid',
                                                              'offset': 7,
                                                              'bit length': 1})

        Region1Invalid.help = """Region 1 of the SPI Memory was invalid"""
        self.dataModel.addChild(Region1Invalid)

        Region0FlashErr = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Region 0 Flash Error',
                                                               'offset': 8,
                                                               'bit length': 1})

        Region0FlashErr.help = """An error occurred attempting to read Region 0 of SPI memory. A retry may have been successful."""
        self.dataModel.addChild(Region0FlashErr)

        Region1FlashErr = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Region 1 Flash Error',
                                                               'offset': 9,
                                                               'bit length': 1})

        Region1FlashErr.help = """An error occurred attempting to read Region 1 of SPI memory. A retry may have been successful."""
        self.dataModel.addChild(Region1FlashErr)

        PatchDownloadErr = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'Patch Download Error',
                                                                'offset': 10,
                                                                'bit length': 1})

        PatchDownloadErr.help = """Patch Bundle Download Error had occurred."""
        self.dataModel.addChild(PatchDownloadErr)

        Region0CrcFail = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'Region 0 CRC Fail',
                                                              'offset': 12,
                                                              'bit length': 1})

        Region0CrcFail.help = """CRC of read data from Region 0 of SPI memory failed."""
        self.dataModel.addChild(Region0CrcFail)

        Region1CrcFail = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'Region 1 CRC Fail',
                                                              'offset': 13,
                                                              'bit length': 1})

        Region1CrcFail.help = """CRC of read data from Region 1 of SPI memory failed."""
        self.dataModel.addChild(Region1CrcFail)

        CustomerOTPInvalid = register_class.cBooleanDMTerminator(self,
                                                                 {'name': 'Customer OTP Invalid',
                                                                  'offset': 14,
                                                                  'bit length': 1})

        CustomerOTPInvalid.help = """If set, the OTP Config bytes above are valid."""
        self.dataModel.addChild(CustomerOTPInvalid)

        PP1Switch = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'PP1 Switch',
                                                         'offset': 17,
                                                         'bit length': 1})

        PP1Switch.help = """PP1 sink path enabled during dead-battery mode."""
        self.dataModel.addChild(PP1Switch)

        PP2Switch = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'PP2 Switch',
                                                         'offset': 18,
                                                         'bit length': 1})

        PP2Switch.help = """PP2 sink path enabled during dead-battery mode."""
        self.dataModel.addChild(PP2Switch)

        PP3Switch = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'PP3 Switch',
                                                         'offset': 19,
                                                         'bit length': 1})

        PP3Switch.help = """PP3 sink path enabled during dead-battery mode."""
        self.dataModel.addChild(PP3Switch)

        PP4Switch = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'PP4 Switch',
                                                         'offset': 20,
                                                         'bit length': 1})

        PP4Switch.help = """PP4 sink path enabled during dead-battery mode."""
        self.dataModel.addChild(PP4Switch)

        OTPCustomerValid = register_class.cListDMTerminator(self,
                                                            {'name': 'Customer OTP Valid',
                                                             'offset': 32,
                                                             'bit length': 2})

        OTPCustomerValid.help = """10b indicates valid Customer OTP Area."""
        OTPCustomerValid.setMaxValue(1)
        OTPCustomerValid.setReportList(['Invalid Customer OTP', \
                                        'Valid Customer OTP', \
                                        ])
        self.dataModel.addChild(OTPCustomerValid)

        OTPCustomerDeadBattery = register_class.cListDMTerminator(self,
                                                                  {'name': 'OTP Customer Dead Battery',
                                                                   'offset': 34,
                                                                   'bit length': 2})

        OTPCustomerDeadBattery.help = """10b indicates valid Customer OTP Area."""
        OTPCustomerDeadBattery.setMaxValue(3)
        OTPCustomerDeadBattery.setReportList(['Bus Power From ADCIN', \
                                              'Bus Power No Response', \
                                              'Bus Power Wait for 3V3, Close Internal Switch', \
                                              'Bus Power Wait for Patch, Close Internal Switch', \
                                              'Bus Power Wait for 3V3, Close External Switch', \
                                              'Bus Power Wait for Patch, Close External Switch', \
                                              'Bus Power No Wait', \
                                              ])

        self.dataModel.addChild(OTPCustomerDeadBattery)

        OTPCustomerOal2C = register_class.cHexDMTerminator(self,
                                                           {'name': 'OTP I2C Address [6:5] for I2C2',
                                                            'offset': 36,
                                                            'bit length': 2})

        OTPCustomerOal2C.help = """I2C Address contribution from OTP."""
        self.dataModel.addChild(OTPCustomerOal2C)

        OTPcustomerTBTpresent = register_class.cBooleanDMTerminator(self,
                                                                    {'name': 'OTP Customer TBT Present',
                                                                     'offset': 38,
                                                                     'bit length': 1})

        OTPcustomerTBTpresent.help = """TBT Supported"""
        self.dataModel.addChild(OTPcustomerTBTpresent)

        OTPcustomerI2CinputThres = register_class.cBooleanDMTerminator(self,
                                                                       {'name': 'OTP Customer I2C Threshold',
                                                                        'offset': 39,
                                                                        'bit length': 1})

        OTPcustomerI2CinputThres.help = """I2C input threshold"""
        self.dataModel.addChild(OTPcustomerI2CinputThres)

        OTPcustomerTBTCont = register_class.cHexDMTerminator(self,
                                                             {'name': 'OTP Customer TBT Controller Type',
                                                              'offset': 40,
                                                              'bit length': 2})

        self.dataModel.addChild(OTPcustomerTBTCont)

        OTPcustomerDisablePD = register_class.cBooleanDMTerminator(self,
                                                                   {'name': 'OTP Customer Disable PD',
                                                                    'offset': 42,
                                                                    'bit length': 1})

        self.dataModel.addChild(OTPcustomerDisablePD)

        REV_ID_Metal = register_class.cHexDMTerminator(self,
                                                       {'name': 'Revision ID Metal',
                                                        'offset': 63,
                                                        'bit length': 3})

        REV_ID_Metal.help = """PD Controller Silicon (Metal) Revision"""
        self.dataModel.addChild(REV_ID_Metal)

        REV_ID_Base = register_class.cListDMTerminator(self,
                                                       {'name': 'Revision ID Base',
                                                        'offset': 66,
                                                        'bit length': 3})

        REV_ID_Base.help = """PD Controller Silicon (Base) Revision, 0001b = A"""
        REV_ID_Base.setReportList(['TPS65982', \
                                   'TPS65983a', \
                                   'TPS65983b', \
                                   'TPS65982DC', \
                                   'Uknown (0x4)', \
                                   'TPS65988', \
                                   'Uknown (0x6)', \
                                   'Uknown (0x7)', \
                                   ])
        self.dataModel.addChild(REV_ID_Base)


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cMiscellaneous_0x2B_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Miscellaneous Configuration',
                                                 'address': 0x2B,
                                                 'byte length': 2,
                                                 'permission': 'RW'})

        self.setAsShared()

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'Miscellaneous Configuration',
                                                         'offset': 0,
                                                         'bit length': 16})

        I2C1Volt = register_class.cListDMTerminator(self, 1,
                                                    {'name': 'I2C1 Voltage Level',
                                                     'offset': 4,
                                                     'bit length': 1})

        I2C1Volt.help = """When set to 1, I2C1 voltage level will be referenced to LDO_3V3.When set to 0, I2C1 voltage will be referenced to VDDIO."""
        I2C1Volt.setReportList(['LDO_3V3', \
                                'VDD_IO', \
                                ])
        self.dataModel.addChild(I2C1Volt)

        I2C2Volt = register_class.cListDMTerminator(self, 1,
                                                    {'name': 'I2C2 Voltage Level',
                                                     'offset': 5,
                                                     'bit length': 1})

        I2C2Volt.help = """When set to 1, I2C2 voltage level will be referenced to LDO_3V3.When set to 0, I2C2 voltage will be referenced to VDDIO."""
        I2C2Volt.setReportList(['LDO_3V3', \
                                'VDD_IO', \
                                ])
        self.dataModel.addChild(I2C2Volt)

        cbWorkaround = register_class.cBooleanDMTerminator(self, 1,
                                                           {'name': 'Relax OCP on Voltage Transitions',
                                                            'offset': 8,
                                                            'bit length': 1})

        cbWorkaround.help = """When enabled, the PD controller will not trigger an OCP event during a voltage transition from one PDO to another."""
        self.dataModel.addChild(cbWorkaround)


########################################################################################################################
########################################################################################################################
########################################################################################################################


class cBuildID_0x2E_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Build Identifier',
                                                 'address': 0x2E,
                                                 'byte length': 49,
                                                 'permission': 'DRO'})

        self.setAsShared()

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'Build Identifier',
                                                         'offset': 0,
                                                         'bit length': 392})
        BuildID = register_class.cHexDMTerminator(self,
                                                  {'name': 'Build Identifier',
                                                   'offset': 0,
                                                   'bit length': 392})
        BuildID.help = """ASCII string returns uniquely identifying custom build information. note: 40 Hex Characters representing the build + 1
underscore character + MMDDYYYY (build date) + null terminator (0).Returns 0 length on released firmware."""
        self.dataModel.addChild(BuildID)


########################################################################################################################
########################################################################################################################
########################################################################################################################


class cDeviceInfo_0x2F_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Device Info',
                                                 'address': 0x2F,
                                                 'byte length': 47,
                                                 'permission': 'DRO'})

        self.setAsShared()

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'Device Info',
                                                         'offset': 0,
                                                         'bit length': 376})
        DeviceInfo = register_class.cAsciiDMTerminator(self,
                                                       {'name': 'Device Info',
                                                        'offset': 0,
                                                        'bit length': 376})
        DeviceInfo.help = """ASCII string with hardware and firmware version information of the PD Controller. Note: After NULL terminator for C string there are 12 additional
bytes, returning the same data as the bootloader does for registers
0x00, 0x01 and 0x0F in that order. This makes it possible to
positively identify n PD Controller and its bootloader version even
when the application image has overridden the base registers. This
is necessary for in-system flashing."""
        self.dataModel.addChild(DeviceInfo)


########################################################################################################################
########################################################################################################################
########################################################################################################################

# display pdos based on numPdo
# not a method, but should be grouped with txSrcCap class
def RxSrcCap_TopLevelDMGenerator(self):
    numSrcPdo = self.getChildByName('Number of Source PDOs').valueToInt()
    retDict = {'name': self.name, 'grouping tier': self.tier, 'data model list': []}
    retDict['data model list'].append(self.getChildByName('Number of Source PDOs').dataModelGenerator())
    for i in range(numSrcPdo):
        retDict['data model list'].append(self.getChildByName('Source PDO %d' % (i + 1)).dataModelGenerator())

    return retDict


class cRxSrcCap_0x30_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Received Source Capabilities',
                                                 'address': 0x30,
                                                 'byte length': 29,
                                                 'permission': 'DRO'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name': 'Received Source Capabilities',
                                                         'offset': 0,
                                                         'bit length': 232})

        numSrcPdo = register_class.cDecimalDMTerminator(self,
                                                        {'name': 'Number of Source PDOs',
                                                         'offset': 0,
                                                         'bit length': 3})

        numSrcPdo.help = """Number of valid Source PDOs that will be transmitted to the sink at the other end of the USB Type-C cable using USB-PD protocol. The PD Controller can transmit between 0 and 7 Source PDOs"""
        numSrcPdo.updateRegisters.append(self)

        self.dataModel.addChild(numSrcPdo)

        sPdo1 = cDMSourcePdo1Array(self, 1, {'name': 'Source PDO 1',
                                             'offset': 8,
                                             'bit length': 32,
                                             'Is Receive': True})
        self.dataModel.addChild(sPdo1)

        for i in range(2, 8):
            SrcPDOX = cDMAnySourcePdoArray(self, 1,
                                           {'name': 'Source PDO %d' % i,
                                            'offset': 8 + ((i - 1) * 32),
                                            'bit length': 32})

            self.dataModel.addChild(SrcPDOX)

        self.dataModel.setDataModelGenerator(RxSrcCap_TopLevelDMGenerator)


########################################################################################################################
########################################################################################################################
########################################################################################################################

# display pdos based on numPdo
# not a method, but should be grouped with txSrcCap class
def RxSinkCap_TopLevelDMGenerator(self):
    numSrcPdo = self.getChildByName('Number of Sink PDOs').valueToInt()
    retDict = {'name': self.name, 'grouping tier': self.tier, 'data model list': []}
    retDict['data model list'].append(self.getChildByName('Number of Sink PDOs').dataModelGenerator())
    for i in range(numSrcPdo):
        retDict['data model list'].append(self.getChildByName('Sink PDO %d' % (i + 1)).dataModelGenerator())

    return retDict


class cRxSinkCap_0x31_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Received Sink Capabilities',
                                                 'address': 0x31,
                                                 'byte length': 57,
                                                 'permission': 'DRO'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name': 'Received Sink Capabilities',
                                                         'offset': 0,
                                                         'bit length': 456})

        numSinkTerm = register_class.cDecimalDMTerminator(self,
                                                          {'name': 'Number of Sink PDOs',
                                                           'offset': 0,
                                                           'bit length': 3})
        numSinkTerm.help = """Number of valid sink PDOs that will be transmitted to the source at the other end of the USB Type-C cable using USB-PD protocol. The PD Controller can transmit between 0 and 7 Sink PDOs."""
        numSinkTerm.updateRegisters.append(self)

        # TODO: set max allowable value to 6 (instead of 0-7 from 3 bits)
        self.dataModel.addChild(numSinkTerm)

        sPdo1 = cDMSinkPdo1Array(self, 1, {'name': 'Sink PDO 1',
                                           'offset': 8,
                                           'bit length': 32,
                                           'Is Receive': True})

        self.dataModel.addChild(sPdo1)
        # need to figure out a more consistent approach, but can't initialize the value until it is placed in register
        sPdo1.getChildByName('Voltage').setFromInt(100)
        sPdo1.getChildByName('Supply Type').setFromInt(0)

        for i in range(2, 7):
            SnkPDOX = cDMAnySinkPdoArray(self, 1,
                                         {'name': 'Sink PDO %d' % i,
                                          'offset': 8 + ((i - 1) * 32),
                                          'bit length': 32,
                                          'No RDO Extensions': True})

            self.dataModel.addChild(SnkPDOX)

        self.dataModel.setDataModelGenerator(RxSinkCap_TopLevelDMGenerator)


########################################################################################################################
########################################################################################################################
########################################################################################################################


# nine arguments:
# [0] PP1 configuration
# [1] PP2 configuration
# [2] PP3 configuration
# [3] PP4 configuration
# [4] PP1 vbus
# [5] PP2 vbus
# [6] PP3 vbus
# [7] PP4 vbus
# [8] Number of PDOs
def switchSourceCheckFxn(self, argumentList, newValue):
    pp1 = argumentList[0].valueToInt()
    pp2 = argumentList[1].valueToInt()
    pp3 = argumentList[2].valueToInt()
    pp4 = argumentList[3].valueToInt()

    pp1_vbus = argumentList[4].valueToInt()
    pp2_vbus = argumentList[5].valueToInt()
    pp3_vbus = argumentList[6].valueToInt()
    pp4_vbus = argumentList[7].valueToInt()

    numPDO = argumentList[8].valueToInt()

    if self.pdoNumber > numPDO:
        # only check the active PDOs
        return {'check failed': False, \
                'message': None, \
                'change list': None, \
                }

    # backwards compatibility with older config tool releases
    if hasattr(self.register.device, 'portNumber'):
        myPort = self.register.device.portNumber
    else:
        myPort = None

    switchSetting_options_list = ['PP1 sources this PDO', 'PP2 sources this PDO', 'PP3 sources this PDO',
                                  'PP4 sources this PDO']

    ppSwitchList = ['PP Switch Disabled', 'PP Switch as Source Only (Output)', 'PP Switch as Sink Only (Input)',
                    'PP Switch as Sink Only, wait for SRDY', 'PP Switch as Sink or Source',
                    'PP Switch as Sink or Source, wait for SRDY']
    vbusMapList = ['VBUS 1', 'VBUS 2']

    if switchSetting_options_list[newValue] == 'PP1 sources this PDO':
        if ppSwitchList[pp1] in ['PP Switch as Source Only (Output)', 'PP Switch as Sink or Source',
                                 'PP Switch as Sink or Source, wait for SRDY']:
            returnVal = {'check failed': False, \
                         'message': None, \
                         'change list': None, \
                         }
        else:
            returnVal = {'check failed': True, \
                         'message': 'Setting Transmit Source Capabilities PDO switch source to PP1 requires that this switch be configured as an output in the System Configuration register.  Currently it is configured as: %s.' %
                                    ppSwitchList[pp1], \
                         'change list': [{'object': argumentList[0], \
                                          'valid setting list': [{'value': 1, 'description': ppSwitchList[1]}, \
                                                                 {'value': 4, 'description': ppSwitchList[4]}, \
                                                                 {'value': 5, 'description': ppSwitchList[5]}, \
                                                                 ] \
                                          }], \
                         }

        if pp1_vbus == myPort:
            return returnVal
        elif pp1_vbus == None:
            # backwards compatibility, don't check
            return returnVal
        else:
            if returnVal['check failed'] == False:
                return {'check failed': True, \
                        'message': 'Setting Transmit Source Capabilities PDO switch source to PP1 for this port (port %d) requires that this switch be mapped to %s.  Currently it is mapped to: %s.' % (
                        myPort, vbusMapList[myPort], vbusMapList[pp1_vbus]), \
                        'change list': [{'object': argumentList[4], \
                                         'valid setting list': [{'value': myPort, 'description': vbusMapList[myPort]}, ] \
                                         }], \
                        }
            else:
                returnVal[
                    'message'] += '  Additionally, setting Transmit Source Capabilities PDO switch source to PP1 for this port (port %d) requires that this switch be mapped to %s.  Currently it is mapped to: %s.' % (
                myPort, vbusMapList[myPort], vbusMapList[pp1_vbus])
                returnVal['change list'].append({'object': argumentList[4], \
                                                 'valid setting list': [
                                                     {'value': myPort, 'description': vbusMapList[myPort]}, ] \
                                                 })
                return returnVal

    elif switchSetting_options_list[newValue] == 'PP2 sources this PDO':
        if ppSwitchList[pp2] in ['PP Switch as Source Only (Output)', 'PP Switch as Sink or Source',
                                 'PP Switch as Sink or Source, wait for SRDY']:
            returnVal = {'check failed': False, \
                         'message': None, \
                         'change list': None, \
                         }
        else:
            returnVal = {'check failed': True, \
                         'message': 'Setting Transmit Source Capabilities PDO switch source to PP2 requires that this switch be configured as an output in the System Configuration register.  Currently it is configured as: %s' %
                                    ppSwitchList[pp2], \
                         'change list': [{'object': argumentList[1], \
                                          'valid setting list': [{'value': 1, 'description': ppSwitchList[1]}, \
                                                                 {'value': 4, 'description': ppSwitchList[4]}, \
                                                                 {'value': 5, 'description': ppSwitchList[5]}, \
                                                                 ] \
                                          }], \
                         }

        if pp2_vbus == myPort:
            return returnVal
        elif pp2_vbus == None:
            # backwards compatibility, don't check
            return returnVal
        else:
            if returnVal['check failed'] == False:
                return {'check failed': True, \
                        'message': 'Setting Transmit Source Capabilities PDO switch source to PP2 for this port (port %d) requires that this switch be mapped to %s.  Currently it is mapped to: %s.' % (
                        myPort, vbusMapList[myPort], vbusMapList[pp2_vbus]), \
                        'change list': [{'object': argumentList[5], \
                                         'valid setting list': [{'value': myPort, 'description': vbusMapList[myPort]}, ] \
                                         }], \
                        }
            else:
                returnVal[
                    'message'] += '  Additionally, setting Transmit Source Capabilities PDO switch source to PP2 for this port (port %d) requires that this switch be mapped to %s.  Currently it is mapped to: %s.' % (
                myPort, vbusMapList[myPort], vbusMapList[pp2_vbus])
                returnVal['change list'].append({'object': argumentList[5], \
                                                 'valid setting list': [
                                                     {'value': myPort, 'description': vbusMapList[myPort]}, ] \
                                                 })
                return returnVal

    elif switchSetting_options_list[newValue] == 'PP3 sources this PDO':
        if ppSwitchList[pp3] in ['PP Switch as Source Only (Output)', 'PP Switch as Sink or Source',
                                 'PP Switch as Sink or Source, wait for SRDY']:
            returnVal = {'check failed': False, \
                         'message': None, \
                         'change list': None, \
                         }
        else:
            returnVal = {'check failed': True, \
                         'message': 'Setting Transmit Source Capabilities PDO switch source to PP3 requires that this switch be configured as an output in the System Configuration register.  Currently it is configured as: %s' %
                                    ppSwitchList[pp3], \
                         'change list': [{'object': argumentList[2], \
                                          'valid setting list': [{'value': 1, 'description': ppSwitchList[1]}, \
                                                                 {'value': 4, 'description': ppSwitchList[4]}, \
                                                                 {'value': 5, 'description': ppSwitchList[5]}, \
                                                                 ] \
                                          }], \
                         }

        if pp3_vbus == myPort:
            return returnVal
        elif pp3_vbus == None:
            # backwards compatibility, don't check
            return returnVal
        else:
            if returnVal['check failed'] == False:
                return {'check failed': True, \
                        'message': 'Setting Transmit Source Capabilities PDO switch source to PP3 for this port (port %d) requires that this switch be mapped to %s.  Currently it is mapped to: %s.' % (
                        myPort, vbusMapList[myPort], vbusMapList[pp3_vbus]), \
                        'change list': [{'object': argumentList[6], \
                                         'valid setting list': [{'value': myPort, 'description': vbusMapList[myPort]}, ] \
                                         }], \
                        }
            else:
                returnVal[
                    'message'] += '  Additionally, setting Transmit Source Capabilities PDO switch source to PP3 for this port (port %d) requires that this switch be mapped to %s.  Currently it is mapped to: %s.' % (
                myPort, vbusMapList[myPort], vbusMapList[pp3_vbus])
                returnVal['change list'].append({'object': argumentList[6], \
                                                 'valid setting list': [
                                                     {'value': myPort, 'description': vbusMapList[myPort]}, ] \
                                                 })
                return returnVal


    elif switchSetting_options_list[newValue] == 'PP4 sources this PDO':
        if ppSwitchList[pp4] in ['PP Switch as Source Only (Output)', 'PP Switch as Sink or Source',
                                 'PP Switch as Sink or Source, wait for SRDY']:
            returnVal = {'check failed': False, \
                         'message': None, \
                         'change list': None, \
                         }
        else:
            returnVal = {'check failed': True, \
                         'message': 'Setting Transmit Source Capabilities PDO switch source to PP2 requires that this switch be configured as an output in the System Configuration register.  Currently it is configured as: %s' %
                                    ppSwitchList[pp4], \
                         'change list': [{'object': argumentList[3], \
                                          'valid setting list': [{'value': 1, 'description': ppSwitchList[1]}, \
                                                                 {'value': 4, 'description': ppSwitchList[4]}, \
                                                                 {'value': 5, 'description': ppSwitchList[5]}, \
                                                                 ] \
                                          }], \
                         }

        if pp4_vbus == myPort:
            return returnVal
        elif pp4_vbus == None:
            # backwards compatibility, don't check
            return returnVal
        else:
            if returnVal['check failed'] == False:
                return {'check failed': True, \
                        'message': 'Setting Transmit Source Capabilities PDO switch source to PP4 for this port (port %d) requires that this switch be mapped to %s.  Currently it is mapped to: %s.' % (
                        myPort, vbusMapList[myPort], vbusMapList[pp4_vbus]), \
                        'change list': [{'object': argumentList[7], \
                                         'valid setting list': [{'value': myPort, 'description': vbusMapList[myPort]}, ] \
                                         }], \
                        }
            else:
                returnVal[
                    'message'] += '  Additionally, setting Transmit Source Capabilities PDO switch source to PP4 for this port (port %d) requires that this switch be mapped to %s.  Currently it is mapped to: %s.' % (
                myPort, vbusMapList[myPort], vbusMapList[pp4_vbus])
                returnVal['change list'].append({'object': argumentList[7], \
                                                 'valid setting list': [
                                                     {'value': myPort, 'description': vbusMapList[myPort]}, ] \
                                                 })
                return returnVal

    else:
        return {'check failed': True, \
                'message': 'Unknown input option to switchSourceCheckFxn', \
                'change list': [{'object': None, \
                                 'valid setting list': None \
                                 }], \
                }


# display pdos based on numPdo
# not a method, but should be grouped with txSrcCap class
def TxSrcCap_TopLevelDMGenerator(self):
    HIDE_BANK_1 = False

    numSrcPdoB0 = self.getChildByName('Bank 0 Settings').getChildByName('Number of Bank 0 Source PDOs').valueToInt()
    numSrcPdoB1 = self.getChildByName('Bank 1 Settings').getChildByName('Number of Bank 1 Source PDOs').valueToInt()

    if HIDE_BANK_1:
        self.getChildByName('Bank 1 Settings').hide()
        self.getChildByName('Tx Source PDO Config').getChildByName('Active PDO Bank').hide()
        self.getChildByName('Tx Source PDO Config').getChildByName('Active PDO Bank Follows EP').hide()

    for i in range(7):
        if i < numSrcPdoB0:
            self.getChildByName('Bank 0 Settings').getChildByName('Source PDO %d' % (i + 1)).unhide()
        else:
            self.getChildByName('Bank 0 Settings').getChildByName('Source PDO %d' % (i + 1)).hide()

        if i < numSrcPdoB1:
            self.getChildByName('Bank 1 Settings').getChildByName('Source PDO %d' % (i + 1)).unhide()
        else:
            self.getChildByName('Bank 1 Settings').getChildByName('Source PDO %d' % (i + 1)).hide()

    return self.childrenAsListDMGenerator()


class cTxSrcCap_0x32_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Transmit Source Capabilities',
                                                 'address': 0x32,
                                                 'byte length': 64,
                                                 'permission': 'RW'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name': 'Transmit Source Capabilities',
                                                         'offset': 0,
                                                         'bit length': 512})

        SrcPdoConfig = register_class.cDataModelArray(self, 1,
                                                      {'name': 'Tx Source PDO Config',
                                                       'offset': 0,
                                                       'bit length': 24})

        self.dataModel.addChild(SrcPdoConfig)
        SrcPdoConfig.hide()

        activeBank = register_class.cListDMTerminator(self,
                                                      {'name': 'Active PDO Bank',
                                                       'offset': 16,
                                                       'bit length': 1})

        activeBank.setReportList(['Use Bank 0', 'Use Bank 1'])

        activeBankFV = register_class.cForceSetDMTerminator(self,
                                                            {'name': 'Active PDO Bank',
                                                             'offset': 16,
                                                             'bit length': 1,
                                                             'force value': int(0),
                                                             'force display': 'Bank 0',
                                                             'display widget': activeBank})

        activeBankFV.hide()
        SrcPdoConfig.addChild(activeBankFV)

        activeBankFollowsEP = register_class.cBooleanDMTerminator(self,
                                                                  {'name': 'Active PDO Bank Follows EP',
                                                                   'offset': 17,
                                                                   'bit length': 1})

        activeBankFollowsEPFV = register_class.cForceSetDMTerminator(self,
                                                                     {'name': 'Active PDO Bank Follows EP',
                                                                      'offset': 17,
                                                                      'bit length': 1,
                                                                      'force value': int(0),
                                                                      'force display': 'False',
                                                                      'display widget': activeBankFollowsEP})

        activeBankFollowsEPFV.hide()
        SrcPdoConfig.addChild(activeBankFollowsEPFV)

        sendPend = register_class.cBooleanDMTerminator(self,
                                                       {'name': 'Transmit Source Send Pending',
                                                        'offset': 23,
                                                        'bit length': 1})
        sendPend.hide()
        SrcPdoConfig.addChild(sendPend)

        b0settings = register_class.cDataModelArray(self, 2,
                                                    {'name': 'Bank 0 Settings',
                                                     'offset': 64,
                                                     'bit length': 224})

        self.dataModel.addChild(b0settings)

        numSrcPdo = register_class.cDecimalDMTerminator(self,
                                                        {'name': 'Number of Bank 0 Source PDOs',
                                                         'offset': 0,
                                                         'bit length': 3})

        numSrcPdo.help = """Number of valid Source PDOs that will be transmitted to the sink at the other end of the USB Type-C cable using USB-PD protocol. The PD Controller can transmit between 0 and 7 Source PDOs"""
        numSrcPdo.setFixedOffset(0)
        numSrcPdo.updateRegisters.append(self)

        b0settings.addChild(numSrcPdo)

        SrcPDO1SwitchSource = register_class.cListDMTerminator(self,
                                                               {'name': 'Switch Source',
                                                                'offset': 0,
                                                                'bit length': 2})

        SrcPDO1SwitchSource.help = """Select which power path will source this PDO."""
        SrcPDO1SwitchSource.setReportList(
            ['PP1 sources this PDO', 'PP2 sources this PDO', 'PP3 sources this PDO', 'PP4 sources this PDO'])
        SrcPDO1SwitchSource.setFixedOffset(32)
        # used in the checked field function
        SrcPDO1SwitchSource.pdoNumber = 1

        SrcPDO1SwitchSource.registerAsCheckedField(switchSourceCheckFxn,
                                                   [ \
                                                       ['Global System Configuration', 'PP 1 Switch Config'], \
                                                       ['Global System Configuration', 'PP 2 Switch Config'], \
                                                       ['Global System Configuration', 'PP 3 Switch Config'], \
                                                       ['Global System Configuration', 'PP 4 Switch Config'], \
                                                       ['Global System Configuration', 'PP1 Switch to VBUS Map'], \
                                                       ['Global System Configuration', 'PP2 Switch to VBUS Map'], \
                                                       ['Global System Configuration', 'PP3 Switch to VBUS Map'], \
                                                       ['Global System Configuration', 'PP4 Switch to VBUS Map'], \
                                                       ['self', 'Bank 0 Settings', 'Number of Bank 0 Source PDOs'], \
                                                       ])

        sPdo1 = cDMSourcePdo1Array(self, 1, {'name': 'Source PDO 1',
                                             'offset': 0,
                                             'bit length': 32})

        sPdo1.prependChild(SrcPDO1SwitchSource)
        b0settings.addChild(sPdo1)

        for i in range(2, 8):
            SrcPDOX = cDMAnySourcePdoArray(self, 1,
                                           {'name': 'Source PDO %d' % i,
                                            'offset': (i - 1) * 32,
                                            'bit length': 32})

            SrcPDOXAdvertised = register_class.cListDMTerminator(self,
                                                                 {'name': 'Advertised Mask',
                                                                  'offset': 0,
                                                                  'bit length': 1})

            SrcPDOXAdvertised.help = """Select when this PDO should be advertised to the far end device."""
            SrcPDOXAdvertised.setReportList(['Advertise only if Externally Powered', 'Always Advertise'])
            SrcPDOXAdvertised.setFixedOffset(8 + i)

            SrcPDOXSwitchSource = register_class.cListDMTerminator(self,
                                                                   {'name': 'Switch Source',
                                                                    'offset': 0,
                                                                    'bit length': 2})

            SrcPDOXSwitchSource.help = """Select which power path sources this PDO."""
            SrcPDOXSwitchSource.setMaxValue(3)
            SrcPDOXSwitchSource.setReportList(
                ['PP1 sources this PDO', 'PP2 sources this PDO', 'PP3 sources this PDO', 'PP4 sources this PDO'])
            SrcPDOXSwitchSource.setFixedOffset(30 + 2 * i)

            SrcPDOX.prependChild(SrcPDOXSwitchSource)
            SrcPDOX.prependChild(SrcPDOXAdvertised)

            # used in the checked field function
            SrcPDOXSwitchSource.pdoNumber = i

            SrcPDOXSwitchSource.registerAsCheckedField(switchSourceCheckFxn,
                                                       [ \
                                                           ['Global System Configuration', 'PP 1 Switch Config'], \
                                                           ['Global System Configuration', 'PP 2 Switch Config'], \
                                                           ['Global System Configuration', 'PP 3 Switch Config'], \
                                                           ['Global System Configuration', 'PP 4 Switch Config'], \
                                                           ['Global System Configuration', 'PP1 Switch to VBUS Map'], \
                                                           ['Global System Configuration', 'PP2 Switch to VBUS Map'], \
                                                           ['Global System Configuration', 'PP3 Switch to VBUS Map'], \
                                                           ['Global System Configuration', 'PP4 Switch to VBUS Map'], \
                                                           ['self', 'Bank 0 Settings', 'Number of Bank 0 Source PDOs'], \
                                                           ])

            b0settings.addChild(SrcPDOX)

        b1settings = register_class.cDataModelArray(self, 2,
                                                    {'name': 'Bank 1 Settings',
                                                     'offset': 288,
                                                     'bit length': 224})

        self.dataModel.addChild(b1settings)
        b1settings.hide()

        numSrcPdoB1 = register_class.cDecimalDMTerminator(self,
                                                          {'name': 'Number of Bank 1 Source PDOs',
                                                           'offset': 3,
                                                           'bit length': 3})

        numSrcPdoB1.help = """Number of valid Source PDOs that will be transmitted to the sink at the other end of the USB Type-C cable using USB-PD protocol. The PD Controller can transmit between 0 and 7 Source PDOs"""
        numSrcPdoB1.setFixedOffset(3)
        numSrcPdoB1.updateRegisters.append(self)

        b1settings.addChild(numSrcPdoB1)

        SrcPDO1SwitchSource = register_class.cListDMTerminator(self,
                                                               {'name': 'Switch Source',
                                                                'offset': 0,
                                                                'bit length': 2})

        SrcPDO1SwitchSource.help = """Select which power path will source this PDO."""
        SrcPDO1SwitchSource.setReportList(
            ['PP1 sources this PDO', 'PP2 sources this PDO', 'PP3 sources this PDO', 'PP4 sources this PDO'])
        SrcPDO1SwitchSource.setFixedOffset(48)

        # used in the checked field function
        SrcPDO1SwitchSource.pdoNumber = 1

        SrcPDO1SwitchSource.registerAsCheckedField(switchSourceCheckFxn,
                                                   [ \
                                                       ['Global System Configuration', 'PP 1 Switch Config'], \
                                                       ['Global System Configuration', 'PP 2 Switch Config'], \
                                                       ['Global System Configuration', 'PP 3 Switch Config'], \
                                                       ['Global System Configuration', 'PP 4 Switch Config'], \
                                                       ['Global System Configuration', 'PP1 Switch to VBUS Map'], \
                                                       ['Global System Configuration', 'PP2 Switch to VBUS Map'], \
                                                       ['Global System Configuration', 'PP3 Switch to VBUS Map'], \
                                                       ['Global System Configuration', 'PP4 Switch to VBUS Map'], \
                                                       ['self', 'Bank 1 Settings', 'Number of Bank 1 Source PDOs'], \
                                                       ])

        sPdo1 = cDMSourcePdo1Array(self, 1, {'name': 'Source PDO 1',
                                             'offset': 0,
                                             'bit length': 32})

        sPdo1.prependChild(SrcPDO1SwitchSource)
        b1settings.addChild(sPdo1)

        for i in range(2, 8):
            SrcPDOX = cDMAnySourcePdoArray(self, 1,
                                           {'name': 'Source PDO %d' % i,
                                            'offset': (i - 1) * 32,
                                            'bit length': 32})

            SrcPDOXAdvertised = register_class.cListDMTerminator(self,
                                                                 {'name': 'Advertised Mask',
                                                                  'offset': 0,
                                                                  'bit length': 1})

            SrcPDOXAdvertised.help = """Select when this PDO should be advertised to the far end device."""
            SrcPDOXAdvertised.setReportList(['Advertise only if Externally Powered', 'Always Advertise'])
            SrcPDOXAdvertised.setFixedOffset(8 + i)

            SrcPDOXSwitchSource = register_class.cListDMTerminator(self,
                                                                   {'name': 'Switch Source',
                                                                    'offset': 0,
                                                                    'bit length': 2})

            SrcPDOXSwitchSource.help = """Select which power path sources this PDO."""
            SrcPDOXSwitchSource.setMaxValue(3)
            SrcPDOXSwitchSource.setReportList(
                ['PP1 sources this PDO', 'PP2 sources this PDO', 'PP3 sources this PDO', 'PP4 sources this PDO'])
            SrcPDOXSwitchSource.setFixedOffset(46 + 2 * i)

            SrcPDOX.prependChild(SrcPDOXSwitchSource)
            SrcPDOX.prependChild(SrcPDOXAdvertised)

            # used in the checked field function
            SrcPDOXSwitchSource.pdoNumber = i

            SrcPDOXSwitchSource.registerAsCheckedField(switchSourceCheckFxn,
                                                       [ \
                                                           ['Global System Configuration', 'PP 1 Switch Config'], \
                                                           ['Global System Configuration', 'PP 2 Switch Config'], \
                                                           ['Global System Configuration', 'PP 3 Switch Config'], \
                                                           ['Global System Configuration', 'PP 4 Switch Config'], \
                                                           ['Global System Configuration', 'PP1 Switch to VBUS Map'], \
                                                           ['Global System Configuration', 'PP2 Switch to VBUS Map'], \
                                                           ['Global System Configuration', 'PP3 Switch to VBUS Map'], \
                                                           ['Global System Configuration', 'PP4 Switch to VBUS Map'], \
                                                           ['self', 'Bank 1 Settings', 'Number of Bank 1 Source PDOs'], \
                                                           ])

            b1settings.addChild(SrcPDOX)

        self.dataModel.setDataModelGenerator(TxSrcCap_TopLevelDMGenerator)


########################################################################################################################
########################################################################################################################
########################################################################################################################

def TxSinkCap_TopLevelDMGenerator(self):
    numSinkPdo = self.getChildByName('Sink PDO Count').getChildByName('Number of Sink PDOs').valueToInt()

    for i in range(6):
        if i < numSinkPdo:
            self.getChildByName('Sink PDO %d' % (i + 1)).unhide()
        else:
            self.getChildByName('Sink PDO %d' % (i + 1)).hide()

    return self.childrenAsListDMGenerator()


class cTxSinkCap_0x33_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Transmit Sink Capabilities',
                                                 'address': 0x33,
                                                 'byte length': 57,
                                                 'permission': 'RW'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name': 'Transmit Sink Capabilities',
                                                         'offset': 0,
                                                         'bit length': 456})

        SrcPdoConfig = register_class.cDataModelArray(self, 1,
                                                      {'name': 'Sink PDO Count',
                                                       'offset': 0,
                                                       'bit length': 8})

        self.dataModel.addChild(SrcPdoConfig)

        numSinkTerm = register_class.cDecimalDMTerminator(self,
                                                          {'name': 'Number of Sink PDOs',
                                                           'offset': 0,
                                                           'bit length': 3})
        numSinkTerm.help = """Number of valid sink PDOs that will be transmitted to the source at the other end of the USB Type-C cable using USB-PD protocol. The PD Controller can transmit between 0 and 7 Sink PDOs."""
        numSinkTerm.updateRegisters.append(self)

        # TODO: set max allowable value to 6 (instead of 0-7 from 3 bits)
        SrcPdoConfig.addChild(numSinkTerm)

        sPdo1 = cDMSinkPdo1Array(self, 1, {'name': 'Sink PDO 1',
                                           'offset': 8,
                                           'bit length': 32})

        self.dataModel.addChild(sPdo1)
        # need to figure out a more consistent approach, but can't initialize the value until it is placed in register
        sPdo1.getChildByName('Voltage').setFromInt(100)
        sPdo1.getChildByName('Supply Type').setFromInt(0)

        for i in range(2, 7):
            SnkPDOX = cDMAnySinkPdoArray(self, 1,
                                         {'name': 'Sink PDO %d' % i,
                                          'offset': 8 + ((i - 1) * 32),
                                          'bit length': 32})

            self.dataModel.addChild(SnkPDOX)

        self.dataModel.setDataModelGenerator(TxSinkCap_TopLevelDMGenerator)


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cActiveContractPDO_0x34_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Active Contract PDO',
                                                 'address': 0x34,
                                                 'byte length': 4,
                                                 'permission': 'DRO'})

        activePDO = cDMAnySourcePdoArray(self, 1,
                                         {'name': 'Active Contract PDO',
                                          'offset': 0,
                                          'bit length': 32})

        self.dataModel = activePDO


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cActiveContractRDO_0x35_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Active Contract RDO',
                                                 'address': 0x35,
                                                 'byte length': 4,
                                                 'permission': 'DRO'})
        # E.B. Not sure if RO or DO?

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'Active Contract RDO',
                                                         'offset': 0,
                                                         'bit length': 32})

        # E.B. Not sure how to populate this register (0x35) Active Contract RDO.

        maxOpCurrent = cPDOCurrentField(self, {'name': 'Max/Min Operating Current',
                                               'offset': 0,
                                               'bit length': 10})

        self.dataModel.addChild(maxOpCurrent)

        operatingCurrent = cPDOCurrentField(self, {'name': 'Operating Current',
                                                   'offset': 10,
                                                   'bit length': 10})

        self.dataModel.addChild(operatingCurrent)

        noUsbSuspend = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'No USB Suspend',
                                                            'offset': 24,
                                                            'bit length': 1})

        self.dataModel.addChild(noUsbSuspend)

        usbCommCap = register_class.cBooleanDMTerminator(self,
                                                         {'name': 'USB Communication Capable',
                                                          'offset': 25,
                                                          'bit length': 1})

        self.dataModel.addChild(usbCommCap)

        capMismatch = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'Capability Mismatch',
                                                           'offset': 26,
                                                           'bit length': 1})

        self.dataModel.addChild(capMismatch)

        giveback = register_class.cBooleanDMTerminator(self,
                                                       {'name': 'Giveback Flag',
                                                        'offset': 27,
                                                        'bit length': 1})

        self.dataModel.addChild(giveback)

        giveback = register_class.cDecimalDMTerminator(self,
                                                       {'name': 'Object Position',
                                                        'offset': 28,
                                                        'bit length': 3})

        self.dataModel.addChild(giveback)


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cSinkRequestRDO_0x36_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Sink Request RDO',
                                                 'address': 0x36,
                                                 'byte length': 4,
                                                 'permission': 'DRO'})
        # E.B. Not sure if RO or DO?

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'Sink Request RDO',
                                                         'offset': 0,
                                                         'bit length': 32})
        # E.B. Not sure how to populate this register (0x36) Active Contract RDO.

        maxOpCurrent = cPDOCurrentField(self, {'name': 'Max/Min Operating Current',
                                               'offset': 0,
                                               'bit length': 10})

        self.dataModel.addChild(maxOpCurrent)

        operatingCurrent = cPDOCurrentField(self, {'name': 'Operating Current',
                                                   'offset': 10,
                                                   'bit length': 10})

        self.dataModel.addChild(operatingCurrent)

        noUsbSuspend = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'No USB Suspend',
                                                            'offset': 24,
                                                            'bit length': 1})

        self.dataModel.addChild(noUsbSuspend)

        usbCommCap = register_class.cBooleanDMTerminator(self,
                                                         {'name': 'USB Communication Capable',
                                                          'offset': 25,
                                                          'bit length': 1})

        self.dataModel.addChild(usbCommCap)

        capMismatch = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'Capability Mismatch',
                                                           'offset': 26,
                                                           'bit length': 1})

        self.dataModel.addChild(capMismatch)

        giveback = register_class.cBooleanDMTerminator(self,
                                                       {'name': 'Giveback Flag',
                                                        'offset': 27,
                                                        'bit length': 1})

        self.dataModel.addChild(giveback)

        giveback = register_class.cDecimalDMTerminator(self,
                                                       {'name': 'Object Position',
                                                        'offset': 28,
                                                        'bit length': 3})

        self.dataModel.addChild(giveback)


########################################################################################################################
########################################################################################################################
########################################################################################################################


class cAutoNegSink_0x37_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Autonegotiate Sink',
                                                 'address': 0x37,
                                                 'byte length': 12,
                                                 'permission': 'RW'})

        self.FORCESETAUTONEG = True

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name': 'Autonegotitate Sink',
                                                         'offset': 0,
                                                         'bit length': 96})

        genSetting = register_class.cDataModelArray(self, 1,
                                                    {'name': 'General Settings',
                                                     'offset': 0,
                                                     'bit length': 32})

        self.dataModel.addChild(genSetting)

        if self.FORCESETAUTONEG == True:
            autoNegSinkDisp = register_class.cBooleanDMTerminator(self,
                                                                  {'name': 'Autonegotiate Sink Enable',
                                                                   'offset': 0,
                                                                   'bit length': 1})

            autoNegSinkDisp.help = """Auto Negotiate Fixed PDO below (Fixed PDO matching Non-Battery Parameters). This bit must be set for AutoNgtSnkVariable/Battery."""

            autoNegSink = register_class.cForceSetDMTerminator(self,
                                                               {'name': 'Autonegotiate Sink Enable',
                                                                'offset': 0,
                                                                'bit length': 1,
                                                                'force value': int(1),
                                                                'force display': 'Enabled',
                                                                'display widget': autoNegSinkDisp})
            autoNegSink.help = """Auto Negotiate Fixed PDO below (Fixed PDO matching Non-Battery Parameters). This bit must be set for AutoNgtSnkVariable/Battery."""
        else:
            autoNegSink = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Autonegotiate Sink Enable',
                                                               'offset': 0,
                                                               'bit length': 1})

            autoNegSink.help = """Auto Negotiate Fixed PDO below (Fixed PDO matching Non-Battery Parameters). This bit must be set for AutoNgtSnkVariable/Battery."""
        if self.FORCESETAUTONEG == True:
            autoNegVarSinkDisp = register_class.cBooleanDMTerminator(self,
                                                                     {'name': 'Autonegotiate Variable Sink Enable',
                                                                      'offset': 2,
                                                                      'bit length': 1})

            autoNegVarSinkDisp.help = """If the PD controller is connected to a device with a variable supply source, this bit should be enabled."""

            autoNegVarSink = register_class.cForceSetDMTerminator(self,
                                                                  {'name': 'Autonegotiate Variable Sink Enable',
                                                                   'offset': 2,
                                                                   'bit length': 1,
                                                                   'force value': int(1),
                                                                   'force display': 'Enabled',
                                                                   'display widget': autoNegVarSinkDisp})

        else:
            autoNegVarSink = register_class.cBooleanDMTerminator(self,
                                                                 {'name': 'Autonegotiate Variable Sink Enable',
                                                                  'offset': 2,
                                                                  'bit length': 1})

            autoNegVarSink.help = """If the PD controller is connected to a device with a variable supply source, this bit should be enabled."""
        if self.FORCESETAUTONEG == True:
            autoNegBatSinkDisp = register_class.cBooleanDMTerminator(self,
                                                                     {'name': 'Autonegotiate Battery Sink Enable',
                                                                      'offset': 1,
                                                                      'bit length': 1})

            autoNegBatSinkDisp.help = """if the PD Controller is connected to a battery powered source device, this bit should be enabled."""

            autoNegBatSink = register_class.cForceSetDMTerminator(self,
                                                                  {'name': 'Autonegotiate Battery Sink Enable',
                                                                   'offset': 1,
                                                                   'bit length': 1,
                                                                   'force value': int(1),
                                                                   'force display': 'Enabled',
                                                                   'display widget': autoNegBatSinkDisp})

            autoNegBatSink.help = """if the PD Controller is connected to a battery powered source device, this bit should be enabled."""
        else:
            autoNegBatSink = register_class.cBooleanDMTerminator(self,
                                                                 {'name': 'Autonegotiate Battery Sink Enable',
                                                                  'offset': 1,
                                                                  'bit length': 1})

            autoNegBatSink.help = """if the PD Controller is connected to a battery powered source device, this bit should be enabled."""
        genSetting.addChild(autoNegSink)
        genSetting.addChild(autoNegVarSink)
        genSetting.addChild(autoNegBatSink)
        if self.FORCESETAUTONEG == True:
            autoNegSink.setFromInt(1)
            autoNegVarSink.setFromInt(1)
            autoNegBatSink.setFromInt(1)

        USBCommCap = register_class.cBooleanDMTerminator(self,
                                                         {'name': 'USB Communication Capable',
                                                          'offset': 3,
                                                          'bit length': 1})

        USBCommCap.help = """The USB Communications Capable flag shall be set to one when the Sink has USB data lines and is capable of communicating using either [USB 2.0] or [USB 3.1] protocols. The USB Communications Capable flag shall be set to zero when the Sink does not have USB data lines or is otherwise incapable of communicating using either [USB 2.0] or [USB 3.1] protocols. This is used by the Source to determine operation in certain cases such as USB suspend. If the USB Communications Capable flag has been set to zero by a Sink then the Source needs to be aware that USB Suspend rules cannot be observed by the Sink."""
        genSetting.addChild(USBCommCap)

        offerPri = register_class.cListDMTerminator(self,
                                                    {'name': 'Offer Priority',
                                                     'offset': 4,
                                                     'bit length': 2})

        offerPri.help = """Select whether the PD Controller should give priority to Sink PDOs based on Voltage, Current, or Power."""
        offerPri.setReportList(['Choose Highest Current', 'Choose Highest Voltage', 'Choose Highest Power'])

        genSetting.addChild(offerPri)

        noUsbSusp = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'No USB Suspend',
                                                         'offset': 6,
                                                         'bit length': 1})

        noUsbSusp.help = """The No USB Suspend flag may be set by the Sink to indicate to the Source that this device is requesting to continue its Contract during USB Suspend. Sinks setting this flag typically have functionality that can use power for purposes other than USB communication e.g. for charging a Battery."""
        genSetting.addChild(noUsbSusp)

        giveBack = register_class.cBooleanDMTerminator(self,
                                                       {'name': 'Giveback Flag',
                                                        'offset': 7,
                                                        'bit length': 1})

        giveBack.help = """The GiveBack flag shall be set to indicate that the Sink will respond to a GotoMin Message by reducing its load to the Minimum Operating Current. It will typically be used by a USB Device while charging its Battery because a short interruption of the charge will have minimal impact on the user and will allow the Source to manage its load better."""
        genSetting.addChild(giveBack)

        pwrSetting = register_class.cDataModelArray(self, 1,
                                                    {'name': 'Power Settings',
                                                     'offset': 8,
                                                     'bit length': 24})

        self.dataModel.addChild(pwrSetting)

        acSinkMinPwr = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Auto Compute Sink Min Power',
                                                            'offset': 0,
                                                            'bit length': 1})
        acSinkMinPwr.help = """When this bit is set, PD Controller will automatically compute the minimum operating power \
                             required by the Sink based on the Sink PDOs stored in the TX Sink Capabilites Register (0x33) \
                             and store it in the 'Auto Negotiate Sink Min Required Power' field. The 'Auto Negotiate Sink Min Required Power' field \
                             is updated during the negotiation of a new contract. When it is not set, it will use th value store in \
                             'Auto Negotiate Sink Min Required Power' field as the minimum operating power required by the Sink."""
        pwrSetting.addChild(acSinkMinPwr)

        anSnkMinPwr = cPDOPowerField(self,
                                     {'name': 'Auto Negotiate Sink Min Required Power',
                                      'offset': 8,
                                      'bit length': 10})
        anSnkMinPwr.help = """Minimum operating power required by the Sink in 250mW increments. Typically, this field is set to \
                              the maximum power across the PDOs defined in the TX Sink Capabilities Register (0x33). \n\n
                              Note: If the TX Sink Capabilities Register includes Battery supply type PDO(s), then the maximum \
                              power of Battery PDOs should be considered even when Fixed supply and Variable supply PDOs of higher power are \
                              available. """
        pwrSetting.addChild(anSnkMinPwr)


########################################################################################################################
########################################################################################################################
########################################################################################################################


# four arguments:
# [0] display port svid enable
# [1] display port mode enable
# [2] thunderbolt svid enable
# [3] thunderbolt mode enable
def altmodeQueueSVID1(argumentList):
    if (argumentList[0].valueToInt() == 1) and (argumentList[1].valueToInt() == 1):
        DPIsSet = 1
    else:
        DPIsSet = 0

    if (argumentList[2].valueToInt() == 1) and (argumentList[3].valueToInt() == 1):
        TBTIsSet = 1
    else:
        TBTIsSet = 0

    if TBTIsSet == 1:
        return 0x8087
    elif DPIsSet == 1:
        return 0xFF01
    else:
        return 0


# four arguments:
# [0] display port svid enable
# [1] display port mode enable
# [2] thunderbolt svid enable
# [3] thunderbolt mode enable
def altmodeQueueMode1(argumentList):
    if (argumentList[0].valueToInt() == 1) and (argumentList[1].valueToInt() == 1):
        DPIsSet = 1
    else:
        DPIsSet = 0

    if (argumentList[2].valueToInt() == 1) and (argumentList[3].valueToInt() == 1):
        TBTIsSet = 1
    else:
        TBTIsSet = 0

    if TBTIsSet == 1:
        return 1
    elif DPIsSet == 1:
        return 1
    else:
        return 0


# four arguments:
# [0] display port svid enable
# [1] display port mode enable
# [2] thunderbolt svid enable
# [3] thunderbolt mode enable
def altmodeQueueSVID2(argumentList):
    if (argumentList[0].valueToInt() == 1) and (argumentList[1].valueToInt() == 1):
        DPIsSet = 1
    else:
        DPIsSet = 0

    if (argumentList[2].valueToInt() == 1) and (argumentList[3].valueToInt() == 1):
        TBTIsSet = 1
    else:
        TBTIsSet = 0

    if TBTIsSet == 1:
        if DPIsSet == 1:
            return 0xFF01
        else:
            return 0x0
    else:
        return 0


# four arguments:
# [0] display port svid enable
# [1] display port mode enable
# [2] thunderbolt svid enable
# [3] thunderbolt mode enable
def altmodeQueueMode2(argumentList):
    if (argumentList[0].valueToInt() == 1) and (argumentList[1].valueToInt() == 1):
        DPIsSet = 1
    else:
        DPIsSet = 0

    if (argumentList[2].valueToInt() == 1) and (argumentList[3].valueToInt() == 1):
        TBTIsSet = 1
    else:
        TBTIsSet = 0

    if TBTIsSet == 1:
        if DPIsSet == 1:
            return 1
        else:
            return 0
    else:
        return 0


class cAltModeEntryQueue_0x38_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Alternate Mode Entry Queue',
                                                 'address': 0x38,
                                                 'byte length': 16,
                                                 'permission': 'RW'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name': 'Alternate Mode Entry Queue',
                                                         'offset': 0,
                                                         'bit length': 128})

        # AM1
        AMrec1 = register_class.cDataModelArray(self, 1,
                                                {'name': 'Alternate Mode Entry Queue record #1',
                                                 'offset': 0,
                                                 'bit length': 32})

        self.dataModel.addChild(AMrec1)

        AQSvid = register_class.cHexDMTerminator(self, {'name': 'SVID (Standard or Vendor ID)',
                                                        'offset': 0,
                                                        'bit length': 16})

        AMrec1.addChild(AQSvid)

        # note, there is no update function, so this field must be locked, i.e. derived only
        AQSvid.registerAsDerivedField(altmodeQueueSVID1, None,
                                      [ \
                                          ['Display Port Capabilities', 'Enable Display Port SID'], \
                                          ['Display Port Capabilities', 'Enable Display Port Mode 1'], \
                                          ['Intel VID Config Register', 'Intel VID Config Set', 'Enable Intel VID'], \
                                          ['Intel VID Config Register', 'Intel VID Config Set',
                                           'Enable Intel Thunderbolt Mode'], \
                                          ])
        AQSvid.lock()

        AQMode = register_class.cHexDMTerminator(self, {'name': 'Mode Position',
                                                        'offset': 16,
                                                        'bit length': 8})

        AMrec1.addChild(AQMode)

        # note, there is no update function, so this field must be locked, i.e. derived only
        AQMode.registerAsDerivedField(altmodeQueueMode1, None,
                                      [ \
                                          ['Display Port Capabilities', 'Enable Display Port SID'], \
                                          ['Display Port Capabilities', 'Enable Display Port Mode 1'], \
                                          ['Intel VID Config Register', 'Intel VID Config Set', 'Enable Intel VID'], \
                                          ['Intel VID Config Register', 'Intel VID Config Set',
                                           'Enable Intel Thunderbolt Mode'], \
                                          ])
        AQMode.lock()

        limEntry1 = register_class.cForceSetDMTerminator(self, {'name': 'Limited Entry',
                                                                'offset': 24,
                                                                'bit length': 1,
                                                                'force value': int(0),
                                                                'force display': 'Enter on Both Ports'})

        AMrec1.addChild(limEntry1)
        limEntry1.setFromInt(0)

        # AM2
        AMrec2 = register_class.cDataModelArray(self, 1,
                                                {'name': 'Alternate Mode Entry Queue record #2',
                                                 'offset': 32,
                                                 'bit length': 32})

        self.dataModel.addChild(AMrec2)

        AQSvid = register_class.cHexDMTerminator(self, {'name': 'SVID (Standard or Vendor ID)',
                                                        'offset': 0,
                                                        'bit length': 16})

        AMrec2.addChild(AQSvid)

        # note, there is no update function, so this field must be locked, i.e. derived only
        AQSvid.registerAsDerivedField(altmodeQueueSVID2, None,
                                      [ \
                                          ['Display Port Capabilities', 'Enable Display Port SID'], \
                                          ['Display Port Capabilities', 'Enable Display Port Mode 1'], \
                                          ['Intel VID Config Register', 'Intel VID Config Set', 'Enable Intel VID'], \
                                          ['Intel VID Config Register', 'Intel VID Config Set',
                                           'Enable Intel Thunderbolt Mode'], \
                                          ])
        AQSvid.lock()

        AQMode = register_class.cHexDMTerminator(self, {'name': 'Mode Position',
                                                        'offset': 16,
                                                        'bit length': 8})

        AMrec2.addChild(AQMode)

        # note, there is no update function, so this field must be locked, i.e. derived only
        AQMode.registerAsDerivedField(altmodeQueueMode2, None,
                                      [ \
                                          ['Display Port Capabilities', 'Enable Display Port SID'], \
                                          ['Display Port Capabilities', 'Enable Display Port Mode 1'], \
                                          ['Intel VID Config Register', 'Intel VID Config Set', 'Enable Intel VID'], \
                                          ['Intel VID Config Register', 'Intel VID Config Set',
                                           'Enable Intel Thunderbolt Mode'], \
                                          ])
        AQMode.lock()

        limEntry2 = register_class.cForceSetDMTerminator(self, {'name': 'Limited Entry',
                                                                'offset': 24,
                                                                'bit length': 1,
                                                                'force value': int(0),
                                                                'force display': 'Enter on Both Ports'})

        AMrec2.addChild(limEntry2)
        limEntry2.setFromInt(0)

        # AM3
        AMrec3 = register_class.cDataModelArray(self, 1,
                                                {'name': 'Alternate Mode Entry Queue record #3',
                                                 'offset': 64,
                                                 'bit length': 32})

        self.dataModel.addChild(AMrec3)

        AQSvid = register_class.cForceSetDMTerminator(self, {'name': 'SVID (Standard or Vendor ID)',
                                                             'offset': 0,
                                                             'bit length': 16,
                                                             'force value': int(0),
                                                             'force display': '0x0'})

        AMrec3.addChild(AQSvid)
        AQSvid.setFromInt(0)

        AQMode = register_class.cForceSetDMTerminator(self, {'name': 'Mode Position',
                                                             'offset': 16,
                                                             'bit length': 8,
                                                             'force value': int(0),
                                                             'force display': '0x0'})

        AMrec3.addChild(AQMode)
        AQMode.setFromInt(0)

        limEntry3 = register_class.cForceSetDMTerminator(self, {'name': 'Limited Entry',
                                                                'offset': 24,
                                                                'bit length': 1,
                                                                'force value': int(0),
                                                                'force display': 'Enter on Both Ports'})

        AMrec3.addChild(limEntry3)
        limEntry3.setFromInt(0)

        # AM4
        AMrec4 = register_class.cDataModelArray(self, 1,
                                                {'name': 'Alternate Mode Entry Queue record #4',
                                                 'offset': 96,
                                                 'bit length': 32})

        self.dataModel.addChild(AMrec4)

        AQSvid = register_class.cForceSetDMTerminator(self, {'name': 'SVID (Standard or Vendor ID)',
                                                             'offset': 0,
                                                             'bit length': 16,
                                                             'force value': int(0),
                                                             'force display': '0x0'})

        AMrec4.addChild(AQSvid)
        AQSvid.setFromInt(0)

        AQMode = register_class.cForceSetDMTerminator(self, {'name': 'Mode Position',
                                                             'offset': 16,
                                                             'bit length': 8,
                                                             'force value': int(0),
                                                             'force display': '0x0'})

        AMrec4.addChild(AQMode)
        AQMode.setFromInt(0)

        limEntry4 = register_class.cForceSetDMTerminator(self, {'name': 'Limited Entry',
                                                                'offset': 24,
                                                                'bit length': 1,
                                                                'force value': int(0),
                                                                'force display': 'Enter on Both Ports'})

        AMrec4.addChild(limEntry4)
        limEntry4.setFromInt(0)

########################################################################################################################
########################################################################################################################
########################################################################################################################

class cPowerStatus_0x3F_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Power Status',
                                                 'address': 0x3F,
                                                 'byte length': 2,
                                                 'permission': 'DRO'})
        # E.B. Not sure if this should be RO or DO?

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'Power Status',
                                                         'offset': 0,
                                                         'bit length': 16})

        PowerConnection = register_class.cListDMTerminator(self,
                                                           {'name': 'Offer Priority',
                                                            'offset': 0,
                                                            'bit length': 1})

        PowerConnection.help = """1b when a connection is present. 0b when there is no connection to the PD Controller."""
        PowerConnection.setReportList(['No Connection', 'Connection Present'])
        self.dataModel.addChild(PowerConnection)

        SourceSink = register_class.cListDMTerminator(self,
                                                      {'name': 'Source or Sink',
                                                       'offset': 1,
                                                       'bit length': 1})

        SourceSink.help = """1b connection provides power (PD Controller as Sink). 0b connection requests power (PD Controller as Source)."""
        SourceSink.setReportList(['Source', 'Sink'])
        self.dataModel.addChild(SourceSink)

        TypeCCurrent = register_class.cListDMTerminator(self,
                                                        {'name': 'Type-C Current',
                                                         'offset': 2,
                                                         'bit length': 2})

        TypeCCurrent.help = """1b connection provides power (PD Controller as Sink). 0b connection requests power (PD Controller as Source)."""
        TypeCCurrent.setReportList(['USB Default Current', '1.5A Current', '3A Current', 'PD Contract Negotiated'])
        self.dataModel.addChild(TypeCCurrent)

        # deletec this section
        #        BC12Detection = register_class.cListDMTerminator(self,
        #                                                          {'name' : 'BC 1.2 Detection',
        #                                                           'offset' : 4,
        #                                                           'bit length' : 1 })
        #
        #        BC12Detection.help = """Determines if a BC 1.2 connection has been established on the Type-C port."""
        #        BC12Detection.setReportList(['USB BC v1.2 connection not yet established', 'USB BC v1.2 connection valid'])
        #        self.dataModel.addChild(BC12Detection)
        #
        #        BC12Status = register_class.cListDMTerminator(self,
        #                                                          {'name' : 'BC 1.2 Status',
        #                                                           'offset' : 5,
        #                                                           'bit length' : 2 })
        #
        #        BC12Status.help = """Displays the status of the BC1.2 Connection."""
        #        BC12Status.setReportList(['SDP Detected', 'Reserved', 'CDP Detected', 'DCP Detected'])
        #        self.dataModel.addChild(BC12Status)

        ChargerDetectStatus = register_class.cListDMTerminator(self,
                                                               {'name': 'Charger Detect Status',
                                                                'offset': 4,
                                                                'bit length': 4})

        ChargerDetectStatus.help = """Displays the status of charger detection."""
        ChargerDetectStatus.setReportList(['Disabled or Not Run', 'In Progress', 'None', 'SDP',
                                           'BC 1.2 CDP', 'BC 1.2 DCP', 'Divider 1 DCP', 'Divider 2 DCP',
                                           'Divider 3 DCP', '1.2V DCP', 'Reserved', 'Reserved',
                                           'Reserved', 'Reserved', 'Reserved', 'Reserved'])
        self.dataModel.addChild(ChargerDetectStatus)

        ChargerAdvertiseStatus = register_class.cListDMTerminator(self,
                                                                  {'name': 'Charger Advertise Status',
                                                                   'offset': 8,
                                                                   'bit length': 2})

        ChargerAdvertiseStatus.help = """Displays the status of charger advertisement."""
        ChargerAdvertiseStatus.setReportList(['Disabled or Not Run', 'In Progress', 'Complete', 'Reserved'])
        self.dataModel.addChild(ChargerAdvertiseStatus)


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cPDStatus_0x40_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'PD Status',
                                                 'address': 0x40,
                                                 'byte length': 4,
                                                 'permission': 'DRO'})
        # E.B. Not sure if this should be RO or DO?

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'PD Status',
                                                         'offset': 0,
                                                         'bit length': 32})

        PlugDetails = register_class.cListDMTerminator(self,
                                                       {'name': 'Plug Details',
                                                        'offset': 0,
                                                        'bit length': 2})

        PlugDetails.help = """Displays details of the Type-C Plug."""
        PlugDetails.setReportList(['USB Type-C full-featured plug', 'USB 2.0 Type-C plug'])
        PlugDetails.setMaxValue(1)
        self.dataModel.addChild(PlugDetails)

        CCPullUp = register_class.cListDMTerminator(self,
                                                    {'name': 'CC Pull-up',
                                                     'offset': 2,
                                                     'bit length': 2})

        CCPullUp.help = """CC Pull-up value detected by PD Controller when in CC Pull-down mode"""
        CCPullUp.setReportList(
            ['Not in CC pull-down mode / no CC pull-up detected.', 'USB Default Current', '1.5A Current', '3A Current'])
        CCPullUp.setMaxValue(3)
        self.dataModel.addChild(CCPullUp)

        PortType = register_class.cListDMTerminator(self,
                                                    {'name': 'Port Type',
                                                     'offset': 4,
                                                     'bit length': 2})

        PortType.help = """The PD Sink/Source role PD Controller is acting under."""
        PortType.setReportList(['Sink/Source', 'Sink', 'Source', 'Source/Sink'])
        PortType.setMaxValue(3)
        self.dataModel.addChild(PortType)

        PresentRole = register_class.cListDMTerminator(self,
                                                       {'name': 'Present Role',
                                                        'offset': 6,
                                                        'bit length': 1})

        PresentRole.help = """The PD source/sink role PD Controller is acting under."""
        PresentRole.setReportList(['Sink', 'Source'])
        PresentRole.setMaxValue(1)
        self.dataModel.addChild(PresentRole)

        SoftResetType = register_class.cListDMTerminator(self,
                                                         {'name': 'Soft Reset Details',
                                                          'offset': 8,
                                                          'bit length': 5})

        SoftResetType.help = """Displays details as to why a Soft Reset event occurred."""
        SoftResetType.setReportList(['Reset value, no soft reset', \
                                     'Soft reset received from far-end device.', \
                                     'Reserved', \
                                     'Soft reset sent, a GoodCRC was expected but something else was received', \
                                     'Soft reset sent because the received source capabilities message was invalid', \
                                     'Soft reset sent after retries were exhausted.', \
                                     'Soft reset sent due to receiving an accept message unexpectedly.', \
                                     'Reserved', \
                                     'Soft reset sent due to receiving a GetSinkCap message unexpectedly.', \
                                     'Soft reset sent due to receiving a GetSourceCap message unexpectedly.', \
                                     'Soft reset sent due to receiving a GotoMin message unexpectedly', \
                                     'Soft reset sent due to receiving a PS_RDY message unexpectedly.', \
                                     'Soft reset sent due to receiving a Ping message unexpectedly.', \
                                     'Soft reset sent due to receiving a Reject message unexpectedly.', \
                                     'Soft reset sent due to receiving a Request message unexpectedly.', \
                                     'Soft reset sent due to receiving a Sink Capabilities message unexpectedly', \
                                     'Soft reset sent due to receiving a Source Capabilities message unexpectedly', \
                                     'Soft reset sent due to receiving a Swap message unexpectedly.', \
                                     'Soft reset sent due to receiving a Wait Capabilities message unexpectedly', \
                                     'Soft reset sent due to receiving an unknown control message', \
                                     'Soft reset sent due to receiving an unknown data message.', \
                                     'Soft reset sent to initialize SOP Prime controller in plug', \
                                     'Soft reset sent to initialize SOP Double Prime controller in plug', \
                                     ])
        SoftResetType.setMaxValue(23)
        self.dataModel.addChild(SoftResetType)

        HardResetDetails = register_class.cListDMTerminator(self,
                                                            {'name': 'Hard Reset Details',
                                                             'offset': 16,
                                                             'bit length': 6})

        HardResetDetails.help = """Displays details as to why a Hard Reset event occurred."""
        HardResetDetails.setReportList(['Reset value, no hard reset.', \
                                        'Required by the policy engine (signaling sent by far end).', \
                                        'Requested by host.', \
                                        'Invalid DR_Swap request during Active Mode', \
                                        'Required by policy engine, DischargeFailed', \
                                        'Required by policy engine, NoResponseTimeOut', \
                                        'Required by policy engine, SendSoftReset', \
                                        'Required by policy engine, Sink_SelectCapability.', \
                                        'Required by policy engine, Sink_TransitionSink.', \
                                        'Required by policy engine, Sink_WaitForCapabilities', \
                                        'Required by policy engine, SoftReset.', \
                                        'Required by policy engine, SourceOnTimeout', \
                                        'Required by policy engine, Source_CapabilityResponse', \
                                        'Required by policy engine, Source_SendCapabilities', \
                                        'Required by policy engine, SourcingFault', \
                                        'Required by policy engine, UnableToSource.', \
                                        ])
        HardResetDetails.setMaxValue(23)
        self.dataModel.addChild(HardResetDetails)


def GPIODMGenerator(self):
    muxMap = self.getChildByName('Multiplexing for GPIO %d pin' % self.offset).valueToInt()
    gpioAlt = gpioMuxHardwareMap[self.offset]

    eventListNum = self.getChildByName('Mapped Event').valueToInt()
    if eventListNum < len(self.register.GPIOEventDictList) and (eventListNum >= 0):
        inout = self.register.GPIOEventDictList[eventListNum]['inout']
    else:
        if eventListNum == -1:
            inout = 'output'
        else:
            inout = 'neither'

    if muxMap > 0:
        self.getChildByName('Output Enable').hide()
        self.getChildByName('Interrupt Enable').hide()
        self.getChildByName('Initial Value').hide()
        self.getChildByName('Open Drain Output Enable').hide()
        self.getChildByName('Internal Pull Down Enable').hide()
        self.getChildByName('Internal Pull Up Enable').hide()
        self.getChildByName('GPIO Polarity').hide()
        self.getChildByName('Mapped Event').hide()
    elif inout == 'output':
        self.getChildByName('Output Enable').hide()
        self.getChildByName('Interrupt Enable').hide()
        self.getChildByName('Initial Value').unhide()
        self.getChildByName('Open Drain Output Enable').unhide()
        self.getChildByName('Internal Pull Down Enable').unhide()
        self.getChildByName('Internal Pull Up Enable').unhide()
        self.getChildByName('GPIO Polarity').unhide()
        self.getChildByName('Mapped Event').unhide()
    elif inout == 'input':
        self.getChildByName('Output Enable').hide()
        self.getChildByName('Interrupt Enable').hide()
        self.getChildByName('Initial Value').hide()
        self.getChildByName('Open Drain Output Enable').hide()
        self.getChildByName('Internal Pull Down Enable').unhide()
        self.getChildByName('Internal Pull Up Enable').unhide()
        self.getChildByName('GPIO Polarity').unhide()
        self.getChildByName('Mapped Event').unhide()
    else:
        self.getChildByName('Output Enable').hide()
        self.getChildByName('Interrupt Enable').hide()
        self.getChildByName('Initial Value').hide()
        self.getChildByName('Open Drain Output Enable').hide()
        self.getChildByName('Internal Pull Down Enable').hide()
        self.getChildByName('Internal Pull Up Enable').hide()
        self.getChildByName('GPIO Polarity').hide()
        self.getChildByName('Mapped Event').unhide()

    if (gpioAlt == 'I2C3' or gpioAlt == 'Derived I2C3') and muxMap > 0:
        self.getChildByName('Output Enable').setFromInt(1)
        self.getChildByName('Open Drain Output Enable').setFromInt(1)

    return self.childrenAsListDMGenerator()

def GPIOEventSetFromInt(self, listNum):
    if listNum >= len(self.register.GPIOEventDictList):
        listNum = -2

    if listNum == -1:
        self.parent.getChildByName('Output Enable').setFromInt(1)
        self.parent.getChildByName('Interrupt Enable').setFromInt(0)
        listNum = 0
        self.privateSetFromInt(listNum)
        return
    if listNum == -2:
        self.parent.getChildByName('Output Enable').setFromInt(0)
        self.parent.getChildByName('Interrupt Enable').setFromInt(0)
        listNum = 0
        self.privateSetFromInt(listNum)
        return

    if self.register.GPIOEventDictList[listNum]['inout'] == 'output':
        self.parent.getChildByName('Output Enable').setFromInt(1)
        self.parent.getChildByName('Interrupt Enable').setFromInt(0)
    elif self.register.GPIOEventDictList[listNum]['inout'] == 'input':
        self.parent.getChildByName('Output Enable').setFromInt(0)
        self.parent.getChildByName('Interrupt Enable').setFromInt(1)
    else:
        # neither
        self.parent.getChildByName('Output Enable').setFromInt(0)
        self.parent.getChildByName('Interrupt Enable').setFromInt(0)

    self.privateSetFromInt(listNum)


def GPIOEventValueToInt(self):
    # find the match to our GPIO
    # if there is no match and GPIO is enabled, this is -1 mapped without event
    #    if there is no match and GPIO is disabled, this is -2
    # So initialize as such and then search for match

    eventFromSearch = self.privateValueToInt()

    if eventFromSearch == 0:
        if self.parent.getChildByName('Output Enable').valueToInt() == 1:
            eventNum = -1
        else:
            eventNum = -2
    else:
        eventNum = eventFromSearch
        # Check to see if event has been seen for this GPIO before
        if self.parent.offset not in self.register.usedEvents or self.register.usedEvents[self.parent.offset] != eventNum:
            # This is a new event so save
            self.register.usedEvents[self.parent.offset] = eventNum
            # Reset any GPIOs that are also using this event
            reset = [gpio for gpio in sorted(self.register.usedEvents) if self.register.usedEvents[gpio] == eventNum and gpio != self.parent.offset]
            for gpioNum in reset:
                # Get GPIO from register by number
                gpioName = GPIONameGenerator(gpioNum)
                gpioFlags = self.register.dataModel.getChildByName(gpioName)
                gpio = gpioFlags.getChildByName('Mapped Event')
                # Reset GPIO
                gpio.setFromInt(-2)
                del self.register.usedEvents[gpioNum]
                # Rerun dataModelGenerator to comprehend updated event
                gpioFlags.dataModelGenerator()

    return eventNum


gpioMuxHardwareMap = { \
    0: "NONE", \
    1: "NONE", \
    2: "NONE", \
    3: "DP HPD Port 0", \
    4: "NONE", \
    5: "NONE", \
    6: "NONE", \
    7: "NONE", \
    8: "SPI MISO", \
    9: "SPI MOSI", \
    10: "SPI SCLK", \
    11: "SPI CS", \
    12: "SWD CLK", \
    13: "SWD DATA", \
    14: "PWM1", \
    15: "PWM2", \
    16: "PP3", \
    17: "NONE", \
    18: "BC1.2 Port 0", \
    19: "BC1.2 Port 0", \
    20: "NONE", \
    21: "NONE", \
    }


# 2 arguments
# argsList[0] = GPIO vs Alternate Function Mux
# argsList[1] = GPIO vs ADC Mux
def muxSettingfDerivedFxn(argsList):
    if argsList[0].valueToInt() == 1:
        return 2
    elif argsList[1].valueToInt() == 1:
        return 1
    else:
        return 0


# 2 arguments
# argsList[0] = GPIO vs Alternate Function Mux
# argsList[1] = GPIO vs ADC Mux
def muxSettingUpdateFxn(value, argsList):
    if value == 2:
        argsList[0].setFromInt(1)
        argsList[1].setFromInt(0)
    elif value == 1:
        argsList[0].setFromInt(0)
        argsList[1].setFromInt(1)
    else:
        argsList[0].setFromInt(0)
        argsList[1].setFromInt(0)


#  This covers the flag offsets
#  Have to append event record since it uses different offset structure
class cGPIOFlagOffsets(register_class.cDataModelArray):
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)

        hardware = gpioMuxHardwareMap[self.offset]

        muxSetting = register_class.cVirtualDictDMTerminator(self.register,
                                                             {'name': 'Multiplexing for GPIO %d pin' % self.offset,
                                                              'offset': 0,
                                                              'bit length': 2})

        if hardware == 'NONE':
            mux_setting_dict = {0x0: 'Pin Multiplexed to GPIO'}
            muxSetting.setMaxValue(0)
        else:
            mux_setting_dict = {0x0: 'Pin Multiplexed to GPIO',
                                0x2: 'Pin Multiplexed to Alternate Function (%s)' % hardware}
            muxSetting.setMaxValue(2)

        muxSetting.setReportDict(mux_setting_dict)

        if hardware != 'NONE':
            nameAppend = ' (%s)' % hardware
        else:
            nameAppend = ''

        gpioName = 'GPIO #%d%s' % (self.offset, nameAppend)

        muxSetting.registerAsDerivedField(muxSettingfDerivedFxn, muxSettingUpdateFxn,
                                          [ \
                                              ['self', gpioName, 'Map Pin to GPIO or Alternate Function'], \
                                              ['self', gpioName, 'GPIO Analog Input Control'], \
                                              ])

        muxSetting.addUpdateRegisterByName("self")
        self.addChild(muxSetting)

        gpioMux = register_class.cListDMTerminator(self.register,
                                                   {'name': 'Map Pin to GPIO or Alternate Function',
                                                    'offset': 128,
                                                    'bit length': 1})

        gpioMux.help = """Maps the GPIO Mux to either drive the GPIO signal or an alternate hardware signal."""
        gpioMux.addUpdateRegisterByName("self")
        gpioMux.setReportList(['GPIO', hardware])
        gpioMux.hide()

        if hardware == 'NONE':
            gpioMuxFS = register_class.cForceSetDMTerminator(self.register,
                                                             {'name': "Map Pin to GPIO or Alternate Function",
                                                              'offset': 128,
                                                              'bit length': 1,
                                                              'force value': int(0),
                                                              'force display': 'GPIO',
                                                              'display widget': gpioMux})
            gpioMuxFS.addUpdateRegisterByName("self")
            gpioMuxFS.hide()
            self.addChild(gpioMuxFS)
        else:
            self.addChild(gpioMux)

        enable = register_class.cBooleanDMTerminator(self.register,
                                                     {'name': 'Output Enable',
                                                      'offset': 0,
                                                      'bit length': 1})

        enable.help = """Enable this GPIO to be mapped to an event."""
        self.addChild(enable)

        intEnable = register_class.cBooleanDMTerminator(self.register,
                                                        {'name': 'Interrupt Enable',
                                                         'offset': 32,
                                                         'bit length': 1})

        intEnable.help = """Enable this GPIO to trigger an I2C interrupt."""
        self.addChild(intEnable)

        initData = register_class.cDataModelTerminator(self.register,
                                                       {'name': 'Initial Value',
                                                        'offset': 64,
                                                        'bit length': 1})

        initData.help = """Set an Initial Value for this GPIO."""
        self.addChild(initData)

        openDrain = register_class.cBooleanDMTerminator(self.register,
                                                        {'name': 'Open Drain Output Enable',
                                                         'offset': 96,
                                                         'bit length': 1})

        openDrain.help = """Set this GPIO to be Open Drain output."""
        self.addChild(openDrain)

        intPullDown = register_class.cBooleanDMTerminator(self.register,
                                                          {'name': 'Internal Pull Down Enable',
                                                           'offset': 160,
                                                           'bit length': 1})

        intPullDown.help = """Enable an internal pull down on this GPIO."""
        self.addChild(intPullDown)

        intPullUp = register_class.cBooleanDMTerminator(self.register,
                                                        {'name': 'Internal Pull Up Enable',
                                                         'offset': 192,
                                                         'bit length': 1})

        intPullUp.help = """Enable an internal pull up on this GPIO."""
        self.addChild(intPullUp)

        aic = register_class.cListDMTerminator(self.register,
                                               {'name': 'GPIO Analog Input Control',
                                                'offset': 224,
                                                'bit length': 1})

        aic.setReportList(['Pin to GPIO', 'Pin to ADC'])
        aic.help = """Controls the GPIO/ADC Mux for Given Pin."""
        aic.hide()

        aicForceSet = register_class.cForceSetDMTerminator(self.register,
                                                           {'name': "GPIO Analog Input Control",
                                                            'offset': 224,
                                                            'bit length': 1,
                                                            'force value': int(0),
                                                            'force display': 'Pin to GPIO',
                                                            'display widget': aic})

        # AIC only available for Pins [0:17]
        if self.offset < 18:
            self.addChild(aicForceSet)
        else:
            reserved = register_class.cForceSetDMTerminator(self.register,
                                                            {'name': "GPIO Analog Input Control",
                                                             'offset': 224,
                                                             'bit length': 1,
                                                             'force value': int(0),
                                                             'force display': 'Reserved, Set 0',
                                                             'display widget': aic})
            reserved.hide()
            self.addChild(reserved)

        # we don't have a real offset, but use as index to find correct mapping
        event = register_class.cDictDMTerminator(self.register,
                                                 {'name': 'Mapped Event',
                                                  'offset': 0,
                                                  'bit length': 8})

        event.help = """Select which event to map this GPIO to."""
        event.setFixedOffset(256 + (self.offset * 8))

        event.setReportDict(self.register.eventReportDict)
        event.setReplaceDict(self.register.eventReplaceDict)

        # add hook to set ouput enable or interrupt enable as necessary
        event.setMethodSetFromInt(GPIOEventSetFromInt)
        event.setMethodValueToInt(GPIOEventValueToInt)

        event.addUpdateRegisterByName("self")

        self.addChild(event)

        gpioPolarity = register_class.cListDMTerminator(self.register,
                                                        {'name': 'GPIO Polarity',
                                                         'offset': 480,
                                                         'bit length': 1})
        gpioPolarity.setReportList(['Direct-mapped Event', 'Inverted Event'])
        self.addChild(gpioPolarity)

        self.setDataModelGenerator(GPIODMGenerator)


GPIOEventDictList = [
    {'name': 'Disabled', 'inout': 'neither'},
    {'name': 'Output Enabled Without Event', 'inout': 'output'},
    {'name': 'reserved', 'inout': 'neither'},
    {'name': 'Port 0 Plug Event', 'inout': 'output', 'number': 1},
    {'name': 'Port 1 Plug Event', 'inout': 'output', 'number': 2},
    {'name': 'Port 0 Cable Orientation Event', 'inout': 'output', 'number': 3},
    {'name': 'Port 1 Cable Orientation Event', 'inout': 'output', 'number': 4},
    {'name': 'Port 0 AMSEL Event', 'inout': 'output', 'number': 5},
    {'name': 'Port 1 AMSEL Event', 'inout': 'output', 'number': 6},
    {'name': 'Port 0 Source PDO 0 Negotiated', 'inout': 'output', 'number': 7},
    {'name': 'Port 0 Source PDO 1 Negotiated', 'inout': 'output', 'number': 8},
    {'name': 'Port 0 Source PDO 2 Negotiated', 'inout': 'output', 'number': 9},
    {'name': 'Port 0 Source PDO 3 Negotiated', 'inout': 'output', 'number': 10},
    {'name': 'Port 0 Source PDO Negotiated TT 1', 'inout': 'output', 'number': 11},
    {'name': 'Port 0 Source PDO Negotiated TT 2', 'inout': 'output', 'number': 12},
    {'name': 'Port 0 Source PDO Negotiated TT 3', 'inout': 'output', 'number': 13},
    {'name': 'Port 1 Source PDO 0 Negotiated', 'inout': 'output', 'number': 14},
    {'name': 'Port 1 Source PDO 1 Negotiated', 'inout': 'output', 'number': 15},
    {'name': 'Port 1 Source PDO 2 Negotiated', 'inout': 'output', 'number': 16},
    {'name': 'Port 1 Source PDO 3 Negotiated', 'inout': 'output', 'number': 17},
    {'name': 'Port 1 Source PDO Negotiated TT 1', 'inout': 'output', 'number': 18},
    {'name': 'Port 1 Source PDO Negotiated TT 2', 'inout': 'output', 'number': 19},
    {'name': 'Port 1 Source PDO Negotiated TT 3', 'inout': 'output', 'number': 20},
    {'name': 'reserved', 'inout': 'input', 'number': 21},
    {'name': 'reserved', 'inout': 'input', 'number': 22},
    {'name': 'reserved', 'inout': 'input', 'number': 23},
    {'name': 'reserved', 'inout': 'input', 'number': 24},
    {'name': 'reserved', 'inout': 'input', 'number': 25},
    {'name': 'reserved', 'inout': 'input', 'number': 26},
    {'name': 'reserved', 'inout': 'input', 'number': 27},
    {'name': 'reserved', 'inout': 'input', 'number': 28},
    {'name': 'reserved', 'inout': 'output', 'number': 29},
    {'name': 'reserved', 'inout': 'output', 'number': 30},
    {'name': 'reserved', 'inout': 'output', 'number': 31},
    {'name': 'reserved', 'inout': 'output', 'number': 32},
    {'name': 'reserved', 'inout': 'output', 'number': 33},
    {'name': 'reserved', 'inout': 'output', 'number': 34},
    {'name': 'reserved', 'inout': 'output', 'number': 35},
    {'name': 'reserved', 'inout': 'output', 'number': 36},
    {'name': 'reserved', 'inout': 'output', 'number': 37},
    {'name': 'reserved', 'inout': 'output', 'number': 38},
    {'name': 'Port 0 USB3 Event', 'inout': 'output', 'number': 39},
    {'name': 'Port 1 USB3 Event', 'inout': 'output', 'number': 40},
    {'name': 'Port 0 DP Mode Select Event', 'inout': 'output', 'number': 41},
    {'name': 'Port 1 DP Mode Select Event', 'inout': 'output', 'number': 42},
    {'name': 'Port 0 User SVID Active Event', 'inout': 'output', 'number': 43},
    {'name': 'Port 1 User SVID Active Event', 'inout': 'output', 'number': 44},
    {'name': 'Port 0 Source Sink Event', 'inout': 'output', 'number': 45},
    {'name': 'Port 1 Source Sink Event', 'inout': 'output', 'number': 46},
    {'name': 'Port 0 DP or USB3 Event', 'inout': 'output', 'number': 47},
    {'name': 'Port 1 DP or USB3 Event', 'inout': 'output', 'number': 48},
    {'name': 'Port 0 UFP DFP Event', 'inout': 'output', 'number': 49},
    {'name': 'Port 1 UFP DFP Event', 'inout': 'output', 'number': 50},
    {'name': 'reserved', 'inout': 'output', 'number': 51},
    {'name': 'reserved', 'inout': 'output', 'number': 52},
    {'name': 'Port 0 Billboard Event', 'inout': 'output', 'number': 53},
    {'name': 'Port 1 Billboard Event', 'inout': 'output', 'number': 54},
    {'name': 'Port 0 Fault Input Event', 'inout': 'input', 'number': 55},
    {'name': 'Port 1 Fault Input Event', 'inout': 'input', 'number': 56},
    {'name': 'Port 0 FRSwap Input Event', 'inout': 'input', 'number': 57},
    {'name': 'Port 1 FRSwap Input Event', 'inout': 'input', 'number': 58},
    {'name': 'Port 0 FaultZ Output Event', 'inout': 'output', 'number': 59},
    {'name': 'Port 1 FaultZ Output Event', 'inout': 'output', 'number': 60},
    {'name': 'Port 0 Load App Config 1 Event', 'inout': 'input', 'number': 61},
    {'name': 'Port 1 Load App Config 1 Event', 'inout': 'input', 'number': 62},
    {'name': 'Port 0 Load App Config 2 Event', 'inout': 'input', 'number': 63},
    {'name': 'Port 1 Load App Config 2 Event', 'inout': 'input', 'number': 64},
    {'name': 'Port 0 Load App Config 3 Event', 'inout': 'input', 'number': 65},
    {'name': 'Port 1 Load App Config 3 Event', 'inout': 'input', 'number': 66},
    {'name': 'Port 0 Sink Greater Than Threshold Event', 'inout': 'output', 'number': 67},
    {'name': 'Port 1 Sink Greater Than Threshold Event', 'inout': 'output', 'number': 68},
    {'name': 'reserved', 'inout': 'output', 'number': 69},
    {'name': 'reserved', 'inout': 'output', 'number': 70},
    {'name': 'reserved', 'inout': 'output', 'number': 71},
    {'name': 'reserved', 'inout': 'output', 'number': 72},
    {'name': 'reserved', 'inout': 'output', 'number': 73},
    {'name': 'reserved', 'inout': 'neither'},
    {'name': 'reserved', 'inout': 'input', 'number': 75},
    {'name': 'Barrel Jack Detect Event', 'inout': 'input', 'number': 76},
    {'name': 'reserved', 'inout': 'output', 'number': 77},
    {'name': 'reserved', 'inout': 'input', 'number': 78},
    {'name': 'reserved', 'inout': 'output', 'number': 79},
    {'name': 'reserved', 'inout': 'input', 'number': 80},
    {'name': 'Port 0 Power Source On PC Event', 'inout': 'output', 'number': 81},
    {'name': 'Port 1 Power Source On PC Event', 'inout': 'output', 'number': 82},
    {'name': 'Port 0 Power Source ILimit Input Event', 'inout': 'input', 'number': 83},
    {'name': 'Port 1 Power Source ILimit Input Event', 'inout': 'input', 'number': 84},
    {'name': 'Port 0 Audio Accessory Event', 'inout': 'output', 'number': 85},
    {'name': 'Port 1 Audio Accessory Event', 'inout': 'output', 'number': 86},
    {'name': 'Port 0 Source Power Greater Than Threshold', 'inout': 'output', 'number': 87},
    {'name': 'Port 1 Source Power Greater Than Threshold', 'inout': 'output', 'number': 88},
    {'name': 'Port 0 Debug Accessory Event', 'inout': 'output', 'number': 89},
    {'name': 'Port 1 Debug Accessory Event', 'inout': 'output', 'number': 90},
    {'name': 'Port 0 Sink PDO 0 Negotiated', 'inout': 'output', 'number': 91},
    {'name': 'Port 0 Sink PDO 1 Negotiated', 'inout': 'output', 'number': 92},
    {'name': 'Port 0 Sink PDO 2 Negotiated', 'inout': 'output', 'number': 93},
    {'name': 'Port 0 Sink PDO 3 Negotiated', 'inout': 'output', 'number': 94},
    {'name': 'Port 0 Sink PDO Negotiated TT 1', 'inout': 'output', 'number': 95},
    {'name': 'Port 0 Sink PDO Negotiated TT 2', 'inout': 'output', 'number': 96},
    {'name': 'Port 0 Sink PDO Negotiated TT 3', 'inout': 'output', 'number': 97},
    {'name': 'Port 1 Sink PDO 0 Negotiated', 'inout': 'output', 'number': 98},
    {'name': 'Port 1 Sink PDO 1 Negotiated', 'inout': 'output', 'number': 99},
    {'name': 'Port 1 Sink PDO 2 Negotiated', 'inout': 'output', 'number': 100},
    {'name': 'Port 1 Sink PDO 3 Negotiated', 'inout': 'output', 'number': 101},
    {'name': 'Port 1 Sink PDO Negotiated TT 1', 'inout': 'output', 'number': 102},
    {'name': 'Port 1 Sink PDO Negotiated TT 2', 'inout': 'output', 'number': 103},
    {'name': 'Port 1 Sink PDO Negotiated TT 3', 'inout': 'output', 'number': 104},
    {'name': 'Port 0 VCONN On', 'inout': 'output', 'number': 105},
    {'name': 'Port 1 VCONN On', 'inout': 'output', 'number': 106},
    {'name': 'Port 0 FRS Armed Source Event', 'inout': 'output', 'number': 107},
    {'name': 'Port 1 FRS Armed Source Event', 'inout': 'output', 'number': 108},
    {'name': 'Port 0 FRS Armed Sink Event', 'inout': 'output', 'number': 109},
    {'name': 'Port 1 FRS Armed Sink Event', 'inout': 'output', 'number': 110},
    {'name': 'Port 0 FRS VBus Discharge Event', 'inout': 'output', 'number': 111},
    {'name': 'Port 1 FRS VBus Discharge Event', 'inout': 'output', 'number': 112},
    {'name': 'PP1 Switch Event', 'inout': 'output', 'number': 113},
    {'name': 'PP2 Switch Event', 'inout': 'output', 'number': 114},
    {'name': 'Port 0 I2C1 Maser IRQ Event', 'inout': 'input', 'number': 115},
    {'name': 'Port 1 I2C1 Maser IRQ Event', 'inout': 'input', 'number': 116},
    {'name': 'Port 0 I2C3 Maser IRQ Event', 'inout': 'input', 'number': 117},
    {'name': 'Port 1 I2C3 Maser IRQ Event', 'inout': 'input', 'number': 118},
    {'name': 'Port 0 Custom Entry Exit Event', 'inout': 'output', 'number': 119},
    {'name': 'Port 1 Custom Entry Exit Event', 'inout': 'output', 'number': 120},
    {'name': 'Port 0 USB2 On HS Mux Event', 'inout': 'output', 'number': 121},
    {'name': 'Port 1 USB2 On HS Mux Event', 'inout': 'output', 'number': 122},
    {'name': 'Port 0 Custom On HS Mux Event', 'inout': 'output', 'number': 123},
    {'name': 'Port 1 Custom On HS Mux Event', 'inout': 'output', 'number': 124},
    {'name': 'Sink Arbitration GPIO Output', 'inout': 'output', 'number': 125},
    {'name': 'Sink Arbitration GPIO Input', 'inout': 'input', 'number': 126},
]

def GPIONameGenerator(gpioNum):
    # Get base name
    gpioName = 'GPIO #%d' % (gpioNum)
    # Append alt function if it exists
    gpioAltFunction = gpioMuxHardwareMap[gpioNum]
    if gpioAltFunction not in ['NONE', 'Hidden Derived I2C3']:
        gpioName += ' (%s)' % gpioAltFunction
    # Return generated name
    return gpioName

########################################################################################################################
########################################################################################################################
########################################################################################################################

class cPD3_Status_0x41_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'PD3.0 Status',
                                                 'address': 0x41,
                                                 'byte length': 4,
                                                 'permission': 'DRO'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name': 'PD3.0 Status',
                                                         'offset': 0,
                                                         'bit length': 32})

        PD3_Status = register_class.cDataModelArray(self, 1,
                                                    {'name': 'PD3.0 Status',
                                                     'offset': 0,
                                                     'bit length': 32})

        self.dataModel.addChild(PD3_Status)

        NotSupportedRcvd = register_class.cDecimalDMTerminator(self,
                                                               {'name': 'Received Message not supported',
                                                                'offset': 0,
                                                                'bit length': 1})

        NotSupportedRcvd.updateRegisters.append(self)

        NotSupportedRcvd.help = """Not Supported Message received."""

        PD3_Status.addChild(NotSupportedRcvd)

        SrcCapExtRcvd = register_class.cDecimalDMTerminator(self,
                                                            {'name': 'Source Capabilities Received Message',
                                                             'offset': 1,
                                                             'bit length': 1})

        SrcCapExtRcvd.updateRegisters.append(self)

        SrcCapExtRcvd.help = """Source Capabilities Extended Message received."""

        PD3_Status.addChild(SrcCapExtRcvd)

        SecRspRcvd = register_class.cDecimalDMTerminator(self,
                                                         {'name': 'Security Response Received Message',
                                                          'offset': 2,
                                                          'bit length': 1})

        SecRspRcvd.updateRegisters.append(self)

        SecRspRcvd.help = """Security Response Message received."""

        PD3_Status.addChild(SecRspRcvd)

        SrcCapExtReqRcvd = register_class.cDecimalDMTerminator(self,
                                                               {'name': 'Get Source Capabilities Received Message',
                                                                'offset': 3,
                                                                'bit length': 1})

        SrcCapExtReqRcvd.updateRegisters.append(self)

        SrcCapExtReqRcvd.help = """Get Source Capabilities Extended Message received."""

        PD3_Status.addChild(SrcCapExtReqRcvd)

        SecReqRcvd = register_class.cDecimalDMTerminator(self,
                                                         {'name': 'Security Request Message received',
                                                          'offset': 4,
                                                          'bit length': 1})

        SecReqRcvd.updateRegisters.append(self)

        SecReqRcvd.help = """Security Request Message received."""

        PD3_Status.addChild(SecReqRcvd)

        PortPartnerNegSpecSVDMRev = register_class.cListDMTerminator(self,
                                                                     {'name': 'Port Partner Negotiation SVDM received',
                                                                      'offset': 23,
                                                                      'bit length': 2})

        PortPartnerNegSpecSVDMRev.setMaxValue(2)
        PortPartnerNegSpecSVDMRev.setReportList(
            ['PD Specification  revision 1', 'PD Specification revision 2', 'PD Specification revision 3'])
        PortPartnerNegSpecSVDMRev.setFixedOffset(2)

        PortPartnerNegSpecSVDMRev.updateRegisters.append(self)

        PortPartnerNegSpecSVDMRev.help = """Port partner negotiated SVDM specification revision."""
        PD3_Status.addChild(PortPartnerNegSpecSVDMRev)

        PlugPartnerNegSpecSVDMRev = register_class.cListDMTerminator(self,
                                                                     {'name': 'Plug Partner Negotiation SVDM received',
                                                                      'offset': 25,
                                                                      'bit length': 2})

        PlugPartnerNegSpecSVDMRev.setMaxValue(2)
        PlugPartnerNegSpecSVDMRev.setReportList(
            ['PD Specification  revision 1', 'PD Specification revision 2', 'PD Specification revision 3'])
        PlugPartnerNegSpecSVDMRev.setFixedOffset(2)

        PlugPartnerNegSpecSVDMRev.updateRegisters.append(self)

        PlugPartnerNegSpecSVDMRev.help = """Plug partner negotiated SVDM specification revision."""
        PD3_Status.addChild(PlugPartnerNegSpecSVDMRev)

        PortPartnerNegSpecRev = register_class.cListDMTerminator(self,
                                                                 {'name': 'Port Partner Negotiation received',
                                                                  'offset': 27,
                                                                  'bit length': 2})

        PortPartnerNegSpecRev.setMaxValue(2)
        PortPartnerNegSpecRev.setReportList(
            ['PD Specification  revision 1', 'PD Specification revision 2', 'PD Specification revision 3'])
        PortPartnerNegSpecRev.setFixedOffset(2)

        PortPartnerNegSpecRev.updateRegisters.append(self)

        PortPartnerNegSpecRev.help = """Port partner negotiated specification revision."""
        PD3_Status.addChild(PortPartnerNegSpecRev)

        PlugPartnerNegSpecRev = register_class.cListDMTerminator(self,
                                                                 {'name': 'Plug Partner Negotiation received',
                                                                  'offset': 29,
                                                                  'bit length': 2})

        PlugPartnerNegSpecRev.setMaxValue(2)
        PlugPartnerNegSpecRev.setReportList(
            ['PD Specification  revision 1', 'PD Specification revision 2', 'PD Specification revision 3'])
        PlugPartnerNegSpecRev.setFixedOffset(2)

        PlugPartnerNegSpecRev.updateRegisters.append(self)
        PlugPartnerNegSpecRev.help = """Plug partner negotiated specification revision."""
        PD3_Status.addChild(PlugPartnerNegSpecRev)

        UseUnchunkedMessages = register_class.cDecimalDMTerminator(self,
                                                                   {'name': 'Unchunked messages',
                                                                    'offset': 31,
                                                                    'bit length': 1})

        UseUnchunkedMessages.updateRegisters.append(self)

        UseUnchunkedMessages.help = """Unchunked messages are supported."""
        PD3_Status.addChild(UseUnchunkedMessages)


########################################################################################################################
########################################################################################################################
########################################################################################################################


class cEventDelay_0x43_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Event Delay',
                                                 'address': 0x43,
                                                 'byte length': 9,
                                                 'permission': 'RW'})

        self.setAsShared()

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'Event Delay',
                                                         'offset': 0,
                                                         'bit length': 72})

        muxDelay = cEventDelay500uSField(self,
                                         {'name': 'Ice Lake Mux Delay, DFP',
                                          'offset': 0,
                                          'bit length': 8})
        muxDelay.help = """Delay from entering safe state to sending mode configuration command."""

        forceMuxDelayDFP = register_class.cForceSetDMTerminator(self,
                                                                {'name': 'Ice Lake Mux Delay, DFP',
                                                                 'offset': 0,
                                                                 'bit length': 8,
                                                                 'force value': int(0x19),
                                                                 'force display': '12.5 mS',
                                                                 'display widget': muxDelay})
        forceMuxDelayDFP.help = """Delay from entering safe state to sending mode configuration command."""
        self.dataModel.addChild(forceMuxDelayDFP)

        muxDelayU = cEventDelay500uSField(self,
                                          {'name': 'Ice Lake Mux Delay, UFP',
                                           'offset': 8,
                                           'bit length': 8})
        muxDelayU.help = """Delay from entering mode configuration to ACK response."""

        forceMuxDelayUFP = register_class.cForceSetDMTerminator(self,
                                                                {'name': 'Ice Lake Mux Delay, UFP',
                                                                 'offset': 8,
                                                                 'bit length': 8,
                                                                 'force value': int(0x19),
                                                                 'force display': '12.5 mS',
                                                                 'display widget': muxDelayU})
        forceMuxDelayUFP.help = """Delay from entering mode configuration to ACK response."""
        self.dataModel.addChild(forceMuxDelayUFP)

        muxDelayDRS = cEventDelay500uSField(self,
                                            {'name': 'Ice Lake Mux Delay, DRS',
                                             'offset': 16,
                                             'bit length': 8})
        muxDelayDRS.help = """Delay after changing mux data role."""

        forceMuxDelayDRS = register_class.cForceSetDMTerminator(self,
                                                                {'name': 'Ice Lake Mux Delay, DRS',
                                                                 'offset': 16,
                                                                 'bit length': 8,
                                                                 'force value': int(0x19),
                                                                 'force display': '12.5 mS',
                                                                 'display widget': muxDelayDRS})
        forceMuxDelayDRS.help = """Delay after changing mux data role."""
        self.dataModel.addChild(forceMuxDelayDRS)

        hpdDelay = cEventDelay500uSField(self,
                                         {'name': 'Ice Lake HPD Delay',
                                          'offset': 24,
                                          'bit length': 8})
        hpdDelay.help = """HPD delay."""

        forceHpdDelay = register_class.cForceSetDMTerminator(self,
                                                             {'name': 'Ice Lake HPD Delay',
                                                              'offset': 24,
                                                              'bit length': 8,
                                                              'force value': int(0x19),
                                                              'force display': '12.5 mS',
                                                              'display widget': hpdDelay})
        forceHpdDelay.help = """HPD delay."""
        self.dataModel.addChild(forceHpdDelay)

        ufpConfDelay = cEventDelay500uSField(self,
                                             {'name': 'Ice Lake Mux Delay, UFP Config',
                                              'offset': 32,
                                              'bit length': 8})
        ufpConfDelay.help = """Delay for entering a new configuration."""

        forceUfpConfDelay = register_class.cForceSetDMTerminator(self,
                                                                 {'name': 'Ice Lake HPD Delay',
                                                                  'offset': 32,
                                                                  'bit length': 8,
                                                                  'force value': int(0x19),
                                                                  'force display': '12.5 mS',
                                                                  'display widget': ufpConfDelay})
        forceUfpConfDelay.help = """Delay for entering a new configuration."""
        self.dataModel.addChild(forceUfpConfDelay)

        connDelay = cEventDelay500uSField(self,
                                          {'name': 'Ice Lake Connection Delay',
                                           'offset': 40,
                                           'bit length': 8})
        connDelay.help = """Delay for entering a new configuration."""

        forceUfpConfDelay = register_class.cForceSetDMTerminator(self,
                                                                 {'name': 'Ice Lake Connection Delay',
                                                                  'offset': 40,
                                                                  'bit length': 8,
                                                                  'force value': int(0x19),
                                                                  'force display': '12.5 mS',
                                                                  'display widget': connDelay})
        forceUfpConfDelay.help = """Delay for entering a new configuration."""
        self.dataModel.addChild(forceUfpConfDelay)

        retimeDelay = cEventDelay250uSField(self,
                                            {'name': 'Ice Lake Retimer Delay',
                                             'offset': 48,
                                             'bit length': 8})
        retimeDelay.help = """Ice Lake retimer delay."""
        self.dataModel.addChild(retimeDelay)

        forceUfpConfDelay = register_class.cForceSetDMTerminator(self,
                                                                 {'name': 'Ice Lake Retimer Delay',
                                                                  'offset': 48,
                                                                  'bit length': 8,
                                                                  'force value': int(0x32),
                                                                  'force display': '12.5 mS',
                                                                  'display widget': connDelay})
        forceUfpConfDelay.help = """Delay for entering a new configuration."""
        self.dataModel.addChild(forceUfpConfDelay)


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cDPStatus(register_class.cDataModelArray):
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)

        DUConn_List = ['Neither DFP_D or UFP_D connected', 'DFP_D is connected', 'UFP_D is connected',
                       'Both DFP_D and UFP_D are connected']
        PowerLow_List = ['Adapter is functioning normally or disabled',
                         'Adapter has detected low power and DP is disabled']
        DPDisabledEnabled_List = ['DP functionality is Disabled', 'DP functionality is enabled']
        MFPref_List = ['No Preference for Multi-function', 'Multi-function preferred']
        USBConf_List = ['Maintain current configuration', 'Request switch to USB Configuration']
        DPExit_List = ['Maintain current mode', 'Request exit from DisplayPort Mode']
        HPDState_List = ['HPD_Low', 'HPD_High']
        IRQHPD_List = ['No IRQ_HPD since last status', 'IRQ_HPD']

        dDuDconn = register_class.cListDMTerminator(self.register,
                                                    {'name': 'Connection Status',
                                                     'offset': 0,
                                                     'bit length': 2})

        dDuDconn.setReportList(DUConn_List)
        self.addChild(dDuDconn)

        powLow = register_class.cListDMTerminator(self.register,
                                                  {'name': 'Power Low',
                                                   'offset': 2,
                                                   'bit length': 1})

        powLow.setReportList(PowerLow_List)
        self.addChild(powLow)

        enabled = register_class.cListDMTerminator(self.register,
                                                   {'name': 'Enabled',
                                                    'offset': 3,
                                                    'bit length': 1})

        enabled.setReportList(DPDisabledEnabled_List)
        self.addChild(enabled)

        mfp = register_class.cListDMTerminator(self.register,
                                               {'name': 'Multi-function Preferred',
                                                'offset': 4,
                                                'bit length': 1})

        mfp.setReportList(MFPref_List)
        self.addChild(mfp)

        usbConf = register_class.cListDMTerminator(self.register,
                                                   {'name': 'USB Configuration Request',
                                                    'offset': 5,
                                                    'bit length': 1})

        usbConf.setReportList(USBConf_List)
        self.addChild(usbConf)

        exitDP = register_class.cListDMTerminator(self.register,
                                                  {'name': 'Exit DisplayPort Mode Request',
                                                   'offset': 6,
                                                   'bit length': 1})

        exitDP.setReportList(DPExit_List)
        self.addChild(exitDP)

        hpdState = register_class.cListDMTerminator(self.register,
                                                    {'name': 'HPD State',
                                                     'offset': 7,
                                                     'bit length': 1})

        hpdState.setReportList(HPDState_List)
        self.addChild(hpdState)

        hpdState = register_class.cListDMTerminator(self.register,
                                                    {'name': 'IRQ HPD',
                                                     'offset': 8,
                                                     'bit length': 1})

        hpdState.setReportList(IRQHPD_List)
        self.addChild(hpdState)

        reserved = register_class.cForceSetDMTerminator(self.register, {'name': "reserved",
                                                                        'offset': 9,
                                                                        'bit length': 23,
                                                                        'force value': int(0),
                                                                        'force display': 'reserved'})

        reserved.setFromInt(0)
        reserved.hide()
        self.addChild(reserved)


class cDPConfig(register_class.cDataModelArray):
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)

        portCap = register_class.cListDMTerminator(self.register,
                                                   {'name': 'Select Configuration',
                                                    'offset': 0,
                                                    'bit length': 2})

        portCap.help = """DP Port Capability00b = Reserved01b = UFP_D-capable (including Branch device)10b = DFP_D-capable (including Branch device)11b = Both DFP_D and UFP_D-capable"""
        portCap.setReportList(['Set configuration for USB', 'Set configuration for UFP_U as DFP_D',
                               'Set configuration for UFP_U as UFP_D', 'Reserved'])

        self.addChild(portCap)

        dpSignalling = register_class.cBooleanDMTerminator(self.register,
                                                           {'name': 'Supports DP v1.3 signalling',
                                                            'offset': 2,
                                                            'bit length': 1})

        self.addChild(dpSignalling)

        usbSignalling = register_class.cBooleanDMTerminator(self.register,
                                                            {'name': 'Supports USB Gen 2 signalling',
                                                             'offset': 3,
                                                             'bit length': 1})

        self.addChild(usbSignalling)

        dfpdpins = register_class.cMultiBooleanDMTerminator(self.register,
                                                            {'name': 'DFPD Receptacle or UFPD Plug Pin Assignment',
                                                             'offset': 8,
                                                             'bit length': 8})
        dfpdpins.help = """Each bit corresponds to an allowed pin assignment. Multiple pin assignments may be allowed.00000000b = DFP pin assignments are not supported.xxxxxxx1b = Pin assignment A is supportedxxxxxx1xb = Pin assignment B is supportedxxxxx1xxb = Pin assignment C is supportedxxxx1xxxb = Pin assignment D is supportedxxx1xxxxb = Pin assignment E is supportedxx1xxxxxb = Pin assignment F is supportedx1xxxxxxb = Reserved1xxxxxxxb = Reserved"""
        dfpdpins.setFlagNameList(['A', 'B', 'C', 'D', 'E', 'F'])
        dfpdpins.setFlagMask([1, 1, 1, 1, 1, 1, 0, 0])
        dfpdpins.setSpacing(6)
        self.addChild(dfpdpins)

        ufpdpins = register_class.cMultiBooleanDMTerminator(self.register,
                                                            {'name': 'UFPD Receptacle or DFPD Plug Pin Assignment',
                                                             'offset': 16,
                                                             'bit length': 8})
        ufpdpins.help = """Each bit corresponds to an allowed pin assignment. Multiple pin assignments may be allowed.00000000b = UFP pin assignments are not supported.xxxxxxx1b = Pin assignment A is supportedxxxxxx1xb = Pin assignment B is supportedxxxxx1xxb = Pin assignment C is supportedxxxx1xxxb = Pin assignment D is supportedxxx1xxxxb = Pin assignment E is supportedxx1xxxxxb = Reservedx1xxxxxxb = Reserved1xxxxxxxb = Reserved"""
        ufpdpins.setFlagNameList(['A', 'B', 'C', 'D', 'E', 'F'])
        ufpdpins.setFlagMask([1, 1, 1, 1, 1, 0, 0, 0])
        ufpdpins.setSpacing(6)
        self.addChild(ufpdpins)

        reserved = register_class.cForceSetDMTerminator(self.register, {'name': "reserved",
                                                                        'offset': 24,
                                                                        'bit length': 8,
                                                                        'force value': int(0),
                                                                        'force display': 'reserved'})

        reserved.setFromInt(0)
        reserved.hide()
        self.addChild(reserved)


class cDPMode(register_class.cDataModelArray):
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)

        portCap = register_class.cListDMTerminator(self.register,
                                                   {'name': 'Port Capability',
                                                    'offset': 0,
                                                    'bit length': 2})

        portCap.help = """DP Port Capability00b = Reserved01b = UFP_D-capable (including Branch device)10b = DFP_D-capable (including Branch device)11b = Both DFP_D and UFP_D-capable"""
        portCap.setReportList(['Reserved', 'UFP_D capable', 'DFP_D capable', 'Both UFP_d and DFP_D capable'])

        self.addChild(portCap)

        dpSignalling = register_class.cBooleanDMTerminator(self.register,
                                                           {'name': 'Supports DP v1.3 signalling',
                                                            'offset': 2,
                                                            'bit length': 1})

        self.addChild(dpSignalling)

        usbSignalling = register_class.cBooleanDMTerminator(self.register,
                                                            {'name': 'Supports USB Gen 2 signalling',
                                                             'offset': 3,
                                                             'bit length': 1})

        self.addChild(usbSignalling)

        dfpdpins = register_class.cMultiBooleanDMTerminator(self.register,
                                                            {'name': 'DFPD Receptacle or UFPD Plug Pin Assignment',
                                                             'offset': 8,
                                                             'bit length': 8})
        dfpdpins.help = """Each bit corresponds to an allowed pin assignment. Multiple pin assignments may be allowed.00000000b = DFP pin assignments are not supported.xxxxxxx1b = Pin assignment A is supportedxxxxxx1xb = Pin assignment B is supportedxxxxx1xxb = Pin assignment C is supportedxxxx1xxxb = Pin assignment D is supportedxxx1xxxxb = Pin assignment E is supportedxx1xxxxxb = Pin assignment F is supportedx1xxxxxxb = Reserved1xxxxxxxb = Reserved"""
        dfpdpins.setFlagNameList(['A', 'B', 'C', 'D', 'E', 'F'])
        dfpdpins.setFlagMask([1, 1, 1, 1, 1, 1, 0, 0])
        dfpdpins.setSpacing(6)
        self.addChild(dfpdpins)

        ufpdpins = register_class.cMultiBooleanDMTerminator(self.register,
                                                            {'name': 'UFPD Receptacle or DFPD Plug Pin Assignment',
                                                             'offset': 16,
                                                             'bit length': 8})
        ufpdpins.help = """Each bit corresponds to an allowed pin assignment. Multiple pin assignments may be allowed.00000000b = UFP pin assignments are not supported.xxxxxxx1b = Pin assignment A is supportedxxxxxx1xb = Pin assignment B is supportedxxxxx1xxb = Pin assignment C is supportedxxxx1xxxb = Pin assignment D is supportedxxx1xxxxb = Pin assignment E is supportedxx1xxxxxb = Reservedx1xxxxxxb = Reserved1xxxxxxxb = Reserved"""
        ufpdpins.setFlagNameList(['A', 'B', 'C', 'D', 'E', 'F'])
        ufpdpins.setFlagMask([1, 1, 1, 1, 1, 0, 0, 0])
        ufpdpins.setSpacing(6)
        self.addChild(ufpdpins)

        reserved = register_class.cForceSetDMTerminator(self.register, {'name': "reserved",
                                                                        'offset': 24,
                                                                        'bit length': 8,
                                                                        'force value': int(0),
                                                                        'force display': 'reserved'})

        reserved.setFromInt(0)
        reserved.hide()
        self.addChild(reserved)


class cDPSIDStatus_0x58_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'DP SID Status',
                                                 'address': 0x58,
                                                 'byte length': 17,
                                                 'permission': 'DRO'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name': 'DP SID Status',
                                                         'offset': 0,
                                                         'bit length': 136})

        DPSIDDetected = register_class.cListDMTerminator(self,
                                                         {'name': 'DP SID Detected',
                                                          'offset': 0,
                                                          'bit length': 1})
        DPSIDDetected.setReportList(
            ['DP SID not detected', 'Far-end DFP_U has issued DP SID SVDM or UFP_U has responded with ACK'])

        DPSIDDetected.help = """0 (DFP_U/ UFP_U) - DP SID not detected\n\n 1 (DFP_U) - UFP_U returned to DP SID in Discover SVIDs response or responded with ACK to DP SID SVDM Commands\n\n 1 (UFP_U) - DFP_U has issued DP SID SVDM (DIscover Modes, Enter Modes, etc)."""
        self.dataModel.addChild(DPSIDDetected)

        DPModeActive = register_class.cHexDMTerminator(self,
                                                       {'name': 'DP Mode Active',
                                                        'offset': 1,
                                                        'bit length': 1})
        DPModeActive.help = """0 (DFP_U/ UFP_U) - DP SID not active \n\n1 (DFP_U) - PD Controller has entered DisplayPort Mode with attached UFP_U \n\n1 (UFP-U) - Attached DFP_U has entered DisplayPort Mode"""
        self.dataModel.addChild(DPModeActive)

        errorCode = register_class.cHexDMTerminator(self,
                                                    {'name': 'Error Code',
                                                     'offset': 2,
                                                     'bit length': 3})
        errorCode.help = """Error Code."""
        self.dataModel.addChild(errorCode)

        DPStatusTX = cDPStatus(self, 1,
                               {'name': 'DP Status TX',
                                'offset': 8,
                                'bit length': 32})
        DPStatusTX.help = """Current Outgoing DP Status message contents"""
        self.dataModel.addChild(DPStatusTX)

        DPStatusRX = cDPStatus(self, 1,
                               {'name': 'DP Status RX',
                                'offset': 40,
                                'bit length': 32})
        DPStatusRX.help = """Most recently received DP Status message contents"""
        self.dataModel.addChild(DPStatusRX)

        DPConfigure = cDPConfig(self, 1,
                                {'name': 'DP Configure',
                                 'offset': 72,
                                 'bit length': 32})
        DPConfigure.help = """Contents of DP Configure message when sent (DFP_U) or received (UFP_U)."""
        self.dataModel.addChild(DPConfigure)

        DPModeData = cDPMode(self, 1,
                             {'name': 'DP Mode Data',
                              'offset': 104,
                              'bit length': 32})
        DPModeData.help = """Contents of DP Discover Mode response when received (DFP_U) or sent (UFP_U)."""
        self.dataModel.addChild(DPModeData)


########################################################################################################################
########################################################################################################################
########################################################################################################################


class cTBTEnterMode(register_class.cDataModelArray):
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)

        TBTCableSpeedSupport = register_class.cListDMTerminator(self.register,
                                                                {'name': 'Thunderbolt Cable Speed Support',
                                                                 'offset': 0,
                                                                 'bit length': 3})

        TBTCableSpeedSupport.help = """Displays if a power mismatch has occurred."""
        TBTCableSpeedSupport.setReportList(
            ['Reserved', 'USB3.1 gen1 cable (10Gb/s Thunderbolt support)', '10Gb/s only', '10Gb/s & 20Gb/s only'])
        TBTCableSpeedSupport.setMaxValue(3)
        self.addChild(TBTCableSpeedSupport)

        TBTCableGen = register_class.cListDMTerminator(self.register,
                                                       {'name': 'Thunderbolt Cable Gen',
                                                        'offset': 3,
                                                        'bit length': 2})

        TBTCableGen.help = """Displays if a power mismatch has occurred."""
        TBTCableGen.setReportList(['3rd generation TBT (10.3125 and 20.625 Gb/s)',
                                   '4th generation TBT (10.0, 10.3125, 20.0 and 20.625 Gb/s)'])
        TBTCableGen.setMaxValue(1)
        self.addChild(TBTCableGen)

        CableType = register_class.cListDMTerminator(self.register,
                                                     {'name': 'Cable Type',
                                                      'offset': 5,
                                                      'bit length': 1})

        CableType.help = """Status of the Thunderbolt Connection."""
        CableType.setReportList(['Type-C to Type-C Cable', 'Legacy Adapter'])
        self.addChild(CableType)

        activeCable = register_class.cListDMTerminator(self.register,
                                                       {'name': 'Active Cable',
                                                        'offset': 6,
                                                        'bit length': 1})

        CableType.help = """Status of the Thunderbolt Connection."""
        CableType.setReportList(['Active Cable', 'Passive Cable'])
        self.addChild(activeCable)

        ActiveLinkTraining = register_class.cListDMTerminator(self.register,
                                                              {'name': 'Active Link Training',
                                                               'offset': 7,
                                                               'bit length': 1})

        ActiveLinkTraining.help = """Status of Active Link Training connection."""
        ActiveLinkTraining.setReportList(
            ['Active with bi-directional LSRX communication (also used for passive cables)',
             'Active with uni-directional LSRX communication'])
        self.addChild(ActiveLinkTraining)

        legacy = register_class.cListDMTerminator(self.register,
                                                  {'name': 'Legacy TBT Adapter',
                                                   'offset': 8,
                                                   'bit length': 1})

        legacy.setReportList(['Is Not a Legacy Adapter', 'Is a Legacy Adapter'])

        self.addChild(legacy)


class cTBTSOPResponse(register_class.cDataModelArray):
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)

        legacy = register_class.cListDMTerminator(self.register,
                                                  {'name': 'Legacy TBT Adapter',
                                                   'offset': 0,
                                                   'bit length': 1})

        legacy.setReportList(['Is Not a Legacy Adapter', 'Is a Legacy Adapter'])

        self.addChild(legacy)


class cTBTSOPPrimeResponse(register_class.cDataModelArray):
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)

        TBTCableSpeedSupport = register_class.cListDMTerminator(self.register,
                                                                {'name': 'Thunderbolt Cable Speed Support',
                                                                 'offset': 0,
                                                                 'bit length': 3})

        TBTCableSpeedSupport.help = """Displays if a power mismatch has occurred."""
        TBTCableSpeedSupport.setReportList(
            ['Reserved', 'USB3.1 gen1 cable (10Gb/s Thunderbolt support)', '10Gb/s only', '10Gb/s & 20Gb/s only'])
        TBTCableSpeedSupport.setMaxValue(3)
        self.addChild(TBTCableSpeedSupport)

        TBTCableGen = register_class.cListDMTerminator(self.register,
                                                       {'name': 'Thunderbolt Cable Gen',
                                                        'offset': 3,
                                                        'bit length': 2})

        TBTCableGen.help = """Displays if a power mismatch has occurred."""
        TBTCableGen.setReportList(['3rd generation TBT (10.3125 and 20.625 Gb/s)',
                                   '4th generation TBT (10.0, 10.3125, 20.0 and 20.625 Gb/s)'])
        TBTCableGen.setMaxValue(1)
        self.addChild(TBTCableGen)

        CableType = register_class.cListDMTerminator(self.register,
                                                     {'name': 'Cable Type',
                                                      'offset': 5,
                                                      'bit length': 1})

        CableType.help = """Status of the Thunderbolt Connection."""
        CableType.setReportList(['Type-C to Type-C Cable', 'Legacy Adapter'])
        self.addChild(CableType)

        activeCable = register_class.cListDMTerminator(self.register,
                                                       {'name': 'Active Cable',
                                                        'offset': 6,
                                                        'bit length': 1})

        CableType.help = """Status of the Thunderbolt Connection."""
        CableType.setReportList(['Active Cable', 'Passive Cable'])
        self.addChild(activeCable)

        ActiveLinkTraining = register_class.cListDMTerminator(self.register,
                                                              {'name': 'Active Link Training',
                                                               'offset': 7,
                                                               'bit length': 1})

        ActiveLinkTraining.help = """Status of Active Link Training connection."""
        ActiveLinkTraining.setReportList(
            ['Active with bi-directional LSRX communication (also used for passive cables)',
             'Active with uni-directional LSRX communication'])
        self.addChild(ActiveLinkTraining)


class cIntelVIDStatus_0x59_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Intel VID Status',
                                                 'address': 0x59,
                                                 'byte length': 11,
                                                 'permission': 'DRO'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name': 'Intel VID Status',
                                                         'offset': 0,
                                                         'bit length': 88})

        self.hide()

        IntelVIDDetected = register_class.cHexDMTerminator(self,
                                                           {'name': 'Intel VID Detected',
                                                            'offset': 0,
                                                            'bit length': 1})
        IntelVIDDetected.help = """(DFP) UFP returned Intel VID in Discover SVIDs response or responded with ACK to Intel VID SVDM Commands\n\n(UFP) DFP has issued Intel VID SVDM (Discover Modes, Enter Mode, etc)"""
        self.dataModel.addChild(IntelVIDDetected)

        thunderboltModeActive = register_class.cHexDMTerminator(self,
                                                                {'name': 'Thunderbolt Mode Active',
                                                                 'offset': 1,
                                                                 'bit length': 1})
        thunderboltModeActive.help = """(DFP) PD Controller has entered Thunderbolt Mode with attached UFP\n\n(UFP) Attached DFP has entered Thunderbolt Mode """
        self.dataModel.addChild(thunderboltModeActive)

        errorCode = register_class.cHexDMTerminator(self,
                                                    {'name': 'Error Code',
                                                     'offset': 2,
                                                     'bit length': 3})
        errorCode.help = """Error Code"""
        self.dataModel.addChild(errorCode)

        TBTAttentionData = register_class.cHexDMTerminator(self,
                                                           {'name': 'TBT Attention Data',
                                                            'offset': 8,
                                                            'bit length': 32})
        TBTAttentionData.help = """Contents of Attention VDO in Thunderbolt Mode when sent (UFP) or received (DFP)"""
        self.dataModel.addChild(TBTAttentionData)

        TBTEnterModeData = cTBTEnterMode(self, 1,
                                         {'name': 'TBT Enter Mode Data',
                                          'offset': 40,
                                          'bit length': 16})
        TBTEnterModeData.help = """Upper 16 bits of second VDO to Thunderbolt Enter Mode command when sent (DFP) or received (UFP)"""
        self.dataModel.addChild(TBTEnterModeData)

        TBTDiscoverModeDataSOP = cTBTSOPResponse(self, 1,
                                                 {'name': 'TBT Discover Mode Data SOP',
                                                  'offset': 56,
                                                  'bit length': 16})
        TBTDiscoverModeDataSOP.help = """Upper 16 bits of SOP Discover Modes response for TBT Mode when received (DFP) or sent (UFP). Lower 16 bits of the response are always 0x0001. \n\nNOTE: In the UFP role, this register simply copies the contents of the Intel VID Configuration register bits 23:8 at the time the Discover Modes response is generated."""
        self.dataModel.addChild(TBTDiscoverModeDataSOP)

        TBTDiscoverModeDataSOPP = cTBTSOPPrimeResponse(self, 1,
                                                       {'name': 'TBT Discover Mode Data SOPP',
                                                        'offset': 72,
                                                        'bit length': 16})
        TBTDiscoverModeDataSOPP.help = """Upper 16 bits of SOP' Discover Modes Cable response for TBT Mode. Lower 16 bits of the response are always 0x0001 """
        self.dataModel.addChild(TBTDiscoverModeDataSOPP)


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cIOConfig_0x5C_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'I/O Config',
                                                 'address': 0x5C,
                                                 'byte length': 64,
                                                 'permission': 'RO'})

        self.setAsShared()
        self.NumMappableGPIO = 22

        # remove the first "no enabled event" event
        self.GPIOEventDictList = GPIOEventDictList[2:]

        self.eventReportDict = {}
        self.eventReplaceDict = {}
        self.usedEvents = {}

        for (i, eventDict) in enumerate(GPIOEventDictList):
            if GPIOEventDictList[i]['name'] != 'reserved':
                self.eventReportDict[i - 2] = GPIOEventDictList[i]['name']
        #            else:
        #                self.eventReplaceDict[i-2]= -2

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name': 'GPIO Event Map',
                                                         'offset': 0,
                                                         'bit length': 512})

        # 8-11 are SPI lines
        # 12-13 are SWD
        # 16, 17 are external switch control
        self.analogMuxGPIOList = [8, 9, 10, 11]

        for i in range(self.NumMappableGPIO):
            gpioName = GPIONameGenerator(i)
            gpioFlags = cGPIOFlagOffsets(self, 1,
                                         {'name': gpioName,
                                          'offset': i,
                                          'bit length': 480})

            self.dataModel.addChild(gpioFlags)
            if i not in self.analogMuxGPIOList:
                gpioFlags.unhide()
            else:
                gpioFlags.hide()


########################################################################################################################
########################################################################################################################
########################################################################################################################


class cMiscellaneous_0x5E_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Miscellaneous Configuration',
                                                 'address': 0x5E,
                                                 'byte length': 64,
                                                 'permission': 'RW'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name': 'Miscellaneous Configuration',
                                                         'offset': 0,
                                                         'bit length': 512})

        misc = register_class.cDataModelArray(self, 1,
                                              {'name': 'Miscellaneous Configuration',
                                               'offset': 0,
                                               'bit length': 32})

        self.dataModel.addChild(misc)

        hpdGpio = register_class.cListDMTerminator(self,
                                                   {'name': 'DP Hot Plug Detect GPIO',
                                                    'offset': 3,
                                                    'bit length': 2})

        hpdGpio.help = """Select which GPIO is used for Hot Plug Detect for DisplayPort Alternate Mode."""
        hpdGpio.setReportList(
            ['GPIO 4 is HPD Transmit', 'GPIO 5 is HPD Transmit', 'GPIO 4 is HPD Transmit, GPIO 5 is Receive',
             'GPIO 4 is HPD Transmit and Receive'])

        misc.addChild(hpdGpio)

        extRMReset = register_class.cBooleanDMTerminator(self,
                                                         {'name': 'External Reset from MReset',
                                                          'offset': 8,
                                                          'bit length': 1})

        extRMReset.help = """Enable the ability to reset the PD Controller from the MReset pin."""
        misc.addChild(extRMReset)

        extRPolarity = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'External Reset Polarity',
                                                            'offset': 9,
                                                            'bit length': 1})

        extRPolarity = """Select the Polarity of the external reset signal."""
        misc.addChild(extRPolarity)

        igCRCMis = register_class.cBooleanDMTerminator(self,
                                                       {'name': 'Ignore Good CRC Mismatch',
                                                        'offset': 17,
                                                        'bit length': 1})

        igCRCMis.help = """When this bit is set to 1, the PD Controller will ignore Good CRC message ID mismatch. When this bit is set to 0, the PD Controller will generate an interrupt for Good CRC message ID mismatch"""
        misc.addChild(igCRCMis)

        Lock3V3 = register_class.cBooleanDMTerminator(self,
                                                      {'name': 'Lock 3V3 Output',
                                                       'offset': 19,
                                                       'bit length': 1})

        Lock3V3.help = """When this bit is set to 1, the PD Controller will lock VOUT_3V3 voltage on at all times when VOUT_3V3 is also enabled in #Vout3V3enable.When this bit is set to 0, VOUT_3V3 will only be enabled when Intel SVID ThunderBoltTM alternate mode is entered and VOUT_3V3 is also enabled in #Vout3V3enable."""
        misc.addChild(Lock3V3)

        I2C1Level3V3 = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Use 3V3 for I2C1 Level',
                                                            'offset': 20,
                                                            'bit length': 1})

        I2C1Level3V3.help = """When set to 1, I2C1 voltage level will be referenced to LDO_3V3.When set to 0, I2C1 voltage will be referenced to VDDIO."""
        misc.addChild(I2C1Level3V3)

        I2C2Level3V3 = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Use 3V3 for I2C2 Level',
                                                            'offset': 21,
                                                            'bit length': 1})

        I2C2Level3V3.help = """When set to 1, I2C2 voltage level will be referenced to LDO_3V3.When set to 0, I2C2 voltage will be referenced to VDDIO."""
        misc.addChild(I2C2Level3V3)


########################################################################################################################
########################################################################################################################
########################################################################################################################


class cUserAMModeSettings(register_class.cDataModelArray):
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)

        audEntryEnable = register_class.cBooleanDMTerminator(self.register,
                                                             {'name': 'User VID Mode Autoentry Enabled',
                                                              'offset': 0,
                                                              'bit length': 1})

        audEntryEnable.help = """When a user configures an Alternate Mode with a specific Vendor ID, enabling this bit will allow that mode to be automatically entered."""
        self.addChild(audEntryEnable)


########################################################################################################################
########################################################################################################################
########################################################################################################################


class cUserSvidConfig_0x4A_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'User Alternate Mode Config',
                                                 'address': 0x4A,
                                                 'byte length': 64,
                                                 'permission': 'RW'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name': 'User Alternate Mode Config',
                                                         'offset': 0,
                                                         'bit length': 512})

        enableFlags = register_class.cDataModelArray(self, 1,
                                                     {'name': 'General Settings',
                                                      'offset': 0,
                                                      'bit length': 24})

        self.dataModel.addChild(enableFlags)

        vidEnable = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'User VID Enabled',
                                                         'offset': 0,
                                                         'bit length': 1})

        vidEnable.help = """Allows the user to assign a Vendor ID."""
        enableFlags.addChild(vidEnable)

        uamVid = register_class.cHexDMTerminator(self,
                                                 {'name': 'User Alternate Mode VID (Vendor ID)',
                                                  'offset': 16,
                                                  'bit length': 16})

        uamVid.help = """Allows the user to assign a vendor ID to an Alternate Mode."""
        enableFlags.addChild(uamVid)

        for i in range(4):
            modeenable = register_class.cBooleanDMTerminator(self,
                                                             {'name': 'User VID Mode %d Enabled' % (i + 1),
                                                              'offset': 32 + (i * 8),
                                                              'bit length': 1})

            modeenable.help = """Enable this specific vendor defined alternate mode."""
            enableFlags.addChild(modeenable)

            modeNumber = register_class.cHexDMTerminator(self,
                                                         {'name': 'Mode Value',
                                                          'offset': 0,
                                                          'bit length': 32})

            modeNumber.help = """Select the alternate mode value of this user VID defined mode."""
            modeNumber.setFixedOffset(160 + (32 * i))

            userAmSettings = cUserAMModeSettings(self, 1,
                                                 {'name': 'User Alternate Mode #%d Settings' % (i + 1),
                                                  'offset': 64 + (8 * i),
                                                  'bit length': 416})

            autoSend = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'User VID Mode Auto Send Unstructed VDM',
                                                            'offset': 0,
                                                            'bit length': 1})
            autoSend.help = """Enabling this bit will allow that mode to automatically send unstructed VDM on entry. """
            autoSend.setFixedOffset(96 + (8 * i))

            loadApp = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'User VID Mode Load App Config Data',
                                                           'offset': 0,
                                                           'bit length': 1})
            loadApp.help = """Enabling this bit will allow that mode to load application configuration data on entry. """
            loadApp.setFixedOffset(128 + (8 * i))

            userAmSettings.prependChild(autoSend)
            userAmSettings.prependChild(loadApp)
            userAmSettings.prependChild(modeNumber)
            self.dataModel.addChild(userAmSettings)

        enableVDM = register_class.cDataModelArray(self, 1,
                                                   {'name': 'Unstructured VDM Settings',
                                                    'offset': 288,
                                                    'bit length': 224})

        self.dataModel.addChild(enableVDM)

        vdoData = register_class.cHexDMTerminator(self,
                                                  {'name': 'User VID Auto Send VDO Data',
                                                   'offset': 0,
                                                   'bit length': 192})

        vdoData.help = """If auto send unstructured VDM enabled, up to 192 bits may be sent."""
        enableVDM.addChild(vdoData)

        vendorData = register_class.cHexDMTerminator(self,
                                                     {'name': 'User VID Auto Send Vendor Data',
                                                      'offset': 192,
                                                      'bit length': 14})

        vendorData.help = """If auto send unstructured VDM enabled, up to an additional 14 bits may be sent."""
        enableVDM.addChild(vendorData)

        vdoCount = register_class.cDecimalDMTerminator(self,
                                                       {'name': 'User Mode Auto Send VDO Count',
                                                        'offset': 208,
                                                        'bit length': 8})

        vdoCount.help = """If auto send unstructured VDM enabled, number of VDOs to send."""
        enableVDM.addChild(vdoCount)


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cDMUnstructuredVDO0(register_class.cDataModelArray):
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)

        payload = register_class.cHexDMTerminator(self.register,
                                                  {'name': 'Payload',
                                                   'offset': 0,
                                                   'bit length': 15})

        self.addChild(payload)

        structType = register_class.cListDMTerminator(self.register,
                                                      {'name': 'Type',
                                                       'offset': 15,
                                                       'bit length': 1})
        structType.setReportList(['Unstructured',
                                  'Structured'])

        self.addChild(structType)

        SVID = register_class.cHexDMTerminator(self.register,
                                               {'name': 'SVID',
                                                'offset': 16,
                                                'bit length': 16})

        self.addChild(SVID)


class cDMStructuredVDO0(register_class.cDataModelArray):
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)

        cmd = register_class.cListDMTerminator(self.register,
                                               {'name': 'Command',
                                                'offset': 0,
                                                'bit length': 5})
        cmd.setReportList(['Reserved (0x0)',
                           'Discover Identity',
                           'Discover SVIDs',
                           'Discover Modes',
                           'Enter Mode',
                           'Exit Mode',
                           'Attention',
                           'Reserved (0x7)',
                           'Reserved (0x8)',
                           'Reserved (0x9)',
                           'Reserved (0xA)',
                           'Reserved (0xB)',
                           'Reserved (0xC)',
                           'Reserved (0xD)',
                           'Reserved (0xE)',
                           'Reserved (0xF)',
                           'Status Update',
                           'Config',
                           'Send Data Msg',
                           'Msg Received',
                           'Send PDIO Status',
                           'Rx PDIO Status',
                           'Reserved (0x16)',
                           'Reserved (0x17)',
                           'Reserved (0x18)',
                           'Reserved (0x19)',
                           'Reserved (0x1A)',
                           'Reserved (0x1B)',
                           'Cable Disconnect or Hard Reset',
                           'Early Enter Mode',
                           'Mode Etnered',
                           'Config Complete'])

        self.addChild(cmd)

        cmdType = register_class.cListDMTerminator(self.register,
                                                   {'name': 'Command Type',
                                                    'offset': 6,
                                                    'bit length': 2})
        cmdType.setReportList(['Initiator',
                               'Responder ACK',
                               'Responder NACK',
                               'Responder Busy'])

        self.addChild(cmdType)

        objPosn = register_class.cDecimalDMTerminator(self.register,
                                                      {'name': 'Object Position',
                                                       'offset': 8,
                                                       'bit length': 3})

        self.addChild(objPosn)

        vdmVers = register_class.cDecimalDMTerminator(self.register,
                                                      {'name': 'VDM Version',
                                                       'offset': 13,
                                                       'bit length': 2})
        self.addChild(vdmVers)

        structType = register_class.cListDMTerminator(self.register,
                                                      {'name': 'Type',
                                                       'offset': 15,
                                                       'bit length': 1})
        structType.setReportList(['Unstructured',
                                  'Structured'])

        self.addChild(structType)

        SVID = register_class.cHexDMTerminator(self.register,
                                               {'name': 'SVID',
                                                'offset': 16,
                                                'bit length': 16})

        self.addChild(SVID)


# differentiates between structured and unstructured VDO 0 and interprets accordingly
class cDMAnyFirstVDO(register_class.cDataModelArray):
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)

        self.structuredOverlay = cDMStructuredVDO0(register, self.tier, iDict)
        self.unstructuredOverlay = cDMUnstructuredVDO0(register, self.tier, iDict)

        # self.dataModelChildrenArray must contain the children in all three of the overlays
        self.dataModelChildrenArray = []
        self.dataModelChildrenArray.extend(self.structuredOverlay.dataModelChildrenArray)
        self.dataModelChildrenArray.extend(self.unstructuredOverlay.dataModelChildrenArray)

        self.dataModelGenerator = self.AnyVdoArrayDMGenerator

    def hide(self):
        self.structuredOverlay.hide()
        self.unstructuredOverlay.hide()

    def unhide(self):
        self.structuredOverlay.unhide()
        self.unstructuredOverlay.unhide()

    def AnyVdoArrayDMGenerator(self):
        self.structuredOverlay.parent = self.parent
        self.unstructuredOverlay.parent = self.parent

        type = self.structuredOverlay.getChildByName('Type').valueToInt()

        if type == 0:
            return self.unstructuredOverlay.childrenAsListDMGenerator()
        else:
            return self.structuredOverlay.childrenAsListDMGenerator()


# display pdos based on numPdo
# not a method, but should be grouped with txSrcCap class
def cRxAttention_TopLevelDMGenerator(self):
    numVdo = self.getChildByName('RX Attention Status').getChildByName('Number of Valid VDOs').valueToInt()

    for i in range(7):
        if i < numVdo:
            self.getChildByName('Data Objects Received').dataModelChildrenArray[i].unhide()
        else:
            self.getChildByName('Data Objects Received').dataModelChildrenArray[i].hide()

    if numVdo == 0:
        self.getChildByName('Data Objects Received').hide()
    else:
        self.getChildByName('Data Objects Received').unhide()

    return self.childrenAsListDMGenerator()


class cRxAttention_0x4E_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'RX Attention structured VDM',
                                                 'address': 0x4E,
                                                 'byte length': 29,
                                                 'permission': 'DRO'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name': 'RX Attention structured Register',
                                                         'offset': 0,
                                                         'bit length': 232})

        rxAttentionStatus = register_class.cDataModelArray(self, 1,
                                                           {'name': 'RX Attention Status',
                                                            'offset': 0,
                                                            'bit length': 232})

        self.dataModel.addChild(rxAttentionStatus)

        rxVdmNumValid = register_class.cDecimalDMTerminator(self,
                                                            {'name': 'Number of Valid VDOs',
                                                             'offset': 0,
                                                             'bit length': 3})

        rxVdmNumValid.help = """The number of valid VDOs assigned to this PD Controller."""
        rxVdmNumValid.updateRegisters.append(self)
        rxAttentionStatus.addChild(rxVdmNumValid)

        rxVdmSequenceNum = register_class.cDecimalDMTerminator(self,
                                                               {'name': 'Number of Register Updates',
                                                                'offset': 5,
                                                                'bit length': 3})

        rxVdmSequenceNum.help = """Increments by one every time this register is updated, rolls over upon reflow."""
        rxVdmSequenceNum.updateRegisters.append(self)
        rxAttentionStatus.addChild(rxVdmSequenceNum)

        rxDataObjects = register_class.cDataModelArray(self, 2,
                                                       {'name': 'Data Objects Received',
                                                        'offset': 8,
                                                        'bit length': 224})

        self.dataModel.addChild(rxDataObjects)

        rxDataObjectOne = cDMAnyFirstVDO(self, 1,
                                         {'name': 'Data Object 1',
                                          'offset': 0,
                                          'bit length': 32})

        rxDataObjects.addChild(rxDataObjectOne)

        for i in range(2, 8):
            dataObjX = register_class.cDataModelArray(self, 1,
                                                      {'name': 'Data Object %d' % i,
                                                       'offset': 32 * (i - 1),
                                                       'bit length': 32})

            rxDataObjects.addChild(dataObjX)

            rxDataObjectX = register_class.cHexDMTerminator(self,
                                                            {'name': 'Data Object %d' % i,
                                                             'offset': 0,
                                                             'bit length': 32})

            rxDataObjectX.help = "Data Object %d of most recently received Attention SVDM." % i
            dataObjX.addChild(rxDataObjectX)

        self.dataModel.setDataModelGenerator(cRxAttention_TopLevelDMGenerator)


########################################################################################################################
########################################################################################################################
########################################################################################################################


# display pdos based on numPdo
# not a method, but should be grouped with txSrcCap class
def cRxVdm_TopLevelDMGenerator(self):
    numVdo = self.getChildByName('RX VDM Status').getChildByName('Number of Valid VDOs').valueToInt()

    for i in range(7):
        if i < numVdo:
            self.getChildByName('Data Objects Received').dataModelChildrenArray[i].unhide()
        else:
            self.getChildByName('Data Objects Received').dataModelChildrenArray[i].hide()

    if numVdo == 0:
        self.getChildByName('Data Objects Received').hide()
    else:
        self.getChildByName('Data Objects Received').unhide()

    return self.childrenAsListDMGenerator()


class cRxVdm_0x4F_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'RX VDM Register',
                                                 'address': 0x4F,
                                                 'byte length': 29,
                                                 'permission': 'DRO'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name': 'RX VDM Register',
                                                         'offset': 0,
                                                         'bit length': 232})

        rxVdmStatus = register_class.cDataModelArray(self, 1,
                                                     {'name': 'RX VDM Status',
                                                      'offset': 0,
                                                      'bit length': 232})

        self.dataModel.addChild(rxVdmStatus)

        rxVdmNumValid = register_class.cDecimalDMTerminator(self,
                                                            {'name': 'Number of Valid VDOs',
                                                             'offset': 0,
                                                             'bit length': 3})
        rxVdmNumValid.help = """Number of valid Source VDOs that will be transmitted to the sink at the other end of the USB Type-C cable using USB-PD protocol. The PD Controller can transmit between 0 and 7 Source VDOs"""
        rxVdmNumValid.updateRegisters.append(self)

        rxVdmStatus.addChild(rxVdmNumValid)

        rxVdmSource = register_class.cListDMTerminator(self,
                                                       {'name': 'SOP Message Source',
                                                        'offset': 3,
                                                        'bit length': 2})

        rxVdmSource.setMaxValue(3)
        rxVdmSource.setReportList(
            ['VDM came from SOP', 'VDM came from SOP*', 'VDM came from SOP**', 'VDM came from SOP*_Debug'])
        rxVdmSource.setFixedOffset(3)
        rxVdmSource.help = """SOP* of message source."""
        rxVdmSource.updateRegisters.append(self)

        rxVdmStatus.addChild(rxVdmSource)

        rxVdmSequenceNum = register_class.cDecimalDMTerminator(self,
                                                               {'name': 'Number of Register Updates',
                                                                'offset': 5,
                                                                'bit length': 3})

        rxVdmSequenceNum.updateRegisters.append(self)
        rxVdmSequenceNum.help = """Increments by one every time this register is updated, rolls over upon reflow."""
        rxVdmStatus.addChild(rxVdmSequenceNum)

        rxDataObjects = register_class.cDataModelArray(self, 2,
                                                       {'name': 'Data Objects Received',
                                                        'offset': 8,
                                                        'bit length': 224})

        self.dataModel.addChild(rxDataObjects)

        rxDataObjectOne = cDMAnyFirstVDO(self, 1,
                                         {'name': 'Data Object 1',
                                          'offset': 0,
                                          'bit length': 32})

        rxDataObjects.addChild(rxDataObjectOne)

        for i in range(2, 8):
            dataObjX = register_class.cDataModelArray(self, 1,
                                                      {'name': 'Data Object %d' % i,
                                                       'offset': 32 * (i - 1),
                                                       'bit length': 32})

            rxDataObjects.addChild(dataObjX)

            rxDataObjectX = register_class.cHexDMTerminator(self,
                                                            {'name': 'Data Object %d' % i,
                                                             'offset': 0,
                                                             'bit length': 32})

            rxDataObjectX.help = "Data Object %d of most recently received Attention SVDM." % i
            dataObjX.addChild(rxDataObjectX)

        self.dataModel.setDataModelGenerator(cRxVdm_TopLevelDMGenerator)


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cDataControl_0x50_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Data Control Register',
                                                 'address': 0x4f,
                                                 'byte length': 4,
                                                 'permission': 'DRW'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name': 'Data Control Register',
                                                         'offset': 0,
                                                         'bit length': 32})

        dataControl = register_class.cDataModelArray(self, 1,
                                                     {'name': 'Thunderbolt Data Control Register',
                                                      'offset': 0,
                                                      'bit length': 32})

        self.dataModel.addChild(dataControl)

        hostConnected = register_class.cBooleanDMTerminator(self,
                                                            {'name': 'Thunderbolt Host Connected',
                                                             'offset': 0,
                                                             'bit length': 1})

        hostConnected.updateRegisters.append(self)

        hostConnected.help = """Indicates whether a Thunderbolt host is connected. Thunderbolt controller will force a Soft Reset when writing 1 to 0 and will cause a disconnect/reconnect"""

        dataControl.addChild(hostConnected)

        softReset = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'Soft Reset PD Controller',
                                                         'offset': 1,
                                                         'bit length': 1})

        softReset.updateRegisters.append(self)

        softReset.help = """When this bit is set it will cause a Soft Reset of the PD controller, which is equivalent to the Gaid 4CC command"""

        dataControl.addChild(softReset)

        interruptAck = register_class.cBooleanDMTerminator(self,
                                                           {'name': 'Interrupt Acknowledge',
                                                            'offset': 2,
                                                            'bit length': 1})

        interruptAck.updateRegisters.append(self)

        interruptAck.help = """Thunderbolt controller will set this bit and all interrupts configured in IntMask are written to IntClear, clearing all interrupt events"""

        dataControl.addChild(interruptAck)

        StatusNak = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'Interrupt Acknowledge',
                                                         'offset': 3,
                                                         'bit length': 1})

        StatusNak.updateRegisters.append(self)

        StatusNak.help = """(Host may write 0 or 1, no action to be taken)."""

        dataControl.addChild(StatusNak)

        usbHostConnected = register_class.cBooleanDMTerminator(self,
                                                               {'name': 'USB Host Connected ',
                                                                'offset': 4,
                                                                'bit length': 1})

        usbHostConnected.updateRegisters.append(self)

        usbHostConnected.help = """This bit is only applicable to Thunderbolt devices and indicates if there is a USB host connected upstream"""

        dataControl.addChild(usbHostConnected)

        dpHostConnected = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'DisplayPort Host Connected ',
                                                               'offset': 5,
                                                               'bit length': 1})

        dpHostConnected.updateRegisters.append(self)

        dpHostConnected.help = """This bit is only applicable to Thunderbolt devices and indicates if there is a DisplayPort host (DFP_D) connected upstream"""

        dataControl.addChild(dpHostConnected)

        irq_Ack = register_class.cBooleanDMTerminator(self,
                                                      {'name': 'Interrupt Present',
                                                       'offset': 13,
                                                       'bit length': 1})

        irq_Ack.updateRegisters.append(self)

        irq_Ack.help = """This bit is will indicate is an interrupt has occured"""

        dataControl.addChild(irq_Ack)

        hpd_IrqSticky = register_class.cBooleanDMTerminator(self,
                                                            {'name': 'DisplayPort HPD IRQ Present',
                                                             'offset': 14,
                                                             'bit length': 1})

        hpd_IrqSticky.updateRegisters.append(self)

        hpd_IrqSticky.help = """This bit is only applicable to Thunderbolt devices and indicates if an DisplayPort Hot Plug Detect Interrupt was received from the DisplayPort sink (UFP_D)"""

        dataControl.addChild(hpd_IrqSticky)

        hpdLevel = register_class.cBooleanDMTerminator(self,
                                                       {'name': 'DisplayPort HPD High/Low',
                                                        'offset': 15,
                                                        'bit length': 1})

        hpdLevel.updateRegisters.append(self)

        hpdLevel.help = """This bit is only applicable to Thunderbolt devices and indicates the DisplayPort Hot Plug Detect High/Low level from the DisplayPort sink (UFP_D)"""

        dataControl.addChild(hpdLevel)


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cUserVidStatus_0x57_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'User VID Status Register',
                                                 'address': 0x57,
                                                 'byte length': 2,
                                                 'permission': 'DRO'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name': 'User VID Status',
                                                         'offset': 0,
                                                         'bit length': 16})

        userVidStatus = register_class.cDataModelArray(self, 1,
                                                       {'name': 'User VID Status',
                                                        'offset': 0,
                                                        'bit length': 16})

        self.dataModel.addChild(userVidStatus)

        vidDetected = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'User VID Detected',
                                                           'offset': 0,
                                                           'bit length': 1})

        vidDetected.updateRegisters.append(self)

        vidDetected.help = """When this bit is set high the user VID has been detected"""

        userVidStatus.addChild(vidDetected)

        vidActive = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'User VID Active',
                                                         'offset': 1,
                                                         'bit length': 1})

        vidActive.updateRegisters.append(self)

        vidActive.help = """When this bit is set high the user VID is active and at least one mode has been entered"""

        userVidStatus.addChild(vidActive)

        userVidErrorCode = register_class.cHexDMTerminator(self,
                                                           {'name': 'User VID Error Code',
                                                            'offset': 2,
                                                            'bit length': 3})

        userVidErrorCode.updateRegisters.append(self)

        userVidErrorCode.help = """User VID Error Code used for debugging purposes only."""

        userVidStatus.addChild(userVidErrorCode)

        userMode1Status = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'User VID Mode 1 Status',
                                                               'offset': 9,
                                                               'bit length': 1})

        userMode1Status.updateRegisters.append(self)

        userMode1Status.help = """When this bit is set high it will indicate Mode 1 was entered for the user VID"""

        userVidStatus.addChild(userMode1Status)

        userMode2Status = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'User VID Mode 2 Status',
                                                               'offset': 10,
                                                               'bit length': 1})

        userMode2Status.updateRegisters.append(self)

        userMode2Status.help = """When this bit is set high it will indicate Mode 2 was entered for the user VID"""

        userVidStatus.addChild(userMode2Status)

        userMode3Status = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'User VID Mode 3 Status',
                                                               'offset': 11,
                                                               'bit length': 1})

        userMode3Status.updateRegisters.append(self)

        userMode3Status.help = """When this bit is set high it will indicate Mode 3 was entered for the user VID"""

        userVidStatus.addChild(userMode3Status)

        userMode4Status = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'User VID Mode 4 Status',
                                                               'offset': 12,
                                                               'bit length': 1})

        userMode4Status.updateRegisters.append(self)

        userMode4Status.help = """When this bit is set high it will indicate Mode 4 was entered for the user VID"""

        userVidStatus.addChild(userMode4Status)


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cTiVidStatus_0x5B_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'TI VID Status Register',
                                                 'address': 0x5B,
                                                 'byte length': 1,
                                                 'permission': 'DRO'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name': 'TI Mode Status',
                                                         'offset': 0,
                                                         'bit length': 8})

        tividStatus1 = register_class.cDataModelArray(self, 1,
                                                      {'name': 'Texas Instruments VID Status',
                                                       'offset': 0,
                                                       'bit length': 1})

        self.dataModel.addChild(tividStatus1)

        tiVidStatus = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'TI VID Status',
                                                           'offset': 0,
                                                           'bit length': 1})

        tiVidStatus.updateRegisters.append(self)

        tiVidStatus.help = """When this bit is set high the TI VID alternate mode has been entered."""

        tividStatus1.addChild(tiVidStatus)

        pdioStatus = register_class.cBooleanDMTerminator(self,
                                                         {'name': 'TI PDIO Status',
                                                          'offset': 1,
                                                          'bit length': 1})

        pdioStatus.updateRegisters.append(self)

        pdioStatus.help = """When this bit is set high the TI PDIO alternate mode has been entered."""

        tividStatus1.addChild(pdioStatus)

        tiVidErrorCode = register_class.cHexDMTerminator(self,
                                                         {'name': 'TI VID Error Code',
                                                          'offset': 2,
                                                          'bit length': 3})

        tiVidErrorCode.updateRegisters.append(self)

        tiVidErrorCode.help = """Texas Instruments VID Error Code used for debugging purposes only."""

        tividStatus1.addChild(tiVidErrorCode)


########################################################################################################################
########################################################################################################################
########################################################################################################################

# display pdos based on numPdo
# not a method, but should be grouped with txSrcCap class
def TxIDO_TopLevelDMGenerator(self):
    numUfpIDO = self.getChildByName('Record Counts').getChildByName('Number of Identity Objects').valueToInt()

    for i in range(6):
        if i < numUfpIDO:
            self.getChildByName('Discover Identity Response').dataModelChildrenArray[i].unhide()
        else:
            self.getChildByName('Discover Identity Response').dataModelChildrenArray[i].hide()

    numTPIDO = self.getChildByName('Record Counts').getChildByName(
        "Number of SOP' (Tethered Plug) Identity Objects").valueToInt()

    for i in range(6):
        if i < numTPIDO:
            self.getChildByName("SOP' (Tethered Plug) Discover Identity Response").dataModelChildrenArray[i].unhide()
        else:
            self.getChildByName("SOP' (Tethered Plug) Discover Identity Response").dataModelChildrenArray[i].hide()

    if numTPIDO == 0:
        self.getChildByName("SOP' (Tethered Plug) Discover Identity Response").hide()
    else:
        self.getChildByName("SOP' (Tethered Plug) Discover Identity Response").unhide()

    return self.childrenAsListDMGenerator()


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cTxIDO_0x47_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Transmit Identity Data Object',
                                                 'address': 0x47,
                                                 'byte length': 49,
                                                 'permission': 'RW'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name': 'Transmit Identity Data Object',
                                                         'offset': 0,
                                                         'bit length': 392})

        numIdoConfig = register_class.cDataModelArray(self, 1,
                                                      {'name': 'Record Counts',
                                                       'offset': 0,
                                                       'bit length': 8})

        self.dataModel.addChild(numIdoConfig)

        numUfpIDO = register_class.cDecimalDMTerminator(self,
                                                        {'name': 'Number of Identity Objects',
                                                         'offset': 0,
                                                         'bit length': 3})
        numUfpIDO.help = """Select the number of upstream facing port identity objects to assign to this PD Controller."""
        numUfpIDO.setMaxValue(6)
        numUfpIDO.updateRegisters.append(self)
        numIdoConfig.addChild(numUfpIDO)

        # for now just allow the predefined IDO fields

        numSOPpIDO = register_class.cDecimalDMTerminator(self,
                                                         {'name': "Number of SOP' (Tethered Plug) Identity Objects",
                                                          'offset': 4,
                                                          'bit length': 3})
        numSOPpIDO.help = """Select the number of SOP' (Tethered Plug) identity objects to assign to this PD Controller."""
        numSOPpIDO.setMaxValue(6)
        numSOPpIDO.updateRegisters.append(self)
        numIdoConfig.addChild(numSOPpIDO)

        # numTPIDO = register_class.cForceSetDMTerminator( self,  { 'name' : "Number of SOP' (Tethered Plug) Identity Objects",
        #                                                         'offset' : 4,
        #                                                         'bit length' : 3,
        #                                                         'force value' : int(0),
        #                                                         'force display' : '0',
        #                                                         'display widget' : numSOPpIDO })
        #
        # numTPIDO.help = """Select the number of SOP' identity objects to assign to this PD Controller."""
        # numIdoConfig.addChild(numTPIDO)
        # numTPIDO.setFromInt(0)
        # numTPIDO.hide()

        ufpIDO = register_class.cDataModelArray(self, 2,
                                                {'name': 'Discover Identity Response',
                                                 'offset': 8,
                                                 'bit length': 128})

        self.dataModel.addChild(ufpIDO)
        ufpIDO.addChild(cIDHeaderVDO(self, 1,
                                     {'name': 'UFP IDO Header',
                                      'offset': 0,
                                      'bit length': 32}))

        ufpIDO.addChild(register_class.cHexDMTerminator(self,
                                                        {'name': 'Certification Test ID',
                                                         'offset': 32,
                                                         'bit length': 20}))

        ufpIDO.help = """Enter the Certification Test ID of the Device."""
        ufpIDO.addChild(cUFPProductVDO(self, 1,
                                       {'name': 'Product Vendor Defined Object',
                                        'offset': 64,
                                        'bit length': 32}))

        ufpIDO.addChild(cAMAVDO(self, 1,
                                {'name': 'Alternate Mode Adapter VDO',
                                 'offset': 96,
                                 'bit length': 32}))

        ufpIDO.addChild(register_class.cHexDMTerminator(self,
                                                        {'name': 'UFP IDO VDO #5',
                                                         'offset': 128,
                                                         'bit length': 32}))

        ufpIDO.help = """Add the identity object of the 5th UFP VDO."""
        ufpIDO.addChild(register_class.cHexDMTerminator(self,
                                                        {'name': 'UFP IDO VDO #6',
                                                         'offset': 160,
                                                         'bit length': 32}))

        ufpIDO.help = """Add the identity object of the 6th UFP VDO."""
        ufpIDO = register_class.cDataModelArray(self, 2,
                                                {'name': "SOP' (Tethered Plug) Discover Identity Response",
                                                 'offset': 200,
                                                 'bit length': 128})

        self.dataModel.addChild(ufpIDO)
        ufpIDO.addChild(cCableIDOHeaderVDO(self, 1,
                                     {'name': "SOP' (Tethered Plug) IDO Header",
                                      'offset': 0,
                                      'bit length': 32}))

        ufpIDO.addChild(register_class.cHexDMTerminator(self,
                                                        {'name': 'Certification Test ID',
                                                         'offset': 32,
                                                         'bit length': 20}))

        ufpIDO.help = """Enter the Certification Test ID of the Device."""
        ufpIDO.addChild(cUFPProductVDO(self, 1,
                                       {'name': 'Product Vendor Defined Object',
                                        'offset': 64,
                                        'bit length': 32}))

        ufpIDO.addChild(cCableVDO(self, 1,
                                  {'name': 'Cable Vendor Defined Object',
                                   'offset': 96,
                                   'bit length': 32}))

        ufpIDO.addChild(register_class.cHexDMTerminator(self,
                                                        {'name': "SOP' (Tethered Plug) IDO VDO #5",
                                                         'offset': 128,
                                                         'bit length': 32}))

        ufpIDO.help = """Add the identity object of the 5th UFP VDO."""
        ufpIDO.addChild(register_class.cHexDMTerminator(self,
                                                        {'name': "SOP' (Tethered Plug) IDO VDO #6",
                                                         'offset': 160,
                                                         'bit length': 32}))

        ufpIDO.help = """Add the identity object of the 6th UFP VDO."""

        self.dataModel.setDataModelGenerator(TxIDO_TopLevelDMGenerator)


########################################################################################################################
########################################################################################################################
########################################################################################################################

# display pdos based on numPdo
# not a method, but should be grouped with txSrcCap class
def RxIDO_TopLevelDMGenerator(self):
    numUfpIDO = self.getChildByName('VDO configuration').getChildByName('Number of valid VDOs').valueToInt()

    for i in range(6):
        if i < numUfpIDO:
            self.getChildByName('Received VDO').dataModelChildrenArray[i].unhide()
        else:
            self.getChildByName('Received VDO').dataModelChildrenArray[i].hide()

    return self.childrenAsListDMGenerator()


class cRxSOPID_0x48_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'RX Identity SOP',
                                                 'address': 0x48,
                                                 'byte length': 25,
                                                 'permission': 'DRO'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name': 'RX Identity SOP',
                                                         'offset': 0,
                                                         'bit length': 200})

        numVdoConfig = register_class.cDataModelArray(self, 2,
                                                      {'name': 'VDO configuration',
                                                       'offset': 0,
                                                       'bit length': 8})

        self.dataModel.addChild(numVdoConfig)

        numVDO = register_class.cDecimalDMTerminator(self,
                                                     {'name': 'Number of valid VDOs',
                                                      'offset': 0,
                                                      'bit length': 3})
        numVDO.help = """The number of valid VDOs assigned to this PD Controller."""
        numVDO.updateRegisters.append(self)
        numVdoConfig.addChild(numVDO)

        numVDOResponse = register_class.cListDMTerminator(self,
                                                          {'name': 'SOP Message Source',
                                                           'offset': 6,
                                                           'bit length': 2})

        numVDOResponse.help = """Returns the RX identity SOP Status."""
        numVDOResponse.setReportList(['SOP Discover Identity request not sent or pending.', 'Responder ACK received.',
                                      'Responder NAK received or response timeout.',
                                      'Responder BUSY received (PD Controller will retry).'])
        numVdoConfig.addChild(numVDOResponse)

        rxDataObjects = register_class.cDataModelArray(self, 2,
                                                       {'name': 'Received VDO',
                                                        'offset': 8,
                                                        'bit length': 192})

        self.dataModel.addChild(rxDataObjects)

        rxDataObjects.addChild(cIDHeaderVDO(self, 1,
                                            {'name': 'UFP IDO Header',
                                             'offset': 0,
                                             'bit length': 32}))

        rxDataObjects.addChild(register_class.cHexDMTerminator(self,
                                                               {'name': 'Certification Test ID',
                                                                'offset': 32,
                                                                'bit length': 20}))

        rxDataObjects.addChild(cUFPProductVDO(self, 1,
                                              {'name': 'Product Vendor Defined Object',
                                               'offset': 64,
                                               'bit length': 32}))

        rxDataObjects.addChild(cAMAVDO(self, 1,
                                       {'name': 'Alternate Mode Adapter VDO',
                                        'offset': 96,
                                        'bit length': 32}))

        rxDataObjects.addChild(register_class.cHexDMTerminator(self,
                                                               {'name': 'UFP IDO VDO #5',
                                                                'offset': 128,
                                                                'bit length': 32}))

        rxDataObjects.addChild(register_class.cHexDMTerminator(self,
                                                               {'name': 'UFP IDO VDO #6',
                                                                'offset': 160,
                                                                'bit length': 32}))

        self.dataModel.setDataModelGenerator(RxIDO_TopLevelDMGenerator)


########################################################################################################################
########################################################################################################################
########################################################################################################################


class cRxSOPpID_0x49_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'RX Identity SOPp',
                                                 'address': 0x49,
                                                 'byte length': 25,
                                                 'permission': 'DRO'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name': 'RX Identity SOPp',
                                                         'offset': 0,
                                                         'bit length': 200})

        numVdoConfig = register_class.cDataModelArray(self, 1,
                                                      {'name': 'VDO configuration',
                                                       'offset': 0,
                                                       'bit length': 8})

        self.dataModel.addChild(numVdoConfig)

        numVDO = register_class.cDecimalDMTerminator(self,
                                                     {'name': 'Number of valid VDOs',
                                                      'offset': 0,
                                                      'bit length': 3})
        numVDO.help = """The number of valid VDOs assigned to this PD Controller."""
        numVDO.updateRegisters.append(self)
        numVdoConfig.addChild(numVDO)

        numVDOResponse = register_class.cListDMTerminator(self,
                                                          {'name': 'SOPp Message Source',
                                                           'offset': 6,
                                                           'bit length': 2})

        numVDOResponse.help = """Returns the RX identity SOP' response."""
        numVDOResponse.setReportList(['SOP Discover Identity request not sent or pending.', 'Responder ACK received.',
                                      'Responder NAK received or response timeout.',
                                      'Responder BUSY received (PD Controller will retry).'])

        numVdoConfig.addChild(numVDOResponse)

        rxDataObjects = register_class.cDataModelArray(self, 2,
                                                       {'name': 'Received VDO',
                                                        'offset': 8,
                                                        'bit length': 192})

        self.dataModel.addChild(rxDataObjects)

        rxDataObjects.addChild(cCableIDOHeaderVDO(self, 1,
                                            {'name': "SOP' (Tethered Plug) IDO Header",
                                             'offset': 0,
                                             'bit length': 32}))

        rxDataObjects.addChild(register_class.cHexDMTerminator(self,
                                                               {'name': 'Certification Test ID',
                                                                'offset': 32,
                                                                'bit length': 20}))

        rxDataObjects.addChild(cUFPProductVDO(self, 1,
                                              {'name': 'Product Vendor Defined Object',
                                               'offset': 64,
                                               'bit length': 32}))

        rxDataObjects.addChild(cCableVDO(self, 1,
                                         {'name': 'Cable Vendor Defined Object',
                                          'offset': 96,
                                          'bit length': 32}))

        rxDataObjects.addChild(register_class.cHexDMTerminator(self,
                                                               {'name': "SOP' (Tethered Plug) IDO VDO #5",
                                                                'offset': 128,
                                                                'bit length': 32}))

        rxDataObjects.addChild(register_class.cHexDMTerminator(self,
                                                               {'name': "SOP' (Tethered Plug) IDO VDO #6",
                                                                'offset': 160,
                                                                'bit length': 32}))

        self.dataModel.setDataModelGenerator(RxIDO_TopLevelDMGenerator)


########################################################################################################################
########################################################################################################################
########################################################################################################################


# 1 argument
# argsList[0] = Port Capability
def prefRoleDerivedFxn(argsList):
    # if port capability is disabled, UFP only or DFP/UFP set preferred role to UFP
    # Set DFP/UFP to prefers UFP for Daisy Chaining
    if (argsList[0].valueToInt() == 0) or (argsList[0].valueToInt() == 1) or (argsList[0].valueToInt() == 3):
        return 0
    else:
        # if port capability is DFP only, set preferred role to DFP
        return 1


# 1 argument
# argsList[0] = Port Capability
def dpConnectedDerivedFxn(argsList):
    # Careful, connected is swizzled versus capability
    if (argsList[0].valueToInt() == 0) or (argsList[0].valueToInt() == 3):
        # these are direct-mapped
        return argsList[0].valueToInt()
    elif (argsList[0].valueToInt() == 1):
        # these are swizzled
        return 2
    else:
        # these are swizzled
        return 1


class cDisplayPortCapabilities_0x51_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Display Port Capabilities',
                                                 'address': 0x51,
                                                 'byte length': 7,
                                                 'permission': 'RW'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'Display Port Capabilities',
                                                         'offset': 0,
                                                         'bit length': 56})

        enDPSid = register_class.cBooleanDMTerminator(self,
                                                      {'name': 'Enable Display Port SID',
                                                       'offset': 0,
                                                       'bit length': 1})
        enDPSid.help = """When this bit is set to 1, DisplayPort Sepcific Vendor ID (SVID) is enabled. At least one mode from bits[71] must also be enabled for DP to be enabled.When this bit is set to 0, DP SVID is disabled."""
        enDPSid.addUpdateRegisterByName('Alternate Mode Entry Queue')
        self.dataModel.addChild(enDPSid)

        enDPMode = register_class.cBooleanDMTerminator(self,
                                                       {'name': 'Enable Display Port Mode 1',
                                                        'offset': 1,
                                                        'bit length': 1})
        enDPMode.help = """When this bit is set to 1, DisplayPort (DP) Mode is enabled. #EnableDPSID must also be enabled in bit[0] for this bit to enable DisplayPort. Note DP only has one mode for now so this bit is redundant. However, other modes may be added in the future so providing the structure here for this. If other mdoes are added in the future, then bits 31..24 of the DP capabilities message (bits[39..32] of this register) will be non-zero."""
        enDPMode.addUpdateRegisterByName('Alternate Mode Entry Queue')
        self.dataModel.addChild(enDPMode)

        portCap = register_class.cListDMTerminator(self,
                                                   {'name': 'Port Capability',
                                                    'offset': 8,
                                                    'bit length': 2})

        portCap.help = """DP Port Capability00b = Reserved01b = UFP_D-capable (including Branch device)10b = DFP_D-capable (including Branch device)11b = Both DFP_D and UFP_D-capable"""
        portCap.setReportList(['DP Disabled', 'DP UFP_D only', 'DP DFP_D only', 'DP UFP_D and DFP_D'])
        portCap.addUpdateRegisterByName('self')
        self.dataModel.addChild(portCap)

        signalling = register_class.cForceSetDMTerminator(self, {'name': 'DisplayPort Signalling',
                                                                 'offset': 10,
                                                                 'bit length': 1,
                                                                 'force value': 1,
                                                                 'force display': 'DP 1.3'})

        self.dataModel.addChild(signalling)
        signalling.setFromInt(1)
        signalling.hide()

        receptIndic = register_class.cListDMTerminator(self,
                                                       {'name': 'Receptacle Indication',
                                                        'offset': 14,
                                                        'bit length': 1})

        receptIndic.setReportList(['Plug', 'Receptacle'])

        self.dataModel.addChild(receptIndic)

        usb2SNU = register_class.cForceSetDMTerminator(self, {'name': 'USB2.0 Signalling Not Used',
                                                              'offset': 15,
                                                              'bit length': 1,
                                                              'force value': 0,
                                                              'force display': 'False'})

        self.dataModel.addChild(usb2SNU)
        usb2SNU.setFromInt(0)
        usb2SNU.hide()

        #        dfpdpins = register_class.cMultiBooleanDMTerminator(self,
        #                                                        {'name' : 'DFPD Receptacle or UFPD Plug Pin Assignment',
        #                                                         'offset' : 16,
        #                                                         'bit length' : 8 })
        #        dfpdpins.setFlagNameList(['A', 'B', 'C', 'D', 'E', 'F'])
        #        dfpdpins.setFlagMask([1, 1, 1, 1, 1, 1, 0, 0])
        #        dfpdpins.setSpacing(6)
        #        self.dataModel.addChild(dfpdpins)

        dfpdpins = register_class.cForceSetDMTerminator(self, {'name': 'DFPD Receptacle or UFPD Plug Pin Assignment',
                                                               'offset': 16,
                                                               'bit length': 8,
                                                               'force value': int(0x1C),
                                                               'force display': 'C, D and E'})

        self.dataModel.addChild(dfpdpins)
        dfpdpins.setFromInt(0x1C)
        dfpdpins.hide()

        #        ufpdpins = register_class.cMultiBooleanDMTerminator(self,
        #                                                        {'name' : 'UFPD Receptacle or DFPD Plug Pin Assignment',
        #                                                         'offset' : 24,
        #                                                         'bit length' : 8 })
        #
        #        ufpdpins.setFlagNameList(['A', 'B', 'C', 'D', 'E', 'F'])
        #        ufpdpins.setFlagMask([1, 1, 1, 1, 1, 0, 0, 0])
        #        ufpdpins.setSpacing(6)
        #        self.dataModel.addChild(ufpdpins)

        ufpdpins = register_class.cForceSetDMTerminator(self, {'name': 'UFPD Receptacle or DFPD Plug Pin Assignment',
                                                               'offset': 24,
                                                               'bit length': 8,
                                                               'force value': int(0xC),
                                                               'force display': 'C and D'})

        self.dataModel.addChild(ufpdpins)
        ufpdpins.setFromInt(0xC)
        ufpdpins.hide()

        multiFunc = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'Multifunction Preferred',
                                                         'offset': 32,
                                                         'bit length': 1})
        self.dataModel.addChild(multiFunc)

        prefRole = register_class.cListDMTerminator(self,
                                                    {'name': 'Preferred DP Role',
                                                     'offset': 33,
                                                     'bit length': 1})
        prefRole.setReportList(['Prefers UFP_D', 'Prefers DFP_D'])
        prefRole.help = """Preferred DP role for ports that support both DFP_D and UFP_D."""

        prefRole.registerAsDerivedField(prefRoleDerivedFxn, None,
                                        [ \
                                            ['self', 'Port Capability'], \
                                            ])
        prefRole.hide()
        self.dataModel.addChild(prefRole)

        # forceUSB = register_class.cBooleanDMTerminator(self,
        #                                                {'name': 'Force USB Configuration',
        #                                                 'offset': 34,
        #                                                 'bit length': 1})
        # forceUSB.help = """Forces USB Configuration."""
        # self.dataModel.addChild(forceUSB)

        dfpUfpConn = register_class.cListDMTerminator(self,
                                                      {'name': 'DFP_D / UFP_D Connected',
                                                       'offset': 35,
                                                       'bit length': 2})
        dfpUfpConn.setReportList(
            ['No Connection', 'Only DFP_D Connected', 'Only UFP_D Connected', 'UFP_D and DFP_D Connected'])
        dfpUfpConn.help = """Whether port will indicate connection if configured as DFP_D or UFP_D."""

        dfpUfpConn.registerAsDerivedField(dpConnectedDerivedFxn, None,
                                          [ \
                                              ['self', 'Port Capability'], \
                                              ])
        dfpUfpConn.hide()
        self.dataModel.addChild(dfpUfpConn)

        autoEnter = register_class.cForceSetDMTerminator(self, {'name': 'DisplayPort Mode Auto Entry Allowed',
                                                                'offset': 41,
                                                                'bit length': 1,
                                                                'force value': int(0),
                                                                'force display': 'Disabled'})

        self.dataModel.addChild(autoEnter)
        autoEnter.setFromInt(0)
        autoEnter.hide()

        billboardIndex = register_class.cForceSetDMTerminator(self, {'name': 'Reserved, Set 0',
                                                                     'offset': 48,
                                                                     'bit length': 8,
                                                                     'force value': int(0),
                                                                     'force display': '0'})

        self.dataModel.addChild(billboardIndex)
        billboardIndex.setFromInt(0)
        billboardIndex.hide()


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cIntVidConf_0x52_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Intel VID Config Register',
                                                 'address': 0x52,
                                                 'byte length': 8,
                                                 'permission': 'RW'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name': 'Intel VID Config Register',
                                                         'offset': 0,
                                                         'bit length': 64})

        self.hide()

        vidConfig = register_class.cDataModelArray(self, 1,
                                                   {'name': 'Intel VID Config Set',
                                                    'offset': 0,
                                                    'bit length': 16})

        self.dataModel.addChild(vidConfig)

        enIntVid = register_class.cBooleanDMTerminator(self,
                                                       {'name': 'Enable Intel VID',
                                                        'offset': 0,
                                                        'bit length': 1})
        enIntVid.help = """When this bit is set to 1, Intel VID is enabled. At least one mode from bit[71] must also be enabled for Intel VID to be enabled.When this bit is set to 0, Intel VID is disabled"""
        enIntVid.addUpdateRegisterByName('Alternate Mode Entry Queue')
        vidConfig.addChild(enIntVid)

        enIntMode = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'Enable Intel Thunderbolt Mode',
                                                         'offset': 1,
                                                         'bit length': 1})
        enIntMode.help = """When this bit is set to 1, ThunderboltTM Mode is enabled. #IntelVIDEnabled must also be enabled in bit[0] for this bit to enable ThunderBoltTM."""
        enIntMode.addUpdateRegisterByName('Alternate Mode Entry Queue')
        vidConfig.addChild(enIntMode)

        vout3V3R = register_class.cForceSetDMTerminator(self, {'name': 'Vout_3V3 Required',
                                                               'offset': 8,
                                                               'bit length': 1,
                                                               'force value': 1,
                                                               'force display': 'Enabled'})

        self.dataModel.addChild(vout3V3R)
        vout3V3R.setFromInt(1)
        vout3V3R.hide()

        emarkOverride = register_class.cForceSetDMTerminator(self, {'name': 'Thunderbolt Emarker Override',
                                                                    'offset': 9,
                                                                    'bit length': 1,
                                                                    'force value': int(0),
                                                                    'force display': 'False'})

        emarkOverride.hide()
        vidConfig.addChild(emarkOverride)
        emarkOverride.setFromInt(0)

        anMinPowerReq = register_class.cForceSetDMTerminator(self, {'name': 'AN Minimum Power Required',
                                                                    'offset': 10,
                                                                    'bit length': 1,
                                                                    'force value': int(1),
                                                                    'force display': 'True'})

        anMinPowerReq.hide()
        vidConfig.addChild(anMinPowerReq)
        anMinPowerReq.setFromInt(1)


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cTIVidConf_0x54_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Texas Instruments VID Config',
                                                 'address': 0x54,
                                                 'byte length': 8,
                                                 'permission': 'RW'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'Texas Instruments VID Config',
                                                         'offset': 0,
                                                         'bit length': 64})

        enTIVid = register_class.cBooleanDMTerminator(self,
                                                      {'name': 'Enable Texas Instruments VID',
                                                       'offset': 0,
                                                       'bit length': 1})
        enTIVid.help = """When this bit is set to 1, TI VID is enabled. At least one mode from bits[71] must also be enabled for the TI VID to be enabled.When this bit is set to 0, TI VID is disabled.If this option is disabled by default, it is not advisable to enable the TI SVID"""
        self.dataModel.addChild(enTIVid)

        enPDIOMode = register_class.cBooleanDMTerminator(self,
                                                         {'name': 'Enable PDIO Mode',
                                                          'offset': 1,
                                                          'bit length': 1})
        enPDIOMode.help = """The PDIO Alternate mode enables GPIO passthru using the PD data channel"""
        self.dataModel.addChild(enPDIOMode)

        enPDIOAutoentry = register_class.cBooleanDMTerminator(self,
                                                              {'name': 'Enable PDIO Mode Autoentry',
                                                               'offset': 9,
                                                               'bit length': 1})
        enPDIOAutoentry.help = """With this bit enabled, the PDIO mode will be automatically entered when the far end device is compatible."""
        self.dataModel.addChild(enPDIOAutoentry)

        billboardIndex = register_class.cForceSetDMTerminator(self, {'name': 'Reserved, Set 0',
                                                                     'offset': 16,
                                                                     'bit length': 8,
                                                                     'force value': int(0),
                                                                     'force display': '0'})

        billboardIndex.help = """Set the billboard index for this Alternate Mode."""
        billboardIndex.hide()
        self.dataModel.addChild(billboardIndex)
        billboardIndex.setFromInt(0)

        pdioSignature = register_class.cDataModelTerminator(self,
                                                            {'name': 'PDIO Signature',
                                                             'offset': 32,
                                                             'bit length': 32})
        pdioSignature.help = """select the signature of the PDIO Alternate Mode."""
        self.dataModel.addChild(pdioSignature)


class cMiscellaneousControl_0x55_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Miscellaneous Control',
                                                 'address': 0x55,
                                                 'byte length': 1,
                                                 'permission': 'RW'})

        self.setAsShared()

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'Miscellaneous Control',
                                                         'offset': 0,
                                                         'bit length': 8})

        enTIVid = register_class.cBooleanDMTerminator(self,
                                                      {'name': 'VSafe0V Dongle',
                                                       'offset': 0,
                                                       'bit length': 1})
        self.dataModel.addChild(enTIVid)

        enTIVid = register_class.cBooleanDMTerminator(self,
                                                      {'name': 'AC Adapter Block Swap if no Data Support',
                                                       'offset': 1,
                                                       'bit length': 1})
        self.dataModel.addChild(enTIVid)

        enTIVid = register_class.cBooleanDMTerminator(self,
                                                      {'name': 'Extend Error Recovery Timeout to 50 mSec',
                                                       'offset': 2,
                                                       'bit length': 1})
        self.dataModel.addChild(enTIVid)

        psrdyDly = register_class.cHexDMTerminator(self,
                                                   {'name': 'PSRDY Delay',
                                                    'offset': 3,
                                                    'bit length': 2})
        self.dataModel.addChild(psrdyDly)


########################################################################################################################
########################################################################################################################
########################################################################################################################


def intFrom4CC(value):
    retVal = 0x0
    # little endian. First char takes position 0 of the array
    for (i, char) in enumerate(value):
        retVal |= (ord(char) << (8 * i))

    return retVal


cmdReportDict = {intFrom4CC('!CMD'): '!CMD',
                 intFrom4CC('Gaid'): 'Gaid',
                 intFrom4CC('GAID'): 'GAID',
                 intFrom4CC('ANeg'): 'ANeg',
                 intFrom4CC('CRST'): 'CRST',
                 intFrom4CC('DBfg'): 'DBfg',
                 #                   intFrom4CC('FPWR') : 'FPWR',
                 #                   intFrom4CC('GPIO') : 'GPIO',
                 intFrom4CC('GPoe'): 'GPoe',
                 intFrom4CC('GPie'): 'GPie',
                 intFrom4CC('GPsh'): 'GPsh',
                 intFrom4CC('GPsl'): 'GPsl',
                 intFrom4CC('HRST'): 'HRST',
                 intFrom4CC('I2Cw') : 'I2Cw',
                 #                   intFrom4CC('LOCK') : 'LOCK',
                 #                   intFrom4CC('MEMr') : 'MEMr',
                 #                   intFrom4CC('MEMw') : 'MEMw',
                 #                   intFrom4CC('PDOf') : 'PDOf',
                 #                   intFrom4CC('PDTx') : 'PDTx',
                 intFrom4CC('SRDY'): 'SRDY',
                 intFrom4CC('SRYR'): 'SRYR',
                 #                   intFrom4CC('VDMs') : 'VDMs'
                 }

cmdTaskReportDict = {intFrom4CC('!CMD'): '!CMD',
                     intFrom4CC('Gaid'): 'Gaid',
                     intFrom4CC('GAID'): 'GAID',
                     #                   intFrom4CC('ABRT') : 'ABRT',
                     intFrom4CC('AMDs'): 'AMDs',
                     intFrom4CC('AMDs'): 'AMEn',
                     intFrom4CC('AMEn'): 'AMEx',
                     intFrom4CC('AMEx'): 'ANeg',
                     #                  intFrom4CC('ASkE') : 'ASkE',
                     intFrom4CC('CRST'): 'CRST',
                     intFrom4CC('DBfg'): 'DBfg',
                     #                   intFrom4CC('FPWR') : 'FPWR',
                     intFrom4CC('GO2M'): 'GO2M',
                     #                   intFrom4CC('GPIO') : 'GPIO',
                     #                   intFrom4CC('GPMp') : 'GPMp',
                     intFrom4CC('GPoe'): 'GPoe',
                     intFrom4CC('GPie'): 'GPie',
                     intFrom4CC('GPsh'): 'GPsh',
                     intFrom4CC('GPsl'): 'GPsl',
                     intFrom4CC('GSkC'): 'GSkC',
                     intFrom4CC('GSrC'): 'GSrC',
                     intFrom4CC('HRST'): 'HRST',
                     #                  intFrom4CC('ISkE') : 'ISkE',
                     #                   intFrom4CC('LOCK') : 'LOCK',
                     #                   intFrom4CC('MDEr') : 'MDEr',
                     #                   intFrom4CC('MDEw') : 'MDEw',
                     #                   intFrom4CC('MEMr') : 'MEMr',
                     #                   intFrom4CC('MEMw') : 'MEMw',
                     #                   intFrom4CC('PDOf') : 'PDOf',
                     #                   intFrom4CC('PDTx') : 'PDTx',
                     intFrom4CC('SRDY'): 'SRDY',
                     intFrom4CC('SRYR'): 'SRYR',
                     intFrom4CC('SSrC'): 'SSrC',
                     intFrom4CC('SWDF'): 'SWDF',
                     intFrom4CC('SWSk'): 'SWSk',
                     intFrom4CC('SWSr'): 'SWSr',
                     intFrom4CC('SWUF'): 'SWUF',
                     intFrom4CC('SWVC'): 'SWVC',
                     #                   intFrom4CC('VDMs') : 'VDMs'
                     }


class cUserAMGpioCfgSet(register_class.cDataModelArray):
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)

        AppCfgMaskLow = register_class.cHexDMTerminator(self.register,
                                                        {'name' : 'App Config Mask, GPIO High Transition or User AM Enter',
                                                         'offset': 0,
                                                         'bit length': 8})

        self.addChild(AppCfgMaskLow)

        AppCfgMaskHigh = register_class.cHexDMTerminator(self.register,
                                                            {'name' : 'App Config Mask, GPIO Low Transition or User AM Exit',
                                                             'offset': 8,
                                                             'bit length': 8})

        self.addChild(AppCfgMaskHigh)

        cmdOnlyChannel = register_class.cListDMTerminator(self.register,
                                                          {'name': 'Command Channel to use for Command (not Task) Slot',
                                                           'offset': 16,
                                                           'bit length': 2})

        cmdOnlyChannel.setMaxValue(2)
        cmdOnlyChannel.setReportList(['CMD1 (0x08)', 'CMD2 (0x09)', 'CMD3 (0x1E)'])

        self.addChild(cmdOnlyChannel)

        cmdTaskChannel = register_class.cListDMTerminator(self.register,
                                                          {'name': 'Command Channel to use for Command or Task Slot',
                                                           'offset': 24,
                                                           'bit length': 2})

        cmdTaskChannel.setMaxValue(2)
        cmdTaskChannel.setReportList(['CMD1 (0x08)', 'CMD2 (0x09)', 'CMD3 (0x1E)'])

        self.addChild(cmdTaskChannel)

        AMEntryGPIOHighCmd = register_class.cDictDMTerminator(self.register,
                                                              {
                                                                  'name': 'Alt Mode Entry / GPIO High 4CC Command (not Task)',
                                                                  'offset': 32,
                                                                  'bit length': 32})

        AMEntryGPIOHighCmd.setReportDict(cmdReportDict)

        self.addChild(AMEntryGPIOHighCmd)

        AMEntryGPIOHighCmdTsk = register_class.cDictDMTerminator(self.register,
                                                                 {
                                                                     'name': 'Alt Mode Entry / GPIO High 4CC Command or Task',
                                                                     'offset': 64,
                                                                     'bit length': 32})

        AMEntryGPIOHighCmdTsk.setReportDict(cmdTaskReportDict)

        self.addChild(AMEntryGPIOHighCmdTsk)

        AMEntryGPIOLowCmd = register_class.cDictDMTerminator(self.register,
                                                             {'name': 'Alt Mode Exit / GPIO Low 4CC Command (not Task)',
                                                              'offset': 96,
                                                              'bit length': 32})

        AMEntryGPIOLowCmd.setReportDict(cmdReportDict)

        self.addChild(AMEntryGPIOLowCmd)

        AMExitGPIOLowCmdTsk = register_class.cDictDMTerminator(self.register,
                                                               {'name': 'Alt Mode Exit / GPIO Low 4CC Command or Task',
                                                                'offset': 128,
                                                                'bit length': 32})

        AMExitGPIOLowCmdTsk.setReportDict(cmdTaskReportDict)

        self.addChild(AMExitGPIOLowCmdTsk)


class cAppConfig_0x5D_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'App configuration Register',
                                                 'address': 0x5D,
                                                 'byte length': 60,
                                                 'permission': 'RW'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name': 'App configuration',
                                                         'offset': 0,
                                                         'bit length': 80})

        for i in range(3):
            appCfgGPIO = cUserAMGpioCfgSet(self, 1,
                                           {'name': 'App Config Group %d Settings' % (i + 1),
                                            'offset': 160 * i,
                                            'bit length': 160})

            self.dataModel.addChild(appCfgGPIO)


########################################################################################################################
########################################################################################################################
########################################################################################################################


class cDataStatus_0x5F_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Data Status',
                                                 'address': 0x5F,
                                                 'byte length': 5,
                                                 'permission': 'DRO'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'Data Status',
                                                         'offset': 0,
                                                         'bit length': 40})

        DataConnection = register_class.cListDMTerminator(self,
                                                          {'name': 'Data Connection',
                                                           'offset': 0,
                                                           'bit length': 1})

        DataConnection.help = """Highlights the Data Connection present on the device"""
        DataConnection.setReportList(['No data connection (rest of bits in this register are cleared)',
                                      'Data connection present (at least one other bit in this register is nonzero)'])
        self.dataModel.addChild(DataConnection)

        DataOrientation = register_class.cListDMTerminator(self,
                                                           {'name': 'Data Orientation',
                                                            'offset': 1,
                                                            'bit length': 1})

        DataOrientation.help = """Highlights the Data Orientation present on the device"""
        DataOrientation.setReportList(['Plug is oriented on CC1 (upside-up) or no data connection',
                                       'Plug is oriented on CC2 (upside-down) with a valid data connection.'])
        self.dataModel.addChild(DataOrientation)

        CableActive = register_class.cListDMTerminator(self,
                                                       {'name': 'Cable Active Orientation',
                                                        'offset': 2,
                                                        'bit length': 1})

        CableActive.help = """Determines if an active cable is attached."""
        CableActive.setReportList(['Cable is passive', 'Cable is active'])
        self.dataModel.addChild(CableActive)

        OverCurrentOrTemperature = register_class.cListDMTerminator(self,
                                                                    {'name': 'Over Current Or Temperature',
                                                                     'offset': 3,
                                                                     'bit length': 1})

        OverCurrentOrTemperature.help = """Highlights if an Over Current Or Temperature has occurred."""
        OverCurrentOrTemperature.setReportList(['No over-current or over-temperature condition',
                                                'Over-current or over-temperature condition has occurred.'])
        self.dataModel.addChild(OverCurrentOrTemperature)

        USB2Connection = register_class.cListDMTerminator(self,
                                                          {'name': 'USB2 Connection',
                                                           'offset': 4,
                                                           'bit length': 1})

        USB2Connection.help = """Highlights if a USB2.0 Connection is present."""
        USB2Connection.setReportList(
            ['No USB2 connection to USB_RP', 'USB2 connection to USB_RP on ‘Mission’ D+/D- pair'])
        self.dataModel.addChild(USB2Connection)

        USB3Connection = register_class.cListDMTerminator(self,
                                                          {'name': 'USB3 Connection',
                                                           'offset': 5,
                                                           'bit length': 1})

        USB3Connection.help = """Highlights if a USB3.0 Connection is present."""
        USB3Connection.setReportList(
            ['No USB3 connection', 'USB3 connection on SSTx1/Rx1 if upside-up, SSTx2/Rx2 if upside down.'])
        self.dataModel.addChild(USB3Connection)

        USB3Speed = register_class.cListDMTerminator(self,
                                                     {'name': 'USB3 Speed',
                                                      'offset': 6,
                                                      'bit length': 1})

        USB3Speed.help = """highlights the USB3.0 speed capabilities."""
        USB3Speed.setReportList(['USB3 limited to Gen 1 speed (5Gbps)', 'USB3 allowed to Gen 2 speed (10Gbs)'])
        self.dataModel.addChild(USB3Speed)

        USBDataRole = register_class.cListDMTerminator(self,
                                                       {'name': 'USB Data Role',
                                                        'offset': 7,
                                                        'bit length': 1})

        USBDataRole.help = """The Data Role of the USB connection."""
        USBDataRole.setReportList(['DFP', 'UFP'])
        self.dataModel.addChild(USBDataRole)

        DPConnection = register_class.cListDMTerminator(self,
                                                        {'name': 'DisplayPort Connection',
                                                         'offset': 8,
                                                         'bit length': 1})

        DPConnection.help = """Highlights if a DisplayPort Connection has been made"""
        DPConnection.setReportList(['No DisplayPort connection.', 'DisplayPort connection'])
        self.dataModel.addChild(DPConnection)

        DPSourceSink = register_class.cListDMTerminator(self,
                                                        {'name': 'DisplayPort Source or Sink',
                                                         'offset': 9,
                                                         'bit length': 1})

        DPSourceSink.help = """Highlights if the DisplayPort Connection is a Source or Sink role."""
        DPSourceSink.setReportList(['DP Source (DFP_D) connection requested (if supported by configuration).',
                                    'DP Sink (UFP_D) connection requested (if supported by configuration).'])
        self.dataModel.addChild(DPSourceSink)

        DPPinAssignment = register_class.cListDMTerminator(self,
                                                           {'name': 'DisplayPort Pin Assignment',
                                                            'offset': 10,
                                                            'bit length': 2})

        DPPinAssignment.help = """Highlights the pin assignment of the DisplayPort connection"""
        DPPinAssignment.setReportList(['Legacy DP, USB-C to DP cable (spec pin assignments E-F, if supported).',
                                       'Legacy DP, USB-C to USB-C cable (spec pin assignments C-D, if supported).',
                                       'New DP, USB-C to USB-C cable (spec pin assignments A-B, if supported).',
                                       'Reserved'])
        self.dataModel.addChild(DPPinAssignment)

        dbgAcc = register_class.cBooleanDMTerminator(self,
                                                     {'name': 'Debug Accessory Mode',
                                                      'offset': 12,
                                                      'bit length': 1})

        dbgAcc.help = """Debug Accessory Mode"""
        self.dataModel.addChild(dbgAcc)

        IRQAck = register_class.cListDMTerminator(self,
                                                  {'name': 'IRQ Ack',
                                                   'offset': 13,
                                                   'bit length': 1})

        IRQAck.help = """IRQ has been acknowledged"""
        IRQAck.setReportList(['No IRQ', 'IRQ'])
        self.dataModel.addChild(IRQAck)

        HPDIRQsticky = register_class.cListDMTerminator(self,
                                                        {'name': 'HPD IRQ sticky',
                                                         'offset': 14,
                                                         'bit length': 1})

        HPDIRQsticky.help = """HPD IRQ from DP Sink connection to Titan Ridge to PD Controller. Cleared when Data_Status.HPD_IRQ_Sticky. Used only for TBT devices. Not used for TBT hosts."""
        HPDIRQsticky.setReportList(['No HPD IRQ', 'HPD IRQ'])
        self.dataModel.addChild(HPDIRQsticky)

        HPDLevel = register_class.cListDMTerminator(self,
                                                    {'name': 'HPD Level',
                                                     'offset': 15,
                                                     'bit length': 1})

        HPDLevel.help = """HPD level from DP Sink connection to Titan Ridge to PD Controller. Used only for TBT devices. Not used for TBT hosts."""
        HPDLevel.setReportList(['HPD Low', 'HPD High'])
        self.dataModel.addChild(HPDLevel)

        TBTConnection = register_class.cListDMTerminator(self,
                                                         {'name': 'TBT Connection',
                                                          'offset': 16,
                                                          'bit length': 1})

        TBTConnection.help = """Status of the Thunderbolt Connection."""
        TBTConnection.setReportList([
                                        'No Thunderbolt connection. This value is also used if TBT Mode is active but an Attention SVDM has been sent/received enabling USB2 instead of TBT.',
                                        'Thunderbolt connection'])
        self.dataModel.addChild(TBTConnection)

        TBTType = register_class.cListDMTerminator(self,
                                                   {'name': 'TBT Type',
                                                    'offset': 17,
                                                    'bit length': 1})

        TBTType.help = """Status of the Thunderbolt Connection."""
        TBTType.setReportList(['Type-C to Type-C Cable', 'Legacy Adapter'])
        self.dataModel.addChild(TBTType)

        CableType = register_class.cListDMTerminator(self,
                                                     {'name': 'Cable Type',
                                                      'offset': 18,
                                                      'bit length': 1})

        CableType.help = """Status of the Thunderbolt Connection."""
        CableType.setReportList(['Type-C to Type-C Cable', 'Legacy Adapter'])
        self.dataModel.addChild(CableType)

        vpro = register_class.cBooleanDMTerminator(self,
                                                   {'name': 'vPro Dock Detected',
                                                    'offset': 19,
                                                    'bit length': 1})

        self.dataModel.addChild(vpro)

        ActiveLinkTraining = register_class.cListDMTerminator(self,
                                                              {'name': 'Active Link Training',
                                                               'offset': 20,
                                                               'bit length': 1})

        ActiveLinkTraining.help = """Status of Active Link Training connection."""
        ActiveLinkTraining.setReportList(
            ['Active with bi-directional LSRX communication (also used for passive cables)',
             'Active with uni-directional LSRX communication'])
        self.dataModel.addChild(ActiveLinkTraining)

        dam = register_class.cBooleanDMTerminator(self,
                                                  {'name': 'Debug Alternate Mode Connected',
                                                   'offset': 21,
                                                   'bit length': 1})

        self.dataModel.addChild(dam)

        ForceLSX = register_class.cListDMTerminator(self,
                                                    {'name': 'Force LSX',
                                                     'offset': 23,
                                                     'bit length': 1})

        ForceLSX.help = """Force LSX"""
        ForceLSX.setReportList(['Normal operation.', 'Force LSX connection active, regardless of TBT operation'])
        self.dataModel.addChild(ForceLSX)

        S0PowerNegotiated = register_class.cListDMTerminator(self,
                                                             {'name': 'S0 Power Negotiated',
                                                              'offset': 24,
                                                              'bit length': 1})

        S0PowerNegotiated.help = """Displays if a power mismatch has occurred."""
        S0PowerNegotiated.setReportList(
            ['Active contract does not have a power mismatch or PD Controller is not a Sink',
             'Active contract (as a Sink) has a power mismatch. Not enough power for S0.'])
        self.dataModel.addChild(S0PowerNegotiated)

        TBTCableSpeedSupport = register_class.cListDMTerminator(self,
                                                                {'name': 'Thunderbolt Cable Speed Support',
                                                                 'offset': 25,
                                                                 'bit length': 3})

        TBTCableSpeedSupport.help = """Displays if a power mismatch has occurred."""
        TBTCableSpeedSupport.setReportList(
            ['Reserved', 'USB3.1 gen1 cable (10Gb/s Thunderbolt support)', '10Gb/s only', '10Gb/s & 20Gb/s only'])
        TBTCableSpeedSupport.setMaxValue(3)
        self.dataModel.addChild(TBTCableSpeedSupport)

        TBTCableGen = register_class.cListDMTerminator(self,
                                                       {'name': 'Thunderbolt Cable Gen',
                                                        'offset': 28,
                                                        'bit length': 2})

        TBTCableGen.help = """Displays if a power mismatch has occurred."""
        TBTCableGen.setReportList(['3rd generation TBT (10.3125 and 20.625 Gb/s)',
                                   '4th generation TBT (10.0, 10.3125, 20.0 and 20.625 Gb/s)'])
        TBTCableGen.setMaxValue(1)
        self.dataModel.addChild(TBTCableGen)


########################################################################################################################
########################################################################################################################
########################################################################################################################


class cRXUserVIDAttnVDM_0x60_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'RX User VID Attention VDM Register',
                                                 'address': 0x60,
                                                 'byte length': 29,
                                                 'permission': 'DRO'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name': 'RX User VID Attention VDM Register',
                                                         'offset': 0,
                                                         'bit length': 232})

        rxAttentionStatus = register_class.cDataModelArray(self, 1,
                                                           {'name': 'RX Attention Status',
                                                            'offset': 0,
                                                            'bit length': 232})

        self.dataModel.addChild(rxAttentionStatus)

        rxVdmNumValid = register_class.cDecimalDMTerminator(self,
                                                            {'name': 'Number of Valid VDOs',
                                                             'offset': 0,
                                                             'bit length': 3})

        rxVdmNumValid.help = """The number of valid VDOs assigned to this PD Controller."""
        rxVdmNumValid.updateRegisters.append(self)
        rxAttentionStatus.addChild(rxVdmNumValid)

        rxVdmSequenceNum = register_class.cDecimalDMTerminator(self,
                                                               {'name': 'Number of Register Updates',
                                                                'offset': 5,
                                                                'bit length': 3})

        rxVdmSequenceNum.help = """Increments by one every time this register is updated, rolls over upon reflow."""
        rxVdmSequenceNum.updateRegisters.append(self)
        rxAttentionStatus.addChild(rxVdmSequenceNum)

        rxDataObjects = register_class.cDataModelArray(self, 2,
                                                       {'name': 'Data Objects Received',
                                                        'offset': 8,
                                                        'bit length': 224})

        self.dataModel.addChild(rxDataObjects)

        rxDataObjectOne = cDMAnyFirstVDO(self, 1,
                                         {'name': 'Data Object 1',
                                          'offset': 0,
                                          'bit length': 32})

        rxDataObjects.addChild(rxDataObjectOne)

        for i in range(2, 8):
            dataObjX = register_class.cDataModelArray(self, 1,
                                                      {'name': 'Data Object %d' % i,
                                                       'offset': 32 * (i - 1),
                                                       'bit length': 32})

            rxDataObjects.addChild(dataObjX)

            rxDataObjectX = register_class.cHexDMTerminator(self,
                                                            {'name': 'Data Object %d' % i,
                                                             'offset': 0,
                                                             'bit length': 32})

            rxDataObjectX.help = "Data Object %d of most recently received Attention SVDM." % i
            dataObjX.addChild(rxDataObjectX)

        self.dataModel.setDataModelGenerator(cRxAttention_TopLevelDMGenerator)


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cRXUserVIDOtherVDM_0x61_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'RX User VID Other VDM Register',
                                                 'address': 0x61,
                                                 'byte length': 29,
                                                 'permission': 'DRO'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name': 'RX User VID Other VDM Register',
                                                         'offset': 0,
                                                         'bit length': 232})

        rxVdmStatus = register_class.cDataModelArray(self, 1,
                                                     {'name': 'RX VDM Status',
                                                      'offset': 0,
                                                      'bit length': 232})

        self.dataModel.addChild(rxVdmStatus)

        rxVdmNumValid = register_class.cDecimalDMTerminator(self,
                                                            {'name': 'Number of Valid VDOs',
                                                             'offset': 0,
                                                             'bit length': 3})

        rxVdmNumValid.help = """The number of valid VDOs assigned to this PD Controller."""
        rxVdmNumValid.updateRegisters.append(self)
        rxVdmStatus.addChild(rxVdmNumValid)

        rxVdmSequenceNum = register_class.cDecimalDMTerminator(self,
                                                               {'name': 'Number of Register Updates',
                                                                'offset': 5,
                                                                'bit length': 3})

        rxVdmSequenceNum.help = """Increments by one every time this register is updated, rolls over upon reflow."""
        rxVdmSequenceNum.updateRegisters.append(self)
        rxVdmStatus.addChild(rxVdmSequenceNum)

        rxDataObjects = register_class.cDataModelArray(self, 2,
                                                       {'name': 'Data Objects Received',
                                                        'offset': 8,
                                                        'bit length': 224})

        self.dataModel.addChild(rxDataObjects)

        rxDataObjectOne = cDMAnyFirstVDO(self, 1,
                                         {'name': 'Data Object 1',
                                          'offset': 0,
                                          'bit length': 32})

        rxDataObjects.addChild(rxDataObjectOne)

        for i in range(2, 8):
            dataObjX = register_class.cDataModelArray(self, 1,
                                                      {'name': 'Data Object %d' % i,
                                                       'offset': 32 * (i - 1),
                                                       'bit length': 32})

            rxDataObjects.addChild(dataObjX)

            rxDataObjectX = register_class.cHexDMTerminator(self,
                                                            {'name': 'Data Object %d' % i,
                                                             'offset': 0,
                                                             'bit length': 32})

            rxDataObjectX.help = "Data Object %d of most recently received Attention SVDM." % i
            dataObjX.addChild(rxDataObjectX)

        self.dataModel.setDataModelGenerator(cRxVdm_TopLevelDMGenerator)


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cBinaryIndices_0x62_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'App Config Binary Data Indices',
                                                 'address': 0x62,
                                                 'byte length': 10,
                                                 'permission': 'RO'})

        self.setAsShared()

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'App Config Binary Data Indices',
                                                         'offset': 0,
                                                         'bit length': 80})

        ccStart = register_class.cDecimalDMTerminator(self,
                                                      {'name': 'Country Codes Start Index',
                                                       'offset': 0,
                                                       'bit length': 8})
        self.dataModel.addChild(ccStart)

        ccLen = register_class.cDecimalDMTerminator(self,
                                                    {'name': 'Country Codes Number of Indices',
                                                     'offset': 8,
                                                     'bit length': 8})
        self.dataModel.addChild(ccLen)

        comI2Cstart = register_class.cDecimalDMTerminator(self,
                                                          {'name': 'Common I2C Record Start Index',
                                                           'offset': 16,
                                                           'bit length': 8})
        self.dataModel.addChild(comI2Cstart)

        comI2Cnum = register_class.cDecimalDMTerminator(self,
                                                        {'name': 'Common I2C Record Number of Indices',
                                                         'offset': 24,
                                                         'bit length': 8})
        self.dataModel.addChild(comI2Cnum)

        p1I2Cstart = register_class.cDecimalDMTerminator(self,
                                                         {'name': 'Port 1 I2C Record Start Index',
                                                          'offset': 32,
                                                          'bit length': 8})
        self.dataModel.addChild(p1I2Cstart)

        p1I2Clen = register_class.cDecimalDMTerminator(self,
                                                       {'name': 'Port 1 I2C Record Number of Indices',
                                                        'offset': 40,
                                                        'bit length': 8})
        self.dataModel.addChild(p1I2Clen)

        p2I2Cstart = register_class.cDecimalDMTerminator(self,
                                                         {'name': 'Port 2 I2C Record Start Index',
                                                          'offset': 48,
                                                          'bit length': 8})
        self.dataModel.addChild(p2I2Cstart)

        p2I2Clen = register_class.cDecimalDMTerminator(self,
                                                       {'name': 'Port 2 I2C Record Number of Indices',
                                                        'offset': 56,
                                                        'bit length': 8})
        self.dataModel.addChild(p2I2Clen)

        future1 = register_class.cDecimalDMTerminator(self,
                                                      {'name': 'Future Use 1',
                                                       'offset': 64,
                                                       'bit length': 8})
        future1.hide()
        self.dataModel.addChild(future1)

        future2 = register_class.cDecimalDMTerminator(self,
                                                      {'name': 'Future Use 2',
                                                       'offset': 72,
                                                       'bit length': 8})
        future2.hide()
        self.dataModel.addChild(future2)


########################################################################################################################
########################################################################################################################
########################################################################################################################


class cI2CMaster_0x64_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'I2C Master Configuration',
                                                 'address': 0x64,
                                                 'byte length': 8,
                                                 'permission': 'RO'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'Slave Address Configuration',
                                                         'offset': 0,
                                                         'bit length': 64})

        MAX_NUM_I2C_SLAVES_SUPPORTED = 8

        for i in range(MAX_NUM_I2C_SLAVES_SUPPORTED):
            slaveAddress = register_class.cHexDMTerminator(self,
                                                           {'name': 'Slave %d I2C Address' % (i + 1),
                                                            'offset': 8 * i,
                                                            'bit length': 7})
            self.dataModel.addChild(slaveAddress)


########################################################################################################################
########################################################################################################################
########################################################################################################################


class cADCresults_0x6A_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'ADC results Register',
                                                 'address': 0x6A,
                                                 'byte length': 10,
                                                 'permission': 'DRO'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name': 'ADC results',
                                                         'offset': 0,
                                                         'bit length': 80})

        ADCresults = register_class.cDataModelArray(self, 1,
                                                    {'name': 'ADC conversion results',
                                                     'offset': 0,
                                                     'bit length': 80})

        self.dataModel.addChild(ADCresults)

        SingleADC = register_class.cDecimalDMTerminator(self,
                                                        {'name': 'Single ADC conversion',
                                                         'offset': 0,
                                                         'bit length': 10})

        SingleADC.updateRegisters.append(self)

        SingleADC.help = """Latest single ADC conversion result."""

        ADCresults.addChild(SingleADC)

        Channel1ADC = register_class.cDecimalDMTerminator(self,
                                                          {'name': 'Channel 1 ADC conversion',
                                                           'offset': 16,
                                                           'bit length': 10})

        Channel1ADC.updateRegisters.append(self)

        Channel1ADC.help = """Latest Multi Channel ADC conversion for Channel 1."""

        ADCresults.addChild(Channel1ADC)

        Channel2ADC = register_class.cDecimalDMTerminator(self,
                                                          {'name': 'Channel 2 ADC conversion',
                                                           'offset': 32,
                                                           'bit length': 10})

        Channel2ADC.updateRegisters.append(self)

        Channel2ADC.help = """Latest Multi Channel ADC conversion for Channel 2."""

        ADCresults.addChild(Channel2ADC)

        Channel3ADC = register_class.cDecimalDMTerminator(self,
                                                          {'name': 'Channel 3 ADC conversion',
                                                           'offset': 48,
                                                           'bit length': 10})

        Channel3ADC.updateRegisters.append(self)

        Channel3ADC.help = """Latest Multi Channel ADC conversion for Channel 3."""

        ADCresults.addChild(Channel3ADC)

        Channel4ADC = register_class.cDecimalDMTerminator(self,
                                                          {'name': 'Channel 4 ADC conversion',
                                                           'offset': 64,
                                                           'bit length': 10})

        Channel4ADC.updateRegisters.append(self)

        Channel4ADC.help = """Latest Multi Channel ADC conversion for Channel 4."""

        ADCresults.addChild(Channel4ADC)


########################################################################################################################
########################################################################################################################
########################################################################################################################


class cHWcontrol_0x6B_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'HW control Register',
                                                 'address': 0x6B,
                                                 'byte length': 12,
                                                 'permission': 'RW'})

        self.setAsShared()

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name': 'HW control',
                                                         'offset': 0,
                                                         'bit length': 96})

        PWM = register_class.cDataModelArray(self, 1,
                                             {'name': 'PWM 1',
                                              'offset': 0,
                                              'bit length': 32})

        self.dataModel.addChild(PWM)

        PWM1enable = register_class.cBooleanDMTerminator(self,
                                                         {'name': 'Enable of PWM1',
                                                          'offset': 0,
                                                          'bit length': 1})

        PWM1enable.help = """When this bit is set high PWM1 enabled."""

        pwm1eFV = register_class.cForceSetDMTerminator(self, {'name': 'Enable of PWM1',
                                                              'offset': 0,
                                                              'bit length': 1,
                                                              'force value': int(0),
                                                              'force display': 'Disabled',
                                                              'display widget': PWM1enable})

        PWM.addChild(pwm1eFV)

        PWM1clockSource = register_class.cListDMTerminator(self,
                                                           {'name': 'PWM1 clock source',
                                                            'offset': 1,
                                                            'bit length': 1})

        PWM1clockSource.help = """When this bit is set high 24 MHz clock enabled. When this bit is set low 100 kHz clock enabled."""
        PWM1clockSource.setReportList(['100 kHz', '24 MHz'])

        pwm1csFV = register_class.cForceSetDMTerminator(self, {'name': 'PWM1 clock source',
                                                               'offset': 1,
                                                               'bit length': 1,
                                                               'force value': int(0),
                                                               'force display': '100 kHz',
                                                               'display widget': PWM1clockSource})

        PWM.addChild(pwm1csFV)

        PWM1clockPeriod = register_class.cDecimalDMTerminator(self,
                                                              {'name': 'PWM1 clock period',
                                                               'offset': 8,
                                                               'bit length': 4})

        PWM1clockPeriod.help = """PWM1 clock period."""

        pwm1cpFV = register_class.cForceSetDMTerminator(self, {'name': 'PWM1 clock period',
                                                               'offset': 8,
                                                               'bit length': 4,
                                                               'force value': int(0),
                                                               'force display': '0',
                                                               'display widget': PWM1clockPeriod})

        PWM.addChild(pwm1cpFV)

        PWM1pulsewidth = register_class.cDecimalDMTerminator(self,
                                                             {'name': 'PWM1 pulse width',
                                                              'offset': 16,
                                                              'bit length': 8})

        pwm1pwFV = register_class.cForceSetDMTerminator(self, {'name': 'PWM1 pulse width',
                                                               'offset': 16,
                                                               'bit length': 8,
                                                               'force value': int(0),
                                                               'force display': '0',
                                                               'display widget': PWM1pulsewidth})

        PWM1pulsewidth.help = """PWM1 pulse width"""

        PWM.addChild(pwm1pwFV)

        PWM2 = register_class.cDataModelArray(self, 1,
                                              {'name': 'PWM 2',
                                               'offset': 32,
                                               'bit length': 32})

        self.dataModel.addChild(PWM2)

        PWM2enable = register_class.cBooleanDMTerminator(self,
                                                         {'name': 'Enable of PWM2 ',
                                                          'offset': 0,
                                                          'bit length': 1})

        pwm2eFV = register_class.cForceSetDMTerminator(self, {'name': 'Enable of PWM2',
                                                              'offset': 0,
                                                              'bit length': 1,
                                                              'force value': int(0),
                                                              'force display': 'Disabled',
                                                              'display widget': PWM2enable})

        PWM2enable.help = """When this bit is set high PWM2 enabled."""

        PWM2.addChild(pwm2eFV)

        PWM2clockSource = register_class.cListDMTerminator(self,
                                                           {'name': 'PWM2 clock source ',
                                                            'offset': 1,
                                                            'bit length': 1})

        PWM2clockSource.setReportList(['100 kHz', '24 MHz'])

        pwm2csFV = register_class.cForceSetDMTerminator(self, {'name': 'PWM2 clock source',
                                                               'offset': 1,
                                                               'bit length': 1,
                                                               'force value': int(0),
                                                               'force display': '100 kHz',
                                                               'display widget': PWM2clockSource})

        PWM2clockSource.help = """When this bit is set high 24 MHz clock enabled. When this bit is set low 100 kHz clock enabled."""

        PWM2.addChild(pwm2csFV)

        PWM2clockPeriod = register_class.cDecimalDMTerminator(self,
                                                              {'name': 'PWM2 clock period',
                                                               'offset': 8,
                                                               'bit length': 4})

        pwm2cpFV = register_class.cForceSetDMTerminator(self, {'name': 'PWM2 clock period',
                                                               'offset': 8,
                                                               'bit length': 4,
                                                               'force value': int(0),
                                                               'force display': '0',
                                                               'display widget': PWM2clockPeriod})

        PWM2clockPeriod.help = """PWM2 clock period."""

        PWM2.addChild(pwm2cpFV)

        PWM2pulsewidth = register_class.cDecimalDMTerminator(self,
                                                             {'name': 'PWM2 pulse width',
                                                              'offset': 16,
                                                              'bit length': 8})

        pwm2pwFV = register_class.cForceSetDMTerminator(self, {'name': 'PWM2 pulse width',
                                                               'offset': 16,
                                                               'bit length': 8,
                                                               'force value': int(0),
                                                               'force display': '0',
                                                               'display widget': PWM2pulsewidth})

        PWM2pulsewidth.help = """PWM2 pulse width"""

        PWM2.addChild(pwm2pwFV)

        RCPmodes = register_class.cDataModelArray(self, 1,
                                                  {'name': 'RCP mode',
                                                   'offset': 64,
                                                   'bit length': 8})

        self.dataModel.addChild(RCPmodes)

        RCPmodeSrcPP1 = register_class.cListDMTerminator(self,
                                                         {'name': 'PP1 Src RCP mode enable',
                                                          'offset': 0,
                                                          'bit length': 1})

        RCPmodeSrcPP1.setReportList(['Comparator Mode', 'Ideal Diode Mode'])

        RCPmodeSrcPP1FV = register_class.cForceSetDMTerminator(self, {'name': 'PP1 Src RCP mode enable',
                                                                      'offset': 0,
                                                                      'bit length': 1,
                                                                      'force value': int(0),
                                                                      'force display': 'Comparator Mode',
                                                                      'display widget': RCPmodeSrcPP1})

        RCPmodeSrcPP1.help = """PP1 reverse current protection when configured as a Source. When this bit is set high, PP1 reverse current protection ideal diode mode enabled. When this bit is set low, PP1 reverse current protection comparator mode enabled."""
        RCPmodeSrcPP1.hide()
        RCPmodes.addChild(RCPmodeSrcPP1FV)

        RCPmodeSnkPP1 = register_class.cListDMTerminator(self,
                                                         {'name': 'PP1 Snk RCP mode enable',
                                                          'offset': 1,
                                                          'bit length': 1})

        RCPmodeSnkPP1.setReportList(['Ideal Diode Mode', 'Comparator Mode'])

        RCPmodeSnkPP1FV = register_class.cForceSetDMTerminator(self, {'name': 'PP1 Snk RCP mode enable',
                                                                      'offset': 1,
                                                                      'bit length': 1,
                                                                      'force value': int(0),
                                                                      'force display': 'Ideal Diode Mode',
                                                                      'display widget': RCPmodeSnkPP1})

        RCPmodeSnkPP1.help = """PP1 reverse current protection when configured as a Sink. When this bit is set high, PP1 reverse current protection comparator mode enabled. When this bit is set low, PP1 reverse current protection ideal diode mode enabled."""
        RCPmodeSnkPP1.hide()

        RCPmodes.addChild(RCPmodeSnkPP1FV)

        RCPmodeSrcPP2 = register_class.cListDMTerminator(self,
                                                         {'name': 'PP2 Src RCP mode enable',
                                                          'offset': 2,
                                                          'bit length': 1})

        RCPmodeSrcPP2.setReportList(['Comparator Mode', 'Ideal Diode Mode'])

        RCPmodeSrcPP2FV = register_class.cForceSetDMTerminator(self, {'name': 'PP2 Src RCP mode enable',
                                                                      'offset': 2,
                                                                      'bit length': 1,
                                                                      'force value': int(0),
                                                                      'force display': 'Comparator Mode',
                                                                      'display widget': RCPmodeSrcPP2})

        RCPmodeSrcPP2.help = """PP2 reverse current protection when configured as a Source. When this bit is set high, PP2 reverse current protection ideal diode mode enabled. When this bit is set low, PP2 reverse current protection comparator mode enabled."""
        RCPmodeSrcPP2.hide()

        RCPmodes.addChild(RCPmodeSrcPP2FV)

        RCPmodeSnkPP2 = register_class.cListDMTerminator(self,
                                                         {'name': 'PP2 Snk RCP mode enable',
                                                          'offset': 3,
                                                          'bit length': 1})

        RCPmodeSnkPP2.setReportList(['Ideal Diode Mode', 'Comparator Mode'])

        RCPmodeSnkPP2FV = register_class.cForceSetDMTerminator(self, {'name': 'PP2 Snk RCP mode enable',
                                                                      'offset': 3,
                                                                      'bit length': 1,
                                                                      'force value': int(0),
                                                                      'force display': 'Ideal Diode Mode',
                                                                      'display widget': RCPmodeSnkPP2})

        RCPmodeSnkPP2.help = """PP2 reverse current protection when configured as a Sink. When this bit is set high, PP2 reverse current protection comparator mode enabled. When this bit is set low, PP2 reverse current protection ideal diode mode enabled."""
        RCPmodeSnkPP2.hide()

        RCPmodes.addChild(RCPmodeSnkPP2FV)

        DisableRCPSrcPP1 = register_class.cBooleanDMTerminator(self,
                                                            {'name' : 'PP1 Src RCP mode disable',
                                                             'offset' : 4,
                                                             'bit length' : 1 })
        RCPmodes.addChild(DisableRCPSrcPP1)
        DisableRCPSrcPP2 = register_class.cBooleanDMTerminator(self,
                                                            {'name' : 'PP2 Src RCP mode disable',
                                                             'offset' : 5,
                                                             'bit length' : 1 })
        RCPmodes.addChild(DisableRCPSrcPP2)
        DisableRCPSnkPP1 = register_class.cBooleanDMTerminator(self,
                                                            {'name' : 'PP1 Snk RCP mode disable',
                                                             'offset' : 6,
                                                             'bit length' : 1 })
        RCPmodes.addChild(DisableRCPSnkPP1)
        DisableRCPSnkPP2 = register_class.cBooleanDMTerminator(self,
                                                            {'name' : 'PP2 Snk RCP mode disable',
                                                             'offset' : 7,
                                                             'bit length' : 1 })
        RCPmodes.addChild(DisableRCPSnkPP2)

########################################################################################################################
########################################################################################################################
########################################################################################################################


class cTypeCState_0x69_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Type C State Register',
                                                 'address': 0x69,
                                                 'byte length': 4,
                                                 'permission': 'DRO'})
        # Should permissions be DRO?
        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'Type C State Register',
                                                         'offset': 0,
                                                         'bit length': 32})

        CCpinForPD = register_class.cListDMTerminator(self,
                                                      {'name': 'CC Pin For PD',
                                                       'offset': 0,
                                                       'bit length': 8})
        CCpinForPD.help = """Describes which CC pin is used for PD Communication """
        CCpinForPD.setMaxValue(3)
        CCpinForPD.setReportList(['Not connected', 'C_CC1 is CC pin', 'C_CC2 is CC pin'])
        self.dataModel.addChild(CCpinForPD)

        CC1pinState = register_class.cListDMTerminator(self,
                                                       {'name': 'CC1 Pin State',
                                                        'offset': 8,
                                                        'bit length': 8})
        CC1pinState.help = """Describes state of CC1 pin"""
        CC1pinState.setMaxValue(5)
        CC1pinState.setReportList(['Not connected', 'Ra detected (Source only)', 'Rd detected (Source only)',
                                   'STD Advertisement detected (Sink only)', '1.5A Advertisement detected (Sink only)',
                                   '3.0A Advertisement detected (Sink only)'])
        self.dataModel.addChild(CC1pinState)

        CC2pinState = register_class.cListDMTerminator(self,
                                                       {'name': 'CC2 Pin State',
                                                        'offset': 16,
                                                        'bit length': 8})
        CC2pinState.help = """Describes state of CC2 pin"""
        CC2pinState.setMaxValue(5)
        CC2pinState.setReportList(['Not connected', 'Ra detected (Source only)', 'Rd detected (Source only)',
                                   'STD Advertisement detected (Sink only)', '1.5A Advertisement detected (Sink only)',
                                   '3.0A Advertisement detected (Sink only)'])
        self.dataModel.addChild(CC2pinState)

        TypeCPortState = register_class.cListDMTerminator(self,
                                                          {'name': 'Type C Port State',
                                                           'offset': 24,
                                                           'bit length': 8})
        TypeCPortState.help = """Describes state of Type C Port"""
        TypeCPortState.setMaxValue(67)
        TypeCPortState.setReportList(
            ['Disabled', 'Reserved', 'Reserved', 'Reserved', 'Reserved', 'Error Recovery', 'Reserved', 'Reserved', \
             'Reserved', 'Reserved', 'Reserved', 'Reserved', 'Reserved', 'Reserved', 'Reserved', 'Reserved', \
             'Reserved', 'Reserved', 'Reserved', 'Reserved', 'Reserved', 'Reserved', 'Reserved', 'Reserved',
             'Unattached Accessory', 'Reserved', 'Reserved', 'Reserved', 'Reserved', 'Reserved', 'Reserved', 'Reserved', \
             'Reserved', 'Reserved', 'Reserved', 'Reserved', 'Reserved', 'Reserved', 'Reserved', 'Reserved',
             'Reserved', 'Reserved', 'Reserved', 'Attach Wait Accessory', 'Reserved', 'Reserved', 'Reserved',
             'Reserved', \
             'Reserved', 'Reserved', 'Reserved', 'Reserved', 'Reserved', 'Reserved', 'Reserved', 'Reserved', \
             'Reserved', 'Reserved', 'Reserved', 'Reserved', 'Reserved', 'Reserved', 'Reserved', 'Reserved', \
             'Reserved', 'Reserved', 'Reserved', 'Reserved', 'Reserved', 'Try SRC', 'Reserved', 'Reserved', \
             'Reserved', 'Reserved', 'Reserved', 'Reserved', 'Reserved', 'Reserved', 'Try Wait SNK', 'Try SNK', \
             'Try Wait SRC', 'Reserved', 'Reserved', 'Reserved', 'Reserved', 'Reserved', 'Reserved', 'Reserved', \
             'Reserved', 'Reserved', 'Reserved', 'Reserved', 'Reserved', 'Reserved', 'Reserved', 'Reserved', \
             'Attached SRC', 'Attached SNK', 'Audio Accessory', 'Debug Accessory', 'Attach Wait SRC', 'Attach Wait SNK',
             'Unattached SNK', 'Unattached SRC'])
        self.dataModel.addChild(TypeCPortState)


########################################################################################################################
########################################################################################################################
########################################################################################################################


class cRXMIDBSOP_0x71_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Received Manufacturer Info Data Block SOP',
                                                 'address': 0x71,
                                                 'byte length': 26,
                                                 'permission': 'DRO'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'Received Manufacturer Info Data Block SOP',
                                                         'offset': 0,
                                                         'bit length': 208})

        VID = register_class.cHexDMTerminator(self,
                                              {'name': 'VID',
                                               'offset': 0,
                                               'bit length': 16})
        VID.help = """Vendor ID"""
        self.dataModel.addChild(VID)

        PID = register_class.cHexDMTerminator(self,
                                              {'name': 'PID',
                                               'offset': 16,
                                               'bit length': 16})
        PID.help = """PID"""
        self.dataModel.addChild(PID)

        ManufacturerString = register_class.cHexDMTerminator(self,
                                                             {'name': 'ManufacturerString',
                                                              'offset': 16,
                                                              'bit length': 16})
        ManufacturerString.help = """Manufacturer String"""
        self.dataModel.addChild(ManufacturerString)


########################################################################################################################
########################################################################################################################
########################################################################################################################


class cSleepControl_0x70_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Sleep Control Register',
                                                 'address': 0x70,
                                                 'byte length': 1,
                                                 'permission': 'RW'})

        self.setAsShared()

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'Sleep Control Register',
                                                         'offset': 0,
                                                         'bit length': 8})

        sleepMode = register_class.cBooleanDMTerminator(self,
                                                        {'name': 'Sleep Mode Allowed',
                                                         'offset': 0,
                                                         'bit length': 1})

        self.dataModel.addChild(sleepMode)

        delay100ms = register_class.cListDMTerminator(self,
                                                      {'name': 'Delay 100 mS Before Sleep',
                                                       'offset': 1,
                                                       'bit length': 1})

        self.dataModel.addChild(delay100ms)

        delay1000ms = register_class.cBooleanDMTerminator(self,
                                                          {'name': 'Delay 1000 mS Before Sleep',
                                                           'offset': 2,
                                                           'bit length': 1})

        self.dataModel.addChild(delay1000ms)


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cGPIOStatus_0x72_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'GPIO Status Register',
                                                 'address': 0x72,
                                                 'byte length': 8,
                                                 'permission': 'DRO'})

        # Should permissions be DRO?
        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'GPIO Status Register',
                                                         'offset': 0,
                                                         'bit length': 64})

        for i in range(22):
            GPIO = register_class.cHexDMTerminator(self,
                                                   {'name': 'GPIO%d Data' % (i),
                                                    'offset': i,
                                                    'bit length': 1})
            GPIO.help = """Logic status of GPIO[%d] \n0 - Low \n1 - High""" % (i)
            self.dataModel.addChild(GPIO)

        for i in range(22):
            GPIODir = register_class.cHexDMTerminator(self,
                                                      {'name': 'GPIO%d Direction' % (i),
                                                       'offset': 32 + i,
                                                       'bit length': 1})
            GPIODir.help = """Direction of GPIO%d \n0 - Input \n1 - Output""" % (i)
            self.dataModel.addChild(GPIODir)


class cPD3Config_0x42_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'PD3 Configuration Register',
                                                 'address': 0x42,
                                                 'byte length': 4,
                                                 'permission': 'RW'})

        self.setAsShared()
        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'PD3 Configuration Register',
                                                         'offset': 0,
                                                         'bit length': 32})

        pMSV = register_class.cListDMTerminator(self,
                                                {'name': 'Port Max Spec Revision',
                                                 'offset': 0,
                                                 'bit length': 2})

        pMSV.setMaxValue(2)

        pMSV.setReportList(['USB/PD Rev 1', 'USB/PD Rev 2', 'USB/PD Rev 3'])

        self.dataModel.addChild(pMSV)

        plMSV = register_class.cListDMTerminator(self,
                                                 {'name': 'Plug Max Spec Revision',
                                                  'offset': 2,
                                                  'bit length': 2})

        plMSV.setMaxValue(2)

        plMSV.setReportList(['USB/PD Rev 1', 'USB/PD Rev 2', 'USB/PD Rev 3'])

        self.dataModel.addChild(plMSV)

        unchunk = register_class.cBooleanDMTerminator(self,
                                                      {'name': 'Unchunked Messaging Supported',
                                                       'offset': 4,
                                                       'bit length': 1})

        self.dataModel.addChild(unchunk)

        frswap = register_class.cBooleanDMTerminator(self,
                                                     {'name': 'Fast Role Swap Supported',
                                                      'offset': 5,
                                                      'bit length': 1})

        self.dataModel.addChild(frswap)

        frDisUvp = register_class.cBooleanDMTerminator(self,
                                                       {'name': 'Fast Role Swap not Initiated by UVP',
                                                        'offset': 6,
                                                        'bit length': 1})

        self.dataModel.addChild(frDisUvp)

        frswapInit = cFRSInitmS(self,
                                {'name': 'Fast Role Swap Init in mSec',
                                 'offset': 8,
                                 'bit length': 4})

        frswapInit.setMinValue(4)
        self.dataModel.addChild(frswapInit)

        goodCrc = register_class.cBooleanDMTerminator(self,
                                                      {'name': 'Override GoodCRC Spec Rev',
                                                       'offset': 12,
                                                       'bit length': 1})
        goodCrc.hide()

        goodCrcFS = register_class.cForceSetDMTerminator(self, {'name': "Override GoodCRC Spec Rev",
                                                                'offset': 12,
                                                                'bit length': 1,
                                                                'force value': int(0),
                                                                'force display': 'False',
                                                                'display widget': goodCrc})

        goodCrcFS.hide()
        self.dataModel.addChild(goodCrcFS)


class cTxMidbSop_0x73_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Tx Manufacturer Info SOP',
                                                 'address': 0x73,
                                                 'byte length': 26,
                                                 'permission': 'RW'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'Tx Manufacturer Info SOP',
                                                         'offset': 0,
                                                         'bit length': 208})

        Vid = register_class.cHexDMTerminator(self,
                                              {'name': 'Vendor ID',
                                               'offset': 0,
                                               'bit length': 16})

        self.dataModel.addChild(Vid)

        Pid = register_class.cHexDMTerminator(self,
                                              {'name': 'Product ID',
                                               'offset': 16,
                                               'bit length': 16})

        self.dataModel.addChild(Pid)

        manString = register_class.cHexDMTerminator(self,
                                                    {'name': 'Manufacturer String',
                                                     'offset': 32,
                                                     'bit length': 176})

        self.dataModel.addChild(manString)


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cRXADO_0x74_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Received Alert Data Object (ADO) Register',
                                                 'address': 0x74,
                                                 'byte length': 4,
                                                 'permission': 'DRO'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'Received Alert Data Object (ADO) Register',
                                                         'offset': 0,
                                                         'bit length': 32})

        HotSwapBatteries = register_class.cHexDMTerminator(self,
                                                           {'name': 'Hot Swap Batteries',
                                                            'offset': 16,
                                                            'bit length': 4})
        HotSwapBatteries.help = """Status change of hot swappable batteries when selected by AlertType."""
        self.dataModel.addChild(HotSwapBatteries)

        FixedBatteries = register_class.cHexDMTerminator(self,
                                                         {'name': 'Fixed Batteries',
                                                          'offset': 20,
                                                          'bit length': 4})
        FixedBatteries.help = """Status change of fixed batteries when selected by AlertType."""
        self.dataModel.addChild(FixedBatteries)

        AlertType = register_class.cHexDMTerminator(self,
                                                    {'name': 'Alert Type',
                                                     'offset': 24,
                                                     'bit length': 8})
        AlertType.help = """Type of alert"""
        self.dataModel.addChild(AlertType)


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cTXADO_0x75_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Transmit Alert Data Object (ADO) Register',
                                                 'address': 0x75,
                                                 'byte length': 4,
                                                 'permission': 'DRW'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'Transmit Alert Data Object (ADO) Register',
                                                         'offset': 0,
                                                         'bit length': 32})

        HotSwapBatteries = register_class.cHexDMTerminator(self,
                                                           {'name': 'Hot Swap Batteries',
                                                            'offset': 16,
                                                            'bit length': 4})
        HotSwapBatteries.help = """Status change of hot swappable batteries when selected by AlertType."""
        self.dataModel.addChild(HotSwapBatteries)

        FixedBatteries = register_class.cHexDMTerminator(self,
                                                         {'name': 'Fixed Batteries',
                                                          'offset': 20,
                                                          'bit length': 4})
        FixedBatteries.help = """Status change of fixed batteries when selected by AlertType."""
        self.dataModel.addChild(FixedBatteries)

        AlertType = register_class.cHexDMTerminator(self,
                                                    {'name': 'Alert Type',
                                                     'offset': 24,
                                                     'bit length': 8})
        AlertType.help = """Type of alert"""
        self.dataModel.addChild(AlertType)


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cRXSCEDB_0x76_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {
            'register name': 'Received Source Capabilities Extended Data Block (SCEDB) Register',
            'address': 0x76,
            'byte length': 24,
            'permission': 'DRO'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {
                                                            'name': 'Received Source Capabilities Extended Data Block (SCEDB) Register',
                                                            'offset': 0,
                                                            'bit length': 184})

        VID = register_class.cHexDMTerminator(self,
                                              {'name': 'VID',
                                               'offset': 0,
                                               'bit length': 16})
        VID.help = """Vendor ID"""
        self.dataModel.addChild(VID)

        PID = register_class.cHexDMTerminator(self,
                                              {'name': 'PID',
                                               'offset': 16,
                                               'bit length': 16})
        PID.help = """PID"""
        self.dataModel.addChild(PID)

        XID = register_class.cHexDMTerminator(self,
                                              {'name': 'PXD',
                                               'offset': 32,
                                               'bit length': 32})
        XID.help = """XID"""
        self.dataModel.addChild(XID)

        FWVersion = register_class.cHexDMTerminator(self,
                                                    {'name': 'FW Version',
                                                     'offset': 64,
                                                     'bit length': 8})
        FWVersion.help = """Firmware Version"""
        self.dataModel.addChild(FWVersion)

        HWVersion = register_class.cHexDMTerminator(self,
                                                    {'name': 'HW Version',
                                                     'offset': 72,
                                                     'bit length': 8})
        HWVersion.help = """Hardware Version"""
        self.dataModel.addChild(HWVersion)

        VoltageRegulation = register_class.cHexDMTerminator(self,
                                                            {'name': 'VoltageRegulation',
                                                             'offset': 80,
                                                             'bit length': 8})
        VoltageRegulation.help = """Voltage Regulation"""
        self.dataModel.addChild(VoltageRegulation)

        HoldupTime = register_class.cHexDMTerminator(self,
                                                     {'name': 'Holdup Time',
                                                      'offset': 88,
                                                      'bit length': 8})
        HoldupTime.help = """Holdup Time"""
        self.dataModel.addChild(HoldupTime)

        Compliance = register_class.cHexDMTerminator(self,
                                                     {'name': 'Compliance',
                                                      'offset': 96,
                                                      'bit length': 8})
        Compliance.help = """Compliance"""
        self.dataModel.addChild(Compliance)

        TouchCurrent = register_class.cHexDMTerminator(self,
                                                       {'name': 'TouchCurrent',
                                                        'offset': 104,
                                                        'bit length': 8})
        TouchCurrent.help = """Touch Current"""
        self.dataModel.addChild(TouchCurrent)

        Peak_Current_1 = register_class.cHexDMTerminator(self,
                                                         {'name': 'Peak Current 1',
                                                          'offset': 112,
                                                          'bit length': 16})
        Peak_Current_1.help = """Peak Current 1"""
        self.dataModel.addChild(Peak_Current_1)

        Peak_Current_2 = register_class.cHexDMTerminator(self,
                                                         {'name': 'Peak Current 2',
                                                          'offset': 128,
                                                          'bit length': 16})
        Peak_Current_2.help = """Peak Current 1"""
        self.dataModel.addChild(Peak_Current_2)

        Peak_Current_3 = register_class.cHexDMTerminator(self,
                                                         {'name': 'Peak Current 3',
                                                          'offset': 144,
                                                          'bit length': 16})
        Peak_Current_3.help = """Peak Current 3"""
        self.dataModel.addChild(Peak_Current_3)

        Touch_Temperature = register_class.cHexDMTerminator(self,
                                                            {'name': 'Touch Temperature',
                                                             'offset': 160,
                                                             'bit length': 8})
        Touch_Temperature.help = """Touch Temperature"""
        self.dataModel.addChild(Touch_Temperature)

        Source_Inputs = register_class.cHexDMTerminator(self,
                                                        {'name': 'Source Inputs',
                                                         'offset': 168,
                                                         'bit length': 8})
        Source_Inputs.help = """Source Inputs"""
        self.dataModel.addChild(Source_Inputs)

        Batteries = register_class.cHexDMTerminator(self,
                                                    {'name': 'Batteries',
                                                     'offset': 176,
                                                     'bit length': 8})
        Batteries.help = """Batteries"""
        self.dataModel.addChild(Batteries)

        srcPdp = register_class.cHexDMTerminator(self,
                                                 {'name': 'Source PDP',
                                                  'offset': 184,
                                                  'bit length': 8})
        Batteries.help = """Source PDP"""
        self.dataModel.addChild(srcPdp)


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cPeakCurrentECField(register_class.cScalingDMTerminator):
    def __init__(self, register, iDict):
        register_class.cScalingDMTerminator.__init__(self, register, iDict)
        # map all strings representing units to scale factor
        self.dictScaleUnits = {'': 10, """%""": 10}
        self.defaultUnit = """%"""


class cOverloadPeriodECField(register_class.cScalingDMTerminator):
    def __init__(self, register, iDict):
        register_class.cScalingDMTerminator.__init__(self, register, iDict)
        # map all strings representing units to scale factor
        self.dictScaleUnits = {'': 20, 'mS': 20, 'S': 0.02}
        self.defaultUnit = 'mS'


class cDutyCycleECField(register_class.cScalingDMTerminator):
    def __init__(self, register, iDict):
        register_class.cScalingDMTerminator.__init__(self, register, iDict)
        # map all strings representing units to scale factor
        self.dictScaleUnits = {'': 5, """%""": 5}
        self.defaultUnit = """%"""


class cPeakCurrentECArray(register_class.cDataModelArray):
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)
        #
        self.addChild(cPeakCurrentECField(self.register, {'name': 'Peak Overload Current',
                                                          'offset': 0,
                                                          'bit length': 5}))

        self.addChild(cOverloadPeriodECField(self.register, {'name': 'Overload Period',
                                                             'offset': 5,
                                                             'bit length': 6}))

        self.addChild(cDutyCycleECField(self.register, {'name': 'Duty Cycle',
                                                        'offset': 11,
                                                        'bit length': 4}))

        self.addChild(register_class.cBooleanDMTerminator(self.register, {'name': 'VBus Droop',
                                                                          'offset': 15,
                                                                          'bit length': 1}))


# 8 arguments
# argsList[0] = Active bank
# argsList[1] = number of B0 PDOs
# argsList[2] = PDO1
# argsList[8] = PDO7
# argsList[9] = number of B0 PDOs
# argsList[10] = PDO1
# argsList[16] = PDO7
def PDPDerivedFxn(argsList):
    bank = argsList[0].valueToInt()

    maxPower = 0
    for i in range(argsList[1 + (8 * bank)].valueToInt()):
        if (argsList[i + 2 + (8 * bank)].maxPower() > maxPower):
            maxPower = argsList[i + 2 + (8 * bank)].maxPower()

    # maxPower in watts
    # this field also in watts, but needs to be integer type
    return long(maxPower)


class cTxSCEDB_0x77_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Tx Source Capabilities Extended Data Block',
                                                 'address': 0x77,
                                                 'byte length': 24,
                                                 'permission': 'RW'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name': 'Tx Manufacturer Info SOP',
                                                         'offset': 0,
                                                         'bit length': 184})

        idSect = register_class.cDataModelArray(self, 1,
                                                {'name': 'Identification',
                                                 'offset': 0,
                                                 'bit length': 64})

        self.dataModel.addChild(idSect)

        Vid = register_class.cHexDMTerminator(self,
                                              {'name': 'Vendor ID (VID)',
                                               'offset': 0,
                                               'bit length': 16})

        idSect.addChild(Vid)

        Pid = register_class.cHexDMTerminator(self,
                                              {'name': 'Product ID (PID)',
                                               'offset': 16,
                                               'bit length': 16})

        idSect.addChild(Pid)

        Xid = register_class.cHexDMTerminator(self,
                                              {'name': 'Manufacturer ID (XID)',
                                               'offset': 32,
                                               'bit length': 32})

        idSect.addChild(Xid)

        versSect = register_class.cDataModelArray(self, 1,
                                                  {'name': 'Version',
                                                   'offset': 64,
                                                   'bit length': 16})

        self.dataModel.addChild(versSect)

        fwVersion = register_class.cHexDMTerminator(self,
                                                    {'name': 'Firmware Version',
                                                     'offset': 0,
                                                     'bit length': 8})

        versSect.addChild(fwVersion)

        hwVersion = register_class.cHexDMTerminator(self,
                                                    {'name': 'Hardware Version',
                                                     'offset': 8,
                                                     'bit length': 8})

        versSect.addChild(hwVersion)

        vrSect = register_class.cDataModelArray(self, 1,
                                                {'name': 'Voltage Regulation',
                                                 'offset': 80,
                                                 'bit length': 8})

        self.dataModel.addChild(vrSect)

        vReg = register_class.cListDMTerminator(self,
                                                {'name': 'Load Step',
                                                 'offset': 0,
                                                 'bit length': 2})

        vReg.setMaxValue(0)
        vReg.setReportList(['150 mA/uSec Load Step'])

        vrSect.addChild(vReg)

        ioc = register_class.cListDMTerminator(self,
                                               {'name': 'Ioc',
                                                'offset': 2,
                                                'bit length': 1})

        ioc.setReportList(["""25% IoC""", """90% IoC"""])

        vrSect.addChild(ioc)

        holdUp = register_class.cHexDMTerminator(self,
                                                 {'name': 'Holdup Time',
                                                  'offset': 88,
                                                  'bit length': 8})

        self.dataModel.addChild(holdUp)

        compSect = register_class.cDataModelArray(self, 1,
                                                  {'name': 'Compliance',
                                                   'offset': 96,
                                                   'bit length': 8})

        self.dataModel.addChild(compSect)

        lps = register_class.cBooleanDMTerminator(self,
                                                  {'name': 'LPS Compliant',
                                                   'offset': 0,
                                                   'bit length': 1})

        compSect.addChild(lps)

        ps1 = register_class.cBooleanDMTerminator(self,
                                                  {'name': 'PS1 Compliant',
                                                   'offset': 1,
                                                   'bit length': 1})

        compSect.addChild(ps1)

        ps2 = register_class.cBooleanDMTerminator(self,
                                                  {'name': 'PS2 Compliant',
                                                   'offset': 2,
                                                   'bit length': 1})

        compSect.addChild(ps2)

        tcSect = register_class.cDataModelArray(self, 1,
                                                {'name': 'Touch Current',
                                                 'offset': 104,
                                                 'bit length': 8})

        self.dataModel.addChild(tcSect)

        eps = register_class.cBooleanDMTerminator(self,
                                                  {'name': 'Low Touch Current EPS',
                                                   'offset': 0,
                                                   'bit length': 1})

        tcSect.addChild(eps)

        gps = register_class.cBooleanDMTerminator(self,
                                                  {'name': 'Ground Pin Supported',
                                                   'offset': 1,
                                                   'bit length': 1})

        tcSect.addChild(gps)

        gppe = register_class.cBooleanDMTerminator(self,
                                                   {'name': 'Ground Pin Intended for Protective Earth',
                                                    'offset': 2,
                                                    'bit length': 1})

        tcSect.addChild(gppe)

        peakCurrent1 = cPeakCurrentECArray(self, 1,
                                           {'name': 'Peak Current 1',
                                            'offset': 112,
                                            'bit length': 16})

        self.dataModel.addChild(peakCurrent1)

        peakCurrent2 = cPeakCurrentECArray(self, 1,
                                           {'name': 'Peak Current 2',
                                            'offset': 128,
                                            'bit length': 16})

        self.dataModel.addChild(peakCurrent2)

        peakCurrent3 = cPeakCurrentECArray(self, 1,
                                           {'name': 'Peak Current 3',
                                            'offset': 144,
                                            'bit length': 16})

        self.dataModel.addChild(peakCurrent3)

        ttSect = register_class.cDataModelArray(self, 1,
                                                {'name': 'Touch Temperature',
                                                 'offset': 160,
                                                 'bit length': 8})

        self.dataModel.addChild(ttSect)

        touchtemp = register_class.cListDMTerminator(self,
                                                     {'name': 'Touch Temperature',
                                                      'offset': 0,
                                                      'bit length': 8})

        touchtemp.setMaxValue(2)
        touchtemp.setReportList(['IEC 60950-1 Compliant', 'IEC 62368-1 TS1 Compliant', 'IEC 62368-1 TS2 Compliant'])

        ttSect.addChild(touchtemp)

        siSect = register_class.cDataModelArray(self, 1,
                                                {'name': 'Source Inputs',
                                                 'offset': 168,
                                                 'bit length': 8})

        self.dataModel.addChild(siSect)

        esp = register_class.cBooleanDMTerminator(self,
                                                  {'name': 'External Supply Present',
                                                   'offset': 0,
                                                   'bit length': 1})

        siSect.addChild(esp)

        esc = register_class.cBooleanDMTerminator(self,
                                                  {'name': 'External Supply is Unconstrained',
                                                   'offset': 1,
                                                   'bit length': 1})

        siSect.addChild(esc)

        ibp = register_class.cBooleanDMTerminator(self,
                                                  {'name': 'Internal Battery Present',
                                                   'offset': 2,
                                                   'bit length': 1})

        siSect.addChild(ibp)

        nbSect = register_class.cDataModelArray(self, 1,
                                                {'name': 'Number of Batteries',
                                                 'offset': 176,
                                                 'bit length': 8})

        self.dataModel.addChild(nbSect)

        nfb = register_class.cDecimalDMTerminator(self,
                                                  {'name': 'Number of Fixed Batteries',
                                                   'offset': 0,
                                                   'bit length': 4})

        nfb.setMaxValue(4)
        nbSect.addChild(nfb)

        nhsb = register_class.cDecimalDMTerminator(self,
                                                   {'name': 'Number of Hot-swappable Batteries',
                                                    'offset': 4,
                                                    'bit length': 4})

        nhsb.setMaxValue(4)
        nbSect.addChild(nhsb)

        PDP = cPDPPowerField(self,
                             {'name': 'Source PD Power',
                              'offset': 184,
                              'bit length': 8})

        PDP.help = """PD Power sourced in Watts.  Calculated from Transmit Source Capabilities (0x32) register"""

        PDP.registerAsDerivedField(PDPDerivedFxn, None,
                                   [ \
                                       ['Transmit Source Capabilities', 'Tx Source PDO Config', 'Active PDO Bank'], \
                                       ['Transmit Source Capabilities', 'Bank 0 Settings',
                                        'Number of Bank 0 Source PDOs'], \
                                       ['Transmit Source Capabilities', 'Bank 0 Settings', 'Source PDO 1'], \
                                       ['Transmit Source Capabilities', 'Bank 0 Settings', 'Source PDO 2'], \
                                       ['Transmit Source Capabilities', 'Bank 0 Settings', 'Source PDO 3'], \
                                       ['Transmit Source Capabilities', 'Bank 0 Settings', 'Source PDO 4'], \
                                       ['Transmit Source Capabilities', 'Bank 0 Settings', 'Source PDO 5'], \
                                       ['Transmit Source Capabilities', 'Bank 0 Settings', 'Source PDO 6'], \
                                       ['Transmit Source Capabilities', 'Bank 0 Settings', 'Source PDO 7'], \
                                       ['Transmit Source Capabilities', 'Bank 1 Settings',
                                        'Number of Bank 1 Source PDOs'], \
                                       ['Transmit Source Capabilities', 'Bank 1 Settings', 'Source PDO 1'], \
                                       ['Transmit Source Capabilities', 'Bank 1 Settings', 'Source PDO 2'], \
                                       ['Transmit Source Capabilities', 'Bank 1 Settings', 'Source PDO 3'], \
                                       ['Transmit Source Capabilities', 'Bank 1 Settings', 'Source PDO 4'], \
                                       ['Transmit Source Capabilities', 'Bank 1 Settings', 'Source PDO 5'], \
                                       ['Transmit Source Capabilities', 'Bank 1 Settings', 'Source PDO 6'], \
                                       ['Transmit Source Capabilities', 'Bank 1 Settings', 'Source PDO 7'], \
                                       ])

        PDP.lock()

        self.dataModel.addChild(PDP)


########################################################################################################################
########################################################################################################################
########################################################################################################################


class cRXSBD_0x78_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Received Status Data Block (SDB) Register',
                                                 'address': 0x78,
                                                 'byte length': 5,
                                                 'permission': 'DRO'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'Received Status Data Block (SDB) Register',
                                                         'offset': 0,
                                                         'bit length': 40})

        Internal_Temperature = register_class.cDecimalDMTerminator(self,
                                                                   {'name': 'Internal Temperature',
                                                                    'offset': 0,
                                                                    'bit length': 8})
        Internal_Temperature.help = """Status of Internal Temperature."""
        self.dataModel.addChild(Internal_Temperature)

        Present_Input = register_class.cHexDMTerminator(self,
                                                        {'name': 'Present Input',
                                                         'offset': 8,
                                                         'bit length': 8})
        Present_Input.help = """Status of Present Input."""
        self.dataModel.addChild(Present_Input)

        Present_Battery_Input = register_class.cHexDMTerminator(self,
                                                                {'name': 'Present Battery Input',
                                                                 'offset': 16,
                                                                 'bit length': 8})
        Present_Battery_Input.help = """Status of Present Battery Input"""
        self.dataModel.addChild(Present_Battery_Input)

        eventFlags = register_class.cHexDMTerminator(self,
                                                     {'name': 'Event Flags',
                                                      'offset': 24,
                                                      'bit length': 8})
        self.dataModel.addChild(eventFlags)

        tmpStat = register_class.cHexDMTerminator(self,
                                                  {'name': 'Temperature Status',
                                                   'offset': 32,
                                                   'bit length': 8})
        self.dataModel.addChild(tmpStat)


########################################################################################################################
########################################################################################################################
########################################################################################################################


class cTXSBD_0x79_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Transmitted Status Data Block (SDB) Register',
                                                 'address': 0x79,
                                                 'byte length': 5,
                                                 'permission': 'DRW'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'Transmitted Status Data Block (SDB) Register',
                                                         'offset': 0,
                                                         'bit length': 24})

        Internal_Temperature = register_class.cDecimalDMTerminator(self,
                                                                   {'name': 'Internal Temperature',
                                                                    'offset': 0,
                                                                    'bit length': 8})
        Internal_Temperature.help = """Status of Internal Temperature."""
        self.dataModel.addChild(Internal_Temperature)

        Present_Input = register_class.cHexDMTerminator(self,
                                                        {'name': 'Present Input',
                                                         'offset': 8,
                                                         'bit length': 8})
        Present_Input.help = """Status of Present Input."""
        self.dataModel.addChild(Present_Input)

        Present_Battery_Input = register_class.cHexDMTerminator(self,
                                                                {'name': 'Present Battery Input',
                                                                 'offset': 16,
                                                                 'bit length': 8})
        Present_Battery_Input.help = """Status of Present Battery Input"""
        self.dataModel.addChild(Present_Battery_Input)

        eventFlags = register_class.cHexDMTerminator(self,
                                                     {'name': 'Event Flags',
                                                      'offset': 24,
                                                      'bit length': 8})
        self.dataModel.addChild(eventFlags)

        tmpStat = register_class.cHexDMTerminator(self,
                                                  {'name': 'Temperature Status',
                                                   'offset': 32,
                                                   'bit length': 8})
        self.dataModel.addChild(tmpStat)


########################################################################################################################
########################################################################################################################
########################################################################################################################


class cRXBSDO_0x7A_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self,
                                          {'register name': 'Received Battery Status Data Objects (BSDO) Register',
                                           'address': 0x7A,
                                           'byte length': 32,
                                           'permission': 'DRO'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'Received Battery Status Data Objects (BSDO) Register',
                                                         'offset': 0,
                                                         'bit length': 256})

        BatteryInfo = register_class.cDecimalDMTerminator(self,
                                                          {'name': 'Battery Info',
                                                           'offset': 8,
                                                           'bit length': 8})
        BatteryInfo.help = """Battery State"""
        self.dataModel.addChild(BatteryInfo)

        BatteryPC = register_class.cHexDMTerminator(self,
                                                    {'name': 'Battery State of Charge (SOC)',
                                                     'offset': 16,
                                                     'bit length': 16})
        BatteryPC.help = """Battery's State of Charge (SOC)."""
        self.dataModel.addChild(BatteryPC)

        Fixed_Battery_0 = register_class.cHexDMTerminator(self,
                                                          {'name': 'Latest BSDO Fixed Battery 0',
                                                           'offset': 32,
                                                           'bit length': 32})
        Fixed_Battery_0.help = """Latest BSDO Fixed Battery 0"""
        self.dataModel.addChild(Fixed_Battery_0)

        Fixed_Battery_1 = register_class.cHexDMTerminator(self,
                                                          {'name': 'Latest BSDO Fixed Battery 1',
                                                           'offset': 64,
                                                           'bit length': 32})
        Fixed_Battery_1.help = """Latest BSDO Fixed Battery 1"""
        self.dataModel.addChild(Fixed_Battery_1)

        Fixed_Battery_2 = register_class.cHexDMTerminator(self,
                                                          {'name': 'Latest BSDO Fixed Battery 2',
                                                           'offset': 96,
                                                           'bit length': 32})
        Fixed_Battery_2.help = """Latest BSDO Fixed Battery 2"""
        self.dataModel.addChild(Fixed_Battery_2)

        Fixed_Battery_3 = register_class.cHexDMTerminator(self,
                                                          {'name': 'Latest BSDO Fixed Battery 3',
                                                           'offset': 128,
                                                           'bit length': 32})
        Fixed_Battery_3.help = """Latest BSDO Fixed Battery 3"""
        self.dataModel.addChild(Fixed_Battery_3)

        HotSwap_Battery_0 = register_class.cHexDMTerminator(self,
                                                            {'name': 'Latest BSDO Hot-Swappable Battery 0',
                                                             'offset': 160,
                                                             'bit length': 32})
        HotSwap_Battery_0.help = """Latest BSDO Hot-Swappable Battery 0"""
        self.dataModel.addChild(HotSwap_Battery_0)

        HotSwap_Battery_1 = register_class.cHexDMTerminator(self,
                                                            {'name': 'Latest BSDO Hot-Swappable Battery 1',
                                                             'offset': 192,
                                                             'bit length': 32})
        HotSwap_Battery_1.help = """Latest BSDO Hot-Swappable Battery 1"""
        self.dataModel.addChild(HotSwap_Battery_1)

        HotSwap_Battery_2 = register_class.cHexDMTerminator(self,
                                                            {'name': 'Latest BSDO Hot-Swappable Battery 2',
                                                             'offset': 224,
                                                             'bit length': 32})
        HotSwap_Battery_2.help = """Latest BSDO Hot-Swappable Battery 2"""
        self.dataModel.addChild(HotSwap_Battery_2)

        HotSwap_Battery_3 = register_class.cHexDMTerminator(self,
                                                            {'name': 'Latest BSDO Hot-Swappable Battery 3',
                                                             'offset': 256,
                                                             'bit length': 32})
        HotSwap_Battery_3.help = """Latest BSDO Hot-Swappable Battery 3"""
        self.dataModel.addChild(HotSwap_Battery_3)


########################################################################################################################
########################################################################################################################
########################################################################################################################


class cTXBSDO_0x7B_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self,
                                          {'register name': 'Transmitted Battery Status Data Objects (BSDO) Register',
                                           'address': 0x7B,
                                           'byte length': 32,
                                           'permission': 'DRW'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {
                                                            'name': 'Transmitted Battery Status Data Objects (BSDO) Register',
                                                            'offset': 0,
                                                            'bit length': 256})

        BatteryInfo = register_class.cDecimalDMTerminator(self,
                                                          {'name': 'Battery Info',
                                                           'offset': 8,
                                                           'bit length': 8})
        BatteryInfo.help = """Battery State"""
        self.dataModel.addChild(BatteryInfo)

        BatteryPC = register_class.cHexDMTerminator(self,
                                                    {'name': 'Battery State of Charge (SOC)',
                                                     'offset': 16,
                                                     'bit length': 16})
        BatteryPC.help = """Battery's State of Charge (SOC)."""
        self.dataModel.addChild(BatteryPC)

        Fixed_Battery_0 = register_class.cHexDMTerminator(self,
                                                          {'name': 'Latest BSDO Fixed Battery 0',
                                                           'offset': 32,
                                                           'bit length': 32})
        Fixed_Battery_0.help = """Latest BSDO Fixed Battery 0"""
        self.dataModel.addChild(Fixed_Battery_0)

        Fixed_Battery_1 = register_class.cHexDMTerminator(self,
                                                          {'name': 'Latest BSDO Fixed Battery 1',
                                                           'offset': 64,
                                                           'bit length': 32})
        Fixed_Battery_1.help = """Latest BSDO Fixed Battery 1"""
        self.dataModel.addChild(Fixed_Battery_1)

        Fixed_Battery_2 = register_class.cHexDMTerminator(self,
                                                          {'name': 'Latest BSDO Fixed Battery 2',
                                                           'offset': 96,
                                                           'bit length': 32})
        Fixed_Battery_2.help = """Latest BSDO Fixed Battery 2"""
        self.dataModel.addChild(Fixed_Battery_2)

        Fixed_Battery_3 = register_class.cHexDMTerminator(self,
                                                          {'name': 'Latest BSDO Fixed Battery 3',
                                                           'offset': 128,
                                                           'bit length': 32})
        Fixed_Battery_3.help = """Latest BSDO Fixed Battery 3"""
        self.dataModel.addChild(Fixed_Battery_3)

        HotSwap_Battery_0 = register_class.cHexDMTerminator(self,
                                                            {'name': 'Latest BSDO Hot-Swappable Battery 0',
                                                             'offset': 160,
                                                             'bit length': 32})
        HotSwap_Battery_0.help = """Latest BSDO Hot-Swappable Battery 0"""
        self.dataModel.addChild(HotSwap_Battery_0)

        HotSwap_Battery_1 = register_class.cHexDMTerminator(self,
                                                            {'name': 'Latest BSDO Hot-Swappable Battery 1',
                                                             'offset': 192,
                                                             'bit length': 32})
        HotSwap_Battery_1.help = """Latest BSDO Hot-Swappable Battery 1"""
        self.dataModel.addChild(HotSwap_Battery_1)

        HotSwap_Battery_2 = register_class.cHexDMTerminator(self,
                                                            {'name': 'Latest BSDO Hot-Swappable Battery 2',
                                                             'offset': 224,
                                                             'bit length': 32})
        HotSwap_Battery_2.help = """Latest BSDO Hot-Swappable Battery 2"""
        self.dataModel.addChild(HotSwap_Battery_2)

        HotSwap_Battery_3 = register_class.cHexDMTerminator(self,
                                                            {'name': 'Latest BSDO Hot-Swappable Battery 3',
                                                             'offset': 256,
                                                             'bit length': 32})
        HotSwap_Battery_3.help = """Latest BSDO Hot-Swappable Battery 3"""
        self.dataModel.addChild(HotSwap_Battery_3)


########################################################################################################################
########################################################################################################################
########################################################################################################################


class cRXBCDB_0x7C_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self,
                                          {'register name': 'Received Battery Capability Data Block (BCDB) Register',
                                           'address': 0x7C,
                                           'byte length': 9,
                                           'permission': 'DRO'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {
                                                            'name': 'Received Battery Capability Data Block (BCDB) Register',
                                                            'offset': 0,
                                                            'bit length': 192})

        VID = register_class.cDecimalDMTerminator(self,
                                                  {'name': 'VID',
                                                   'offset': 0,
                                                   'bit length': 16})
        VID.help = """Status of VID."""
        self.dataModel.addChild(VID)

        PID = register_class.cHexDMTerminator(self,
                                              {'name': 'PID',
                                               'offset': 16,
                                               'bit length': 16})
        PID.help = """Status of PID."""
        self.dataModel.addChild(PID)

        Battery_Design_Capacity = register_class.cDecimalDMTerminator(self,
                                                                      {'name': 'Battery Design Capacity',
                                                                       'offset': 32,
                                                                       'bit length': 16})
        Battery_Design_Capacity.help = """Battery Design Capacity"""
        self.dataModel.addChild(Battery_Design_Capacity)

        Battery_Last_Full_Charge_Capacity = register_class.cDecimalDMTerminator(self,
                                                                                {
                                                                                    'name': 'Battery Last Full Charge Capacity',
                                                                                    'offset': 48,
                                                                                    'bit length': 16})
        Battery_Last_Full_Charge_Capacity.help = """Battery Last Full Charge Capacity"""
        self.dataModel.addChild(Battery_Last_Full_Charge_Capacity)

        Battery_Type = register_class.cDecimalDMTerminator(self,
                                                           {'name': 'Battery Type',
                                                            'offset': 64,
                                                            'bit length': 8})
        Battery_Type.help = """Battery Type"""
        self.dataModel.addChild(Battery_Type)


########################################################################################################################
########################################################################################################################
########################################################################################################################


class cBatteryECArray(register_class.cDataModelArray):
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)
        #

        Vid = register_class.cHexDMTerminator(self.register,
                                              {'name': 'Vendor ID',
                                               'offset': 0,
                                               'bit length': 16})

        self.addChild(Vid)

        Pid = register_class.cHexDMTerminator(self.register,
                                              {'name': 'Product ID',
                                               'offset': 16,
                                               'bit length': 16})

        self.addChild(Pid)

        battCap = register_class.cHexDMTerminator(self.register,
                                                  {'name': 'Battery Design Capacity',
                                                   'offset': 32,
                                                   'bit length': 16})

        self.addChild(battCap)

        battLFCCap = register_class.cHexDMTerminator(self.register,
                                                     {'name': 'Battery Last Full Charge Capacity',
                                                      'offset': 48,
                                                      'bit length': 16})

        self.addChild(battLFCCap)

        batteryType = register_class.cHexDMTerminator(self.register,
                                                      {'name': 'Battery Type',
                                                       'offset': 64,
                                                       'bit length': 8})

        self.addChild(batteryType)


class cTxBatteryCapabilities_0x7D_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Tx Battery Capabilities',
                                                 'address': 0x7D,
                                                 'byte length': 63,
                                                 'permission': 'RW'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name': 'Tx Battery Capabilities',
                                                         'offset': 0,
                                                         'bit length': 504})

        for i in range(4):
            self.dataModel.addChild(cBatteryECArray(self, 1,
                                                    {'name': 'Fixed Battery #%d Capabilities' % (i + 1),
                                                     'offset': i * 72,
                                                     'bit length': 72}))

        for i in range(3):
            self.dataModel.addChild(cBatteryECArray(self, 1,
                                                    {'name': 'Hot-Pluggable Battery #%d Capabilities' % (i + 1),
                                                     'offset': 288 + 72 * i,
                                                     'bit length': 72}))


########################################################################################################################
########################################################################################################################
########################################################################################################################


class cRXMIDB_0x7E_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {
            'register name': 'Received Manufacturer Info Data Block SOPp (MIDB) Register',
            'address': 0x7E,
            'byte length': 26,
            'permission': 'DRO'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {
                                                            'name': 'Received Manufacturer Info Data Block SOPp (MIDB) Register',
                                                            'offset': 0,
                                                            'bit length': 208})

        VID = register_class.cDecimalDMTerminator(self,
                                                  {'name': 'VID',
                                                   'offset': 0,
                                                   'bit length': 16})
        VID.help = """Status of VID."""
        self.dataModel.addChild(VID)

        PID = register_class.cHexDMTerminator(self,
                                              {'name': 'PID',
                                               'offset': 16,
                                               'bit length': 16})
        PID.help = """Status of PID."""
        self.dataModel.addChild(PID)

        Manufacturer_String = register_class.cDecimalDMTerminator(self,
                                                                  {'name': 'Manufacturer String',
                                                                   'offset': 32,
                                                                   'bit length': 176})
        Manufacturer_String.help = """Manufacturer String."""
        self.dataModel.addChild(Manufacturer_String)


########################################################################################################################
########################################################################################################################
########################################################################################################################


class cTxMidbSopPrime_0x7F_register(register_class.cRegister):
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name': 'Tx Manufacturer Info SOP Prime',
                                                 'address': 0x7F,
                                                 'byte length': 26,
                                                 'permission': 'RW'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name': 'Tx Manufacturer Info SOP',
                                                         'offset': 0,
                                                         'bit length': 208})

        Vid = register_class.cHexDMTerminator(self,
                                              {'name': 'Vendor ID',
                                               'offset': 0,
                                               'bit length': 16})

        self.dataModel.addChild(Vid)

        Pid = register_class.cHexDMTerminator(self,
                                              {'name': 'Product ID',
                                               'offset': 16,
                                               'bit length': 16})

        self.dataModel.addChild(Pid)

        manString = register_class.cHexDMTerminator(self,
                                                    {'name': 'Manufacturer String',
                                                     'offset': 32,
                                                     'bit length': 176})

        self.dataModel.addChild(manString)


########################################################################################################################
########################################################################################################################
########################################################################################################################


# host interface function list

task_return_dict = {0x00000000: 'SUCCESS_CMD', 0x00000001: 'ABORT_CMD', 0x00000003: 'REJECT_CMD'}


class cPDOCurrentField(register_class.cScalingDMTerminator):
    def __init__(self, register, iDict):
        register_class.cScalingDMTerminator.__init__(self, register, iDict)
        # map all strings representing units to scale factor
        self.dictScaleUnits = {'': 0.01, 'A': 0.01, 'mA': 10.0}
        self.defaultUnit = 'A'


class cPDOVoltageField(register_class.cScalingDMTerminator):
    def __init__(self, register, iDict):
        register_class.cScalingDMTerminator.__init__(self, register, iDict)
        # map all strings representing units to scale factor
        self.dictScaleUnits = {'': 0.05, 'V': 0.05, 'mV': 50.0}
        self.defaultUnit = 'V'


class cPDOPowerField(register_class.cScalingDMTerminator):
    def __init__(self, register, iDict):
        register_class.cScalingDMTerminator.__init__(self, register, iDict)
        # map all strings representing units to scale factor
        self.dictScaleUnits = {'': 0.25, 'W': 0.25, 'mW': 250.0}
        self.defaultUnit = 'W'


class cDBfg(function_class.cFunction):
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name': 'Deadbattery Flag Clear',
                                                 '4cc': 'DBfg',
                                                 'inargs byte length': 0,
                                                 'outargs byte length': 1})

        self.inargsDataModel = None
        outargsDM = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                   {'name': 'Return Values',
                                                    'offset': 0,
                                                    'bit length': 8})

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                     {'name': 'Task Return Status',
                                                      'offset': 0,
                                                      'bit length': 8})

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        outargsDM.addChild(TSKReturn)

        self.setOutputModel(outargsDM)


class cABRT(function_class.cFunction):
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name': 'Abort',
                                                 '4cc': 'ABRT',
                                                 'inargs byte length': 0,
                                                 'outargs byte length': 1})

        self.inargsDataModel = None
        outargsDM = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                   {'name': 'Return Values',
                                                    'offset': 0,
                                                    'bit length': 8})

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                     {'name': 'Task Return Status',
                                                      'offset': 0,
                                                      'bit length': 8})

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        outargsDM.addChild(TSKReturn)

        self.setOutputModel(outargsDM)


class cGaid(function_class.cFunction):
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name': 'Warm Reboot',
                                                 '4cc': 'Gaid',
                                                 'inargs byte length': 0,
                                                 'outargs byte length': 0})

        self.inargsDataModel = None
        self.outargsDataModel = None


class cGAID(function_class.cFunction):
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name': 'Cold Reboot',
                                                 '4cc': 'GAID',
                                                 'inargs byte length': 0,
                                                 'outargs byte length': 0})

        self.inargsDataModel = None
        self.outargsDataModel = None


class cHRST(function_class.cFunction):
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name': 'PD Hard Reset',
                                                 '4cc': 'HRST',
                                                 'inargs byte length': 0,
                                                 'outargs byte length': 1})

        self.inargsDataModel = None
        outargsDM = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                   {'name': 'Return Values',
                                                    'offset': 0,
                                                    'bit length': 8})

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                     {'name': 'Task Return Status',
                                                      'offset': 0,
                                                      'bit length': 8})

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        outargsDM.addChild(TSKReturn)

        self.setOutputModel(outargsDM)


class cCRST(function_class.cFunction):
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name': 'Cable Reset',
                                                 '4cc': 'CRST',
                                                 'inargs byte length': 0,
                                                 'outargs byte length': 1})

        self.inargsDataModel = None
        outargsDM = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                   {'name': 'Return Values',
                                                    'offset': 0,
                                                    'bit length': 8})

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                     {'name': 'Task Return Status',
                                                      'offset': 0,
                                                      'bit length': 8})

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        outargsDM.addChild(TSKReturn)

        self.setOutputModel(outargsDM)


class cGSkC(function_class.cFunction):
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name': 'Get Sink Capabilities',
                                                 '4cc': 'GSkC',
                                                 'inargs byte length': 0,
                                                 'outargs byte length': 1})

        self.inargsDataModel = None
        outargsDM = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                   {'name': 'Return Values',
                                                    'offset': 0,
                                                    'bit length': 8})

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                     {'name': 'Task Return Status',
                                                      'offset': 0,
                                                      'bit length': 8})

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        outargsDM.addChild(TSKReturn)

        self.setOutputModel(outargsDM)


class cGSrC(function_class.cFunction):
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name': 'Get Source Capabilities',
                                                 '4cc': 'GSrC',
                                                 'inargs byte length': 0,
                                                 'outargs byte length': 1})

        self.inargsDataModel = None
        outargsDM = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                   {'name': 'Return Values',
                                                    'offset': 0,
                                                    'bit length': 8})

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                     {'name': 'Task Return Status',
                                                      'offset': 0,
                                                      'bit length': 8})

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        outargsDM.addChild(TSKReturn)

        self.setOutputModel(outargsDM)


class cSSrC(function_class.cFunction):
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name': 'Send Source Capabilities',
                                                 '4cc': 'SSrC',
                                                 'inargs byte length': 0,
                                                 'outargs byte length': 1})

        self.inargsDataModel = None
        outargsDM = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                   {'name': 'Return Values',
                                                    'offset': 0,
                                                    'bit length': 8})

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                     {'name': 'Task Return Status',
                                                      'offset': 0,
                                                      'bit length': 8})

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        outargsDM.addChild(TSKReturn)

        self.setOutputModel(outargsDM)


class cSRDO(function_class.cFunction):
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name': 'Send Request Data Object',
                                                 '4cc': 'SRDO',
                                                 'inargs byte length': 4,
                                                 'outargs byte length': 1})

        inargsDM = register_class.cDataModelArray(self, 1,
                                                  {'name': 'Input Arguments',
                                                   'offset': 0,
                                                   'bit length': 32})

        mmOpCurr = cPDOCurrentField(self.inargsMiniReg, {'name': 'Max/Min Operating Current or Power',
                                                         'offset': 0,
                                                         'bit length': 10})
        inargsDM.addChild(mmOpCurr)

        opCurr = cPDOCurrentField(self.inargsMiniReg, {'name': 'Operating Current or Power',
                                                       'offset': 10,
                                                       'bit length': 10})
        inargsDM.addChild(opCurr)

        noUSBSusp = register_class.cBooleanDMTerminator(self.inargsMiniReg, {'name': 'No USB Suspend',
                                                                             'offset': 24,
                                                                             'bit length': 1})
        inargsDM.addChild(noUSBSusp)

        USBCommCap = register_class.cBooleanDMTerminator(self.inargsMiniReg, {'name': 'USB Communications Capable',
                                                                              'offset': 25,
                                                                              'bit length': 1})
        inargsDM.addChild(USBCommCap)

        capMismatch = register_class.cBooleanDMTerminator(self.inargsMiniReg, {'name': 'Capability Mismatch',
                                                                               'offset': 26,
                                                                               'bit length': 1})
        inargsDM.addChild(capMismatch)

        giveBack = register_class.cBooleanDMTerminator(self.inargsMiniReg, {'name': 'Give Back Flag',
                                                                            'offset': 27,
                                                                            'bit length': 1})
        inargsDM.addChild(giveBack)

        objPosn = register_class.cDecimalDMTerminator(self.inargsMiniReg, {'name': 'Object Position',
                                                                           'offset': 28,
                                                                           'bit length': 3})
        inargsDM.addChild(objPosn)

        self.setInputModel(inargsDM)

        outargsDM = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                   {'name': 'Return Values',
                                                    'offset': 0,
                                                    'bit length': 8})

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                     {'name': 'Task Return Status',
                                                      'offset': 0,
                                                      'bit length': 8})

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        outargsDM.addChild(TSKReturn)

        self.setOutputModel(outargsDM)


class cSWSk(function_class.cFunction):
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name': 'Swap to Sink',
                                                 '4cc': 'SWSk',
                                                 'inargs byte length': 0,
                                                 'outargs byte length': 1})

        self.inargsDataModel = None
        outargsDM = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                   {'name': 'Return Values',
                                                    'offset': 0,
                                                    'bit length': 8})

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                     {'name': 'Task Return Status',
                                                      'offset': 0,
                                                      'bit length': 8})

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        outargsDM.addChild(TSKReturn)

        self.setOutputModel(outargsDM)


class cSWSr(function_class.cFunction):
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name': 'Swap to Source',
                                                 '4cc': 'SWSr',
                                                 'inargs byte length': 0,
                                                 'outargs byte length': 1})

        self.inargsDataModel = None
        outargsDM = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                   {'name': 'Return Values',
                                                    'offset': 0,
                                                    'bit length': 8})

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                     {'name': 'Task Return Status',
                                                      'offset': 0,
                                                      'bit length': 8})

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        outargsDM.addChild(TSKReturn)

        self.setOutputModel(outargsDM)


class cSWDF(function_class.cFunction):
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name': 'Swap to DFP',
                                                 '4cc': 'SWDF',
                                                 'inargs byte length': 0,
                                                 'outargs byte length': 1})

        self.inargsDataModel = None
        outargsDM = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                   {'name': 'Return Values',
                                                    'offset': 0,
                                                    'bit length': 8})

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                     {'name': 'Task Return Status',
                                                      'offset': 0,
                                                      'bit length': 8})

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        outargsDM.addChild(TSKReturn)

        self.setOutputModel(outargsDM)


class cSWUF(function_class.cFunction):
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name': 'Swap to UFP',
                                                 '4cc': 'SWUF',
                                                 'inargs byte length': 0,
                                                 'outargs byte length': 1})

        self.inargsDataModel = None
        outargsDM = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                   {'name': 'Return Values',
                                                    'offset': 0,
                                                    'bit length': 8})

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                     {'name': 'Task Return Status',
                                                      'offset': 0,
                                                      'bit length': 8})

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        outargsDM.addChild(TSKReturn)

        self.setOutputModel(outargsDM)


class cSWVC(function_class.cFunction):
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name': 'Swap VConn Provider',
                                                 '4cc': 'SWVC',
                                                 'inargs byte length': 0,
                                                 'outargs byte length': 1})

        self.inargsDataModel = None
        outargsDM = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                   {'name': 'Return Values',
                                                    'offset': 0,
                                                    'bit length': 8})

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                     {'name': 'Task Return Status',
                                                      'offset': 0,
                                                      'bit length': 8})

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        outargsDM.addChild(TSKReturn)

        self.setOutputModel(outargsDM)


class cSRDY(function_class.cFunction):
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name': 'System Ready to Sink Power',
                                                 '4cc': 'SRDY',
                                                 'inargs byte length': 1,
                                                 'outargs byte length': 1})

        inargsDM = register_class.cDataModelArray(self.inargsMiniReg, 1,
                                                  {'name': 'Input Arguments',
                                                   'offset': 0,
                                                   'bit length': 8})

        swSel = register_class.cListDMTerminator(self.inargsMiniReg,
                                                 {'name': 'Switch Selection',
                                                  'offset': 0,
                                                  'bit length': 2})
        swSel.setReportList(self.SwitchSelection_list)
        swSel.setMaxValue(len(self.SwitchSelection_list) - 1)
        inargsDM.addChild(swSel)

        self.setInputModel(inargsDM)

        outargsDM = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                   {'name': 'Return Values',
                                                    'offset': 0,
                                                    'bit length': 8})

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                     {'name': 'Task Return Status',
                                                      'offset': 0,
                                                      'bit length': 8})

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        outargsDM.addChild(TSKReturn)

        self.setOutputModel(outargsDM)

    SwitchSelection_list = ['PP1', 'PP2', 'PP3', 'PP4']


class cAMEn(function_class.cFunction) :
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name' : 'Enter Alternate Mode',
                                                 '4cc' : 'AMEn',
                                                 'inargs byte length' : 5,
                                                 'outargs byte length' : 1})

        inargsDM = register_class.cDataModelArray(self.inargsMiniReg, 1,
                                                        {'name' : 'Input Arguments',
                                                        'offset' : 0,
                                                        'bit length' : 40 })

        ModeIndex = register_class.cHexDMTerminator(self.inargsMiniReg,
                                                          {'name' : 'modeIndex',
                                                            'offset' : 0,
                                                            'bit length' : 8 })
        inargsDM.addChild(ModeIndex)

        SVID = register_class.cHexDMTerminator(self.inargsMiniReg,
                                                          {'name' : 'SVID',
                                                            'offset' : 8,
                                                            'bit length' : 16 })
        inargsDM.addChild(SVID)

        objPosn = register_class.cDecimalDMTerminator(self.inargsMiniReg,
                                                          {'name' : 'Object Position',
                                                            'offset' : 24,
                                                            'bit length' : 3 })
        inargsDM.addChild(objPosn)

        LastModeEx = register_class.cDecimalDMTerminator(self.inargsMiniReg,
                                                          {'name' : 'LastModeExited',
                                                            'offset' : 27,
                                                            'bit length' : 1 })
        inargsDM.addChild(LastModeEx)

        SOPType = register_class.cDecimalDMTerminator(self.inargsMiniReg,
                                                          {'name' : 'SOPType',
                                                            'offset' : 30,
                                                            'bit length' : 2 })
        inargsDM.addChild(SOPType)


        self.setInputModel(inargsDM)

        outargsDM = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                        {'name' : 'Return Values',
                                                        'offset' : 0,
                                                        'bit length' : 8 })

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                          {'name' : 'Task Return Status',
                                                            'offset' : 0,
                                                            'bit length' : 8 })

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        outargsDM.addChild(TSKReturn)

        self.setOutputModel(outargsDM)


class cAMEx(function_class.cFunction) :
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name' : 'Exit Alternate Mode',
                                                 '4cc' : 'AMEx',
                                                 'inargs byte length' : 5,
                                                 'outargs byte length' : 1})

        inargsDM = register_class.cDataModelArray(self.inargsMiniReg, 1,
                                                        {'name' : 'Input Arguments',
                                                        'offset' : 0,
                                                        'bit length' : 40 })

        ModeIndex = register_class.cHexDMTerminator(self.inargsMiniReg,
                                                          {'name' : 'modeIndex',
                                                            'offset' : 0,
                                                            'bit length' : 8 })
        inargsDM.addChild(ModeIndex)

        SVID = register_class.cHexDMTerminator(self.inargsMiniReg,
                                                          {'name' : 'SVID',
                                                            'offset' : 8,
                                                            'bit length' : 16 })
        inargsDM.addChild(SVID)

        objPosn = register_class.cDecimalDMTerminator(self.inargsMiniReg,
                                                          {'name' : 'Object Position',
                                                            'offset' : 24,
                                                            'bit length' : 3 })
        inargsDM.addChild(objPosn)

        LastModeEx = register_class.cDecimalDMTerminator(self.inargsMiniReg,
                                                          {'name' : 'LastModeExited',
                                                            'offset' : 27,
                                                            'bit length' : 1 })
        inargsDM.addChild(LastModeEx)

        SOPType = register_class.cDecimalDMTerminator(self.inargsMiniReg,
                                                          {'name' : 'SOPType',
                                                            'offset' : 30,
                                                            'bit length' : 2 })
        inargsDM.addChild(SOPType)

        self.setInputModel(inargsDM)


        outargsDM = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                        {'name' : 'Return Values',
                                                        'offset' : 0,
                                                        'bit length' : 8 })

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                          {'name' : 'Task Return Status',
                                                            'offset' : 0,
                                                            'bit length' : 8 })

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        outargsDM.addChild(TSKReturn)

        self.setOutputModel(outargsDM)


class cANEG(function_class.cFunction):
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name': 'Autonegotiate Sink',
                                                 '4cc': 'ANEG',
                                                 'inargs byte length': 0,
                                                 'outargs byte length': 1})

        self.inargsDataModel = None
        outargsDM = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                   {'name': 'Return Values',
                                                    'offset': 0,
                                                    'bit length': 8})

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                     {'name': 'Task Return Status',
                                                      'offset': 0,
                                                      'bit length': 8})

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        outargsDM.addChild(TSKReturn)

        self.setOutputModel(outargsDM)


class cAMDs(function_class.cFunction):
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name': 'Start Alternate Mode Discovery',
                                                 '4cc': 'AMDs',
                                                 'inargs byte length': 0,
                                                 'outargs byte length': 1})

        self.inargsDataModel = None
        outargsDM = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                   {'name': 'Return Values',
                                                    'offset': 0,
                                                    'bit length': 8})

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                     {'name': 'Task Return Status',
                                                      'offset': 0,
                                                      'bit length': 8})

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        outargsDM.addChild(TSKReturn)

        self.setOutputModel(outargsDM)


class cGPie(function_class.cFunction):
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name': 'Enable GPIO as Input',
                                                 '4cc': 'GPie',
                                                 'inargs byte length': 1,
                                                 'outargs byte length': 1})

        inargsDM = register_class.cDataModelArray(self.inargsMiniReg, 1,
                                                  {'name': 'Input Arguments',
                                                   'offset': 0,
                                                   'bit length': 8})

        gpioNum = register_class.cDecimalDMTerminator(self.inargsMiniReg,
                                                      {'name': 'GPIO Number',
                                                       'offset': 0,
                                                       'bit length': 8})
        gpioNum.setMaxValue(21)
        inargsDM.addChild(gpioNum)

        self.setInputModel(inargsDM)

        outargsDM = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                   {'name': 'Return Values',
                                                    'offset': 0,
                                                    'bit length': 8})

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                     {'name': 'Task Return Status',
                                                      'offset': 0,
                                                      'bit length': 8})

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        outargsDM.addChild(TSKReturn)

        self.setOutputModel(outargsDM)


class cGPoe(function_class.cFunction):
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name': 'Enable GPIO as Output',
                                                 '4cc': 'GPie',
                                                 'inargs byte length': 1,
                                                 'outargs byte length': 1})

        inargsDM = register_class.cDataModelArray(self.inargsMiniReg, 1,
                                                  {'name': 'Input Arguments',
                                                   'offset': 0,
                                                   'bit length': 8})

        gpioNum = register_class.cDecimalDMTerminator(self.inargsMiniReg,
                                                      {'name': 'GPIO Number',
                                                       'offset': 0,
                                                       'bit length': 8})
        gpioNum.setMaxValue(21)
        inargsDM.addChild(gpioNum)

        self.setInputModel(inargsDM)

        outargsDM = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                   {'name': 'Return Values',
                                                    'offset': 0,
                                                    'bit length': 8})

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                     {'name': 'Task Return Status',
                                                      'offset': 0,
                                                      'bit length': 8})

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        outargsDM.addChild(TSKReturn)

        self.setOutputModel(outargsDM)


class cGPsh(function_class.cFunction):
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name': 'Set GPIO High',
                                                 '4cc': 'GPsh',
                                                 'inargs byte length': 1,
                                                 'outargs byte length': 1})

        inargsDM = register_class.cDataModelArray(self.inargsMiniReg, 1,
                                                  {'name': 'Input Arguments',
                                                   'offset': 0,
                                                   'bit length': 8})

        gpioNum = register_class.cDecimalDMTerminator(self.inargsMiniReg,
                                                      {'name': 'GPIO Number',
                                                       'offset': 0,
                                                       'bit length': 8})
        gpioNum.setMaxValue(21)
        inargsDM.addChild(gpioNum)

        self.setInputModel(inargsDM)

        outargsDM = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                   {'name': 'Return Values',
                                                    'offset': 0,
                                                    'bit length': 8})

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                     {'name': 'Task Return Status',
                                                      'offset': 0,
                                                      'bit length': 8})

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        outargsDM.addChild(TSKReturn)

        self.setOutputModel(outargsDM)


class cGPsl(function_class.cFunction):
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name': 'Set GPIO Low',
                                                 '4cc': 'GPsl',
                                                 'inargs byte length': 1,
                                                 'outargs byte length': 1})

        inargsDM = register_class.cDataModelArray(self.inargsMiniReg, 1,
                                                  {'name': 'Input Arguments',
                                                   'offset': 0,
                                                   'bit length': 8})

        gpioNum = register_class.cDecimalDMTerminator(self.inargsMiniReg,
                                                      {'name': 'GPIO Number',
                                                       'offset': 0,
                                                       'bit length': 8})
        gpioNum.setMaxValue(21)
        inargsDM.addChild(gpioNum)

        self.setInputModel(inargsDM)

        outargsDM = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                   {'name': 'Return Values',
                                                    'offset': 0,
                                                    'bit length': 8})

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                     {'name': 'Task Return Status',
                                                      'offset': 0,
                                                      'bit length': 8})

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        outargsDM.addChild(TSKReturn)

        self.setOutputModel(outargsDM)


# display pdos based on numPdo
# not a method, but should be grouped with txSrcCap class
def VDMs_inargs_TopLevelDMGenerator(self):
    numVdo = self.getChildByName('Number of 32-bit VDM Objects').valueToInt()

    for i in range(7):
        if i < numVdo:
            self.getChildByName('VDO %d Payload (32-bit)' % (i + 1)).unhide()
        else:
            self.getChildByName('VDO %d Payload (32-bit)' % (i + 1)).hide()

    return self.childrenAsListDMGenerator()


class cVDMs(function_class.cFunction):
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name': 'Send VDM Packet',
                                                 '4cc': 'VDMs',
                                                 'inargs byte length': 1,
                                                 'outargs byte length': 1})

        self.setInputModel(register_class.cDataModelArray(self.inargsMiniReg, 2,
                                                          {'name': 'Input Arguments',
                                                           'offset': 0,
                                                           'bit length': 8}))

        self.inargsArray = register_class.cDataModelArray(self.inargsMiniReg, 1,
                                                          {'name': 'Input Arguments',
                                                           'offset': 0,
                                                           'bit length': 8})

        self.inargsDataModel.addChild(self.inargsArray)

        numObj = register_class.cDecimalDMTerminator(self.inargsMiniReg,
                                                     {'name': 'Number of 32-bit VDM Objects',
                                                      'offset': 0,
                                                      'bit length': 3})
        numObj.setMaxValue(7)
        numObj.addUpdateRegisterByName('self')
        self.inargsArray.addChild(numObj)

        sopType = register_class.cListDMTerminator(self.inargsMiniReg,
                                                   {'name': 'SOP Type',
                                                    'offset': 4,
                                                    'bit length': 2})
        sopType.setReportList(self.sop_type_list)
        sopType.setMaxValue(2)
        self.inargsArray.addChild(sopType)

        structType = register_class.cListDMTerminator(self.inargsMiniReg,
                                                      {'name': 'Structured/Unstructured',
                                                       'offset': 23,
                                                       'bit length': 1})
        structType.setReportList(self.structured_type_list)
        self.inargsArray.addChild(structType)

        SVID = register_class.cHexDMTerminator(self.inargsMiniReg,
                                               {'name': 'SVID (Standard or Vendor ID)',
                                                'offset': 24,
                                                'bit length': 16})
        self.inargsArray.addChild(SVID)

        vdo0 = register_class.cHexDMTerminator(self.inargsMiniReg,
                                               {'name': 'VDO 0 Partial Payload (15-bit)',
                                                'offset': 8,
                                                'bit length': 15})
        self.inargsArray.addChild(vdo0)

        for i in range(1, 8):
            vdox = register_class.cHexDMTerminator(self.inargsMiniReg,
                                                   {'name': 'VDO %d Payload (32-bit)' % i,
                                                    'offset': 8 + (32 * i),
                                                    'bit length': 32})
            self.inargsArray.addChild(vdox)

        self.inargsArray.setDataModelGenerator(VDMs_inargs_TopLevelDMGenerator)

        outargsDM = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                   {'name': 'Return Values',
                                                    'offset': 0,
                                                    'bit length': 8})

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                     {'name': 'Task Return Status',
                                                      'offset': 0,
                                                      'bit length': 8})

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        outargsDM.addChild(TSKReturn)

        self.setOutputModel(outargsDM)

    sop_type_list = ['SOP', 'SOP Prime', 'SOP Double-Prime']
    structured_type_list = ['Unstructured VDM', 'Structured VDM']


class cPTCq(function_class.cFunction):
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name': 'Patch Query',
                                                 '4cc': 'PTCq',
                                                 'inargs byte length': 0,
                                                 'outargs byte length': 14})

        self.inargsDataModel = None

        outargsDM = register_class.cDataModelArray(self.outargsMiniReg, 1,
                                                   {'name': 'Return Values',
                                                    'offset': 0,
                                                    'bit length': 8})

        noConfig = register_class.cBooleanDMTerminator(self.outargsMiniReg,
                                                       {'name': 'No Config Bundle',
                                                        'offset': 3,
                                                        'bit length': 1})

        noConfig.lock()
        outargsDM.addChild(noConfig)

        noPatch = register_class.cBooleanDMTerminator(self.outargsMiniReg,
                                                      {'name': 'No Patch Bundle',
                                                       'offset': 7,
                                                       'bit length': 1})

        noPatch.lock()
        outargsDM.addChild(noPatch)

        configReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                        {'name': 'Config Return Code',
                                                         'offset': 8,
                                                         'bit length': 8})

        configReturn.setReportDict({0x0: 'Success', \
                                    0x40: 'Warning',
                                    0x80: 'Failure'
                                    })
        configReturn.lock()
        outargsDM.addChild(configReturn)

        pcReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                    {'name': 'Patch Complete Return Code',
                                                     'offset': 16,
                                                     'bit length': 8})

        pcReturn.setReportDict({0x0: 'Success', \
                                0x20: 'Not Ready', \
                                0x40: 'Not a Patch', \
                                0x41: 'Header Checksum Mismatch',
                                0x42: 'Incorrect ROM Version',
                                0x43: 'Patch Code Checksum Incorrect',
                                0x44: 'Null Patch Received',
                                0x45: 'Error Patch Received',
                                })
        pcReturn.lock()
        outargsDM.addChild(pcReturn)

        totdat = register_class.cHexDMTerminator(self.outargsMiniReg,
                                                 {'name': 'Total Data Transferred',
                                                  'offset': 32,
                                                  'bit length': 16})

        totdat.lock()
        outargsDM.addChild(totdat)

        patchdat = register_class.cHexDMTerminator(self.outargsMiniReg,
                                                   {'name': 'Patch Data Transferred',
                                                    'offset': 48,
                                                    'bit length': 16})

        patchdat.lock()
        outargsDM.addChild(patchdat)

        confdat = register_class.cHexDMTerminator(self.outargsMiniReg,
                                                  {'name': 'Config Data Transferred',
                                                   'offset': 64,
                                                   'bit length': 16})

        confdat.lock()
        outargsDM.addChild(confdat)

        state = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                 {'name': 'Patch State',
                                                  'offset': 80,
                                                  'bit length': 8})

        state.setReportDict({0x0: 'No Patch', \
                             0x1: 'Loading',
                             0x2: 'Loading Done', \
                             0x3: 'Running',
                             0x4: 'Early Load Skipped',
                             0x5: 'UART Booted', \
                             0x6: 'Error',
                             })
        state.lock()
        outargsDM.addChild(state)

        source = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                  {'name': 'Patch Load Source',
                                                   'offset': 88,
                                                   'bit length': 8})

        source.setReportDict({0x0: 'None',
                              0x1: 'SRAM',
                              0x2: 'FLASH', \
                              0x3: 'I2C',
                              0x4: 'Default',
                              })
        source.lock()
        outargsDM.addChild(source)

        confState = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                     {'name': 'Config State',
                                                      'offset': 96,
                                                      'bit length': 8})

        confState.setReportDict({0x0: 'No Data',
                                 0x1: 'Loading from SRAM',
                                 0x2: 'Loading from FLASH',
                                 0x3: 'Loading from I2C',
                                 0x4: 'Loading from Default',
                                 0x5: 'Loading Done',
                                 0x6: 'Error',
                                 0x7: 'Success',
                                 0x8: 'Failure',
                                 })
        confState.lock()
        outargsDM.addChild(confState)

        confSource = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                      {'name': 'Config Load Source',
                                                       'offset': 104,
                                                       'bit length': 8})

        confSource.setReportDict({0x0: 'None',
                                  0x1: 'SRAM',
                                  0x2: 'FLASH',
                                  0x3: 'I2C',
                                  0x4: 'Default',
                                  })
        confSource.lock()
        outargsDM.addChild(confSource)

        self.setOutputModel(outargsDM)

    sop_type_list = ['SOP', 'SOP Prime', 'SOP Double-Prime']
    structured_type_list = ['Unstructured VDM', 'Structured VDM']


ADCchannelListOfDict = [
    {'Channel': 'Thermal Sensor Temperature', 'Divider Ratio': 1024 / 1.2, 'Unit': 'Raw (1024 LSB scale)'},
    {'Channel': 'VBUS 1 Voltage', 'Divider Ratio': 25, 'Unit': 'V'},
    {'Channel': 'VBUS 2 Voltage', 'Divider Ratio': 25, 'Unit': 'V'},
    {'Channel': 'PP HV1 Voltage', 'Divider Ratio': 25, 'Unit': 'V'},
    {'Channel': 'PP HV2 Voltage', 'Divider Ratio': 25, 'Unit': 'V'},
    {'Channel': 'PP HV1 Current', 'Divider Ratio': 5 / 1.2, 'Unit': 'A'},
    {'Channel': 'PP HV2 Current', 'Divider Ratio': 5 / 1.2, 'Unit': 'A'},
    {'Channel': 'VOUT_3V3 Voltage', 'Divider Ratio': 3, 'Unit': 'V'},
    {'Channel': 'BC1.2 Voltage', 'Divider Ratio': 3, 'Unit': 'V'},
    {'Channel': 'ADC Input Channel 1', 'Divider Ratio': 3, 'Unit': 'V'},
    {'Channel': 'ADC Input Channel 2', 'Divider Ratio': 3, 'Unit': 'V'},
    {'Channel': 'GPIO 2', 'Divider Ratio': 3, 'Unit': 'V'},
    {'Channel': 'GPIO 7', 'Divider Ratio': 3, 'Unit': 'V'},
    {'Channel': 'GPIO 16', 'Divider Ratio': 3, 'Unit': 'V'},
    {'Channel': 'GPIO 17', 'Divider Ratio': 3, 'Unit': 'V'},
    {'Channel': 'Port A CC_1', 'Divider Ratio': 5, 'Unit': 'V'},
    {'Channel': 'Port A CC_2', 'Divider Ratio': 5, 'Unit': 'V'},
    {'Channel': 'Port B CC_1', 'Divider Ratio': 5, 'Unit': 'V'},
    {'Channel': 'Port B CC_2', 'Divider Ratio': 5, 'Unit': 'V'},
    {'Channel': 'Port A VConn', 'Divider Ratio': 5, 'Unit': 'V'},
    {'Channel': 'Port B VConn', 'Divider Ratio': 5, 'Unit': 'V'},
    {'Channel': 'PP_HV1 Temperature', 'Divider Ratio': 1024 / 1.2, 'Unit': 'Raw (1024 LSB scale)'},
    {'Channel': 'PP_HV2 Temperature', 'Divider Ratio': 1024 / 1.2, 'Unit': 'Raw (1024 LSB scale)'},
    {'Channel': 'GPIO 2 (No Scaling)', 'Divider Ratio': 1, 'Unit': 'V'},
    ]


class cDMAnyChannelTerminator(register_class.cDataModelTerminator):
    def __init__(self, register, adcFunction, iDict):
        register_class.cDataModelTerminator.__init__(self, register, iDict)
        self.adcFunction = adcFunction
        self.terminatorOverlayList = []

        for channel in ADCchannelListOfDict:
            channelTerm = register_class.cScalingDMTerminator(self.register,
                                                              {'name': iDict['name'],
                                                               'offset': iDict['offset'],
                                                               'bit length': iDict['bit length']})
            ratio = ((1.2) / 1024) * channel['Divider Ratio']
            channelTerm.dictScaleUnits = {'': ratio, channel['Unit']: ratio}
            channelTerm.defaultUnit = channel['Unit']

            self.terminatorOverlayList.append(channelTerm)

        self.dataModelGenerator = self.AnyScalerGenerator

    def AnyScalerGenerator(self):
        # todo: should make a set parent call instead of allowing to be set directly
        #       then the objects can correctly set sub-object parent relationships
        for term in self.terminatorOverlayList:
            term.parent = self.parent

        channel = self.adcFunction.inargsDataModel.getChildByName('Channel').valueToInt()
        dmGenerator = self.terminatorOverlayList[channel]

        return dmGenerator.dataModelGenerator()


class cADCs(function_class.cFunction):
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name': 'ADC Read',
                                                 '4cc': 'ADCs',
                                                 'inargs byte length': 1,
                                                 'outargs byte length': 2})

        self.channelList = []
        for record in ADCchannelListOfDict:
            self.channelList.append(record['Channel'])

        inargsDM = register_class.cDataModelArray(self.inargsMiniReg, 1,
                                                  {'name': 'Input Arguments',
                                                   'offset': 0,
                                                   'bit length': 8})

        channel = register_class.cListDMTerminator(self.inargsMiniReg,
                                                   {'name': 'Channel',
                                                    'offset': 0,
                                                    'bit length': 5})
        channel.setReportList(self.channelList)
        channel.setMaxValue(23)
        inargsDM.addChild(channel)

        self.setInputModel(inargsDM)

        outargsDM = register_class.cDataModelArray(self.outargsMiniReg, 1,
                                                   {'name': 'Return Values',
                                                    'offset': 0,
                                                    'bit length': 8})

        TSKReturn = cDMAnyChannelTerminator(self.outargsMiniReg, self,
                                            {'name': 'ADC Read Value',
                                             'offset': 0,
                                             'bit length': 10})

        TSKReturn.lock()
        outargsDM.addChild(TSKReturn)

        self.setOutputModel(outargsDM)


class cGSCX(function_class.cFunction):
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name': 'Get Source Capabilities Extended',
                                                 '4cc': 'GSCX',
                                                 'inargs byte length': 0,
                                                 'outargs byte length': 1})

        self.inargsDataModel = None
        outargsDM = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                   {'name': 'Return Values',
                                                    'offset': 0,
                                                    'bit length': 8})

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                     {'name': 'Task Return Status',
                                                      'offset': 0,
                                                      'bit length': 8})

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        outargsDM.addChild(TSKReturn)

        self.setOutputModel(outargsDM)


class cALRT(function_class.cFunction):
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name': 'Send Alert',
                                                 '4cc': 'ALRT',
                                                 'inargs byte length': 0,
                                                 'outargs byte length': 1})

        self.inargsDataModel = None
        outargsDM = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                   {'name': 'Return Values',
                                                    'offset': 0,
                                                    'bit length': 8})

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                     {'name': 'Task Return Status',
                                                      'offset': 0,
                                                      'bit length': 8})

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        outargsDM.addChild(TSKReturn)

        self.setOutputModel(outargsDM)


class cGSSt(function_class.cFunction):
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name': 'Get Status',
                                                 '4cc': 'GSSt',
                                                 'inargs byte length': 0,
                                                 'outargs byte length': 1})

        self.inargsDataModel = None
        outargsDM = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                   {'name': 'Return Values',
                                                    'offset': 0,
                                                    'bit length': 8})

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                     {'name': 'Task Return Status',
                                                      'offset': 0,
                                                      'bit length': 8})

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        outargsDM.addChild(TSKReturn)

        self.setOutputModel(outargsDM)


class cGBaS(function_class.cFunction):
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name': 'Get Battery Status',
                                                 '4cc': 'GBaS',
                                                 'inargs byte length': 0,
                                                 'outargs byte length': 1})

        self.setInputModel(register_class.cDataModelArray(self.inargsMiniReg, 1,
                                                          {'name': 'Input Arguments',
                                                           'offset': 0,
                                                           'bit length': 8}))

        batteryNumber = register_class.cDecimalDMTerminator(self.inargsMiniReg,
                                                            {'name': 'Battery Number',
                                                             'offset': 0,
                                                             'bit length': 3})

        self.inargsDataModel.addChild(batteryNumber)

        outargsDM = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                   {'name': 'Return Values',
                                                    'offset': 0,
                                                    'bit length': 8})

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                     {'name': 'Task Return Status',
                                                      'offset': 0,
                                                      'bit length': 8})

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        outargsDM.addChild(TSKReturn)

        self.setOutputModel(outargsDM)


class cGBaC(function_class.cFunction):
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name': 'Get Battery Capability',
                                                 '4cc': 'GBaC',
                                                 'inargs byte length': 0,
                                                 'outargs byte length': 1})

        self.setInputModel(register_class.cDataModelArray(self.inargsMiniReg, 1,
                                                          {'name': 'Input Arguments',
                                                           'offset': 0,
                                                           'bit length': 8}))

        batteryNumber = register_class.cDecimalDMTerminator(self.inargsMiniReg,
                                                            {'name': 'Battery Number',
                                                             'offset': 0,
                                                             'bit length': 3})

        self.inargsDataModel.addChild(batteryNumber)

        outargsDM = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                   {'name': 'Return Values',
                                                    'offset': 0,
                                                    'bit length': 8})

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                     {'name': 'Task Return Status',
                                                      'offset': 0,
                                                      'bit length': 8})

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        outargsDM.addChild(TSKReturn)

        self.setOutputModel(outargsDM)


class cGMfI(function_class.cFunction):
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name': 'Get Manufacturer Info',
                                                 '4cc': 'GMfI',
                                                 'inargs byte length': 0,
                                                 'outargs byte length': 1})

        self.setInputModel(register_class.cDataModelArray(self.inargsMiniReg, 1,
                                                          {'name': 'Input Arguments',
                                                           'offset': 0,
                                                           'bit length': 16}))

        manufactRef = register_class.cHexDMTerminator(self.inargsMiniReg,
                                                      {'name': 'Manufacturer Reference',
                                                       'offset': 0,
                                                       'bit length': 16})

        self.inargsDataModel.addChild(manufactRef)

        outargsDM = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                   {'name': 'Return Values',
                                                    'offset': 0,
                                                    'bit length': 8})

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                     {'name': 'Task Return Status',
                                                      'offset': 0,
                                                      'bit length': 8})

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        outargsDM.addChild(TSKReturn)

        self.setOutputModel(outargsDM)


class cLOCK(function_class.cFunction):
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name': 'Lock or Unlock Reserved HI Functions',
                                                 '4cc': 'LOCK',
                                                 'inargs byte length': 4,
                                                 'outargs byte length': 1})

        self.hideIfLocked = True

        self.inargsDataModel = register_class.cDataModelArray(self.inargsMiniReg, 1,
                                                              {'name': 'Input Arguments',
                                                               'offset': 0,
                                                               'bit length': 32})

        memAddr = register_class.cHexDMTerminator(self.inargsMiniReg,
                                                  {'name': 'Lock/Unlock Key',
                                                   'offset': 0,
                                                   'bit length': 32})
        self.inargsDataModel.addChild(memAddr)

        self.outargsDataModel = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                               {'name': 'Return Values',
                                                                'offset': 0,
                                                                'bit length': 8})

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                     {'name': 'Task Return Status',
                                                      'offset': 0,
                                                      'bit length': 8})

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        self.outargsDataModel.addChild(TSKReturn)


class cMEMr(function_class.cFunction):
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name': 'Read From Device Memory',
                                                 '4cc': 'MEMr',
                                                 'inargs byte length': 4,
                                                 'outargs byte length': 4})

        self.hideIfLocked = True

        self.inargsDataModel = register_class.cDataModelArray(self.inargsMiniReg, 1,
                                                              {'name': 'Input Arguments',
                                                               'offset': 0,
                                                               'bit length': 32})

        memAddr = register_class.cHexDMTerminator(self.inargsMiniReg,
                                                  {'name': 'Memory Address',
                                                   'offset': 0,
                                                   'bit length': 32})
        self.inargsDataModel.addChild(memAddr)

        self.outargsDataModel = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                               {'name': 'Return Values',
                                                                'offset': 0,
                                                                'bit length': 32})

        TSKReturn = register_class.cHexDMTerminator(self.outargsMiniReg,
                                                    {'name': 'Read Value',
                                                     'offset': 0,
                                                     'bit length': 32})

        TSKReturn.lock()
        self.outargsDataModel.addChild(TSKReturn)


class cMEMw(function_class.cFunction):
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name': 'Write to Device Memory',
                                                 '4cc': 'MEMw',
                                                 'inargs byte length': 8,
                                                 'outargs byte length': 1})

        self.hideIfLocked = True

        self.inargsDataModel = register_class.cDataModelArray(self.inargsMiniReg, 1,
                                                              {'name': 'Input Arguments',
                                                               'offset': 0,
                                                               'bit length': 64})

        memAddr = register_class.cHexDMTerminator(self.inargsMiniReg,
                                                  {'name': 'Memory Address',
                                                   'offset': 0,
                                                   'bit length': 32})
        self.inargsDataModel.addChild(memAddr)

        memVal = register_class.cHexDMTerminator(self.inargsMiniReg,
                                                 {'name': 'Write Value',
                                                  'offset': 32,
                                                  'bit length': 32})
        self.inargsDataModel.addChild(memVal)

        self.outargsDataModel = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                               {'name': 'Return Values',
                                                                'offset': 0,
                                                                'bit length': 8})

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                     {'name': 'Task Return Status',
                                                      'offset': 0,
                                                      'bit length': 8})

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        self.outargsDataModel.addChild(TSKReturn)


class cI2Cw(function_class.cFunction):
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name': 'I2C Master Write',
                                                 '4cc': 'I2Cw',
                                                 'inargs byte length': 10,
                                                 'outargs byte length': 1})

        self.inargsDataModel = register_class.cDataModelArray(self.inargsMiniReg, 1,
                                                              {'name': 'Input Arguments',
                                                               'offset': 0,
                                                               'bit length': 32})

        slaveAddr = register_class.cHexDMTerminator(self.inargsMiniReg,
                                                    {'name': 'Slave Address',
                                                     'offset': 0,
                                                     'bit length': 8})
        self.inargsDataModel.addChild(slaveAddr)

        slaveAddr = register_class.cDecimalDMTerminator(self.inargsMiniReg,
                                                        {'name': 'Length',
                                                         'offset': 8,
                                                         'bit length': 8})
        self.inargsDataModel.addChild(slaveAddr)

        slaveAddr = register_class.cHexDMTerminator(self.inargsMiniReg,
                                                    {'name': 'Data',
                                                     'offset': 16,
                                                     'bit length': 64})
        self.inargsDataModel.addChild(slaveAddr)

        self.outargsDataModel = register_class.cDataModelArray(self.outargsMiniReg, 1,
                                                               {'name': 'Return Values',
                                                                'offset': 0,
                                                                'bit length': 8})

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                     {'name': 'Task Return Status',
                                                      'offset': 0,
                                                      'bit length': 8})

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        self.outargsDataModel.addChild(TSKReturn)


class cI2Cr(function_class.cFunction):
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name': 'I2C Master Read',
                                                 '4cc': 'I2Cr',
                                                 'inargs byte length': 3,
                                                 'outargs byte length': 64})

        self.inargsDataModel = register_class.cDataModelArray(self.inargsMiniReg, 1,
                                                              {'name': 'Input Arguments',
                                                               'offset': 0,
                                                               'bit length': 24})

        slaveAddr = register_class.cHexDMTerminator(self.inargsMiniReg,
                                                    {'name': 'Slave Address',
                                                     'offset': 0,
                                                     'bit length': 8})
        self.inargsDataModel.addChild(slaveAddr)

        slaveAddr = register_class.cHexDMTerminator(self.inargsMiniReg,
                                                    {'name': 'Register Address',
                                                     'offset': 8,
                                                     'bit length': 8})
        self.inargsDataModel.addChild(slaveAddr)

        slaveAddr = register_class.cDecimalDMTerminator(self.inargsMiniReg,
                                                        {'name': 'Length',
                                                         'offset': 16,
                                                         'bit length': 8})
        self.inargsDataModel.addChild(slaveAddr)

        self.outargsDataModel = register_class.cDataModelArray(self.outargsMiniReg, 1,
                                                               {'name': 'Return Values',
                                                                'offset': 0,
                                                                'bit length': 512})

        TSKReturn = register_class.cHexDMTerminator(self.outargsMiniReg,
                                                    {'name': 'Read Data',
                                                     'offset': 0,
                                                     'bit length': 512})
        self.outargsDataModel.addChild(TSKReturn)


# used by PD State Trace
import array
import time


def byteArray(n):
    strArray = bin(n)[2:].zfill(8 * ((len(bin(n)[2:]) - 1) / 8) + 8)

    ret = array.array('B')

    for i in range(len(strArray) / 8):
        if i != 0:
            ret.append(int(strArray[-i * 8 - 8:-i * 8], 2))
        else:
            ret.append(int(strArray[-8:], 2))

    return ret


def verify_cmd_completed(handle, device_rw, hi_timeout_sec=None):
    HI_TIMEOUT_SEC = 5

    if (hi_timeout_sec == None):
        hi_timeout_sec = HI_TIMEOUT_SEC
    (count, cmd_result) = device_rw.read_reg_4cc(handle, 0x08)
    assert count == 5
    basetime_s = time.time()
    while cmd_result[0] != device_rw.CC_ZERO:
        (count, cmd_result) = device_rw.read_reg_4cc(handle, 0x08)
        assert count == 5
        if cmd_result.tostring() == device_rw.CC_NOT_ZERO:
            return "Cmd STATUS ERROR: %s" % cmd_result.tostring()
        if ((time.time() - basetime_s) > HI_TIMEOUT_SEC):
            # timeout has been reached
            device_rw.write_reg_4cc(handle, 0x08, 'ABRT')
            basetime_s = time.time()
            (count, cmd_result) = device_rw.read_reg_4cc(handle, 0x08)
            while cmd_result[0] != device_rw.CC_ZERO:
                assert count == 5
                if cmd_result.tostring() == device_rw.CC_NOT_ZERO:
                    return "Cmd TIMEOUT followed by ABRT rejection: %s" % cmd_result.tostring()
                else:
                    if ((time.time() - basetime_s) > 5):
                        return "**********************************\nHost Interface function timeout followed by ABRT timeout\n**********************************\n"
            (count, cmd_result) = read_reg_4cc(handle, 0x08)
            return "**********************************\nHost Interface function aborted due to %d second timeout\n**********************************\n" % HI_TIMEOUT_SEC

    return "Success"


# PD State Trace

# PDSt has no exec wrapper and is not put into FUNC_LIST
# It is used internally for the PD State dump feature
# PD state dump
def PDSt(handle, device_rw):
    # read position indicator for circular buffer
    #    device_rw.write_reg(handle, 0x09, byteArray(1))
    #    device_rw.write_reg_4cc(handle, 0x08, 'DBGi')
    #    verify_cmd_completed(handle, device_rw)
    #    (count, ret1) = device_rw.read_reg(handle, 0x09, 2)

    #    position = ret1[0]

    array = []

    for i in range(8):
        device_rw.write_reg(handle, 0x09, byteArray(i))
        device_rw.write_reg_4cc(handle, 0x08, 'DBGr')
        verify_cmd_completed(handle, device_rw)
        (count, readArray) = device_rw.read_reg(handle, 0x09, 65)
        array.extend(readArray)

    shortArray = []
    for i in range(len(array) // 2):
        shortArray.append(array[2 * i] | (array[(2 * i) + 1] << 8))

    position = 0

    for (i, element) in enumerate(shortArray):
        if element == 0xFFFF:
            position = i
            break

    return (position, shortArray)


def pdStateDump(handle, device_rw):
    # return an array of strings in case someone wants to organize by line
    retVal = []
    (position, array) = PDSt(handle, device_rw)

    # remove runs of "PDState_Start" which occur when full circular buffer is not used.
    numPDState_Start = 0
    lastWasPDState_Start = False

    # build the array of return values
    for element in array[position:]:
        port = (element & 0x4000) >> 14
        module = (element & 0x3F00) >> 9
        value = element & 0x1FF
        if (module < 10) and (value in listOfModuleDict[module]):
            if value in listOfModuleDict[module]:
                retVal.append(
                    'Port %d\t%s\t0x%x = %s' % (port, listOfModules[module], value, listOfModuleDict[module][value]))
            else:
                retVal.append('Port %d\t%s\t0x%x = UNKNOWN' % (port, listOfModules[module], value))
        else:
            retVal.append('Port %d\tModule %d\t0x%x = UNKNOWN' % (port, module, value))

    for element in array[:position]:
        port = (element & 0x4000) >> 14
        module = (element & 0x3F00) >> 9
        value = element & 0x1FF
        if (module < 10) and (value in listOfModuleDict[module]):
            if value in listOfModuleDict[module]:
                retVal.append(
                    'Port %d\t%s\t0x%x = %s' % (port, listOfModules[module], value, listOfModuleDict[module][value]))
            else:
                retVal.append('Port %d\t%s\t0x%x = UNKNOWN' % (port, listOfModules[module], value))
        else:
            retVal.append('Port %d\tModule %d\t0x%x = UNKNOWN' % (port, module, value))

    return retVal


TYPEC_state_debug_dict = {0x0: 'SRC_STATE_DISABLED', 0x05: 'SRC_STATE_ERROR_RECOVERY',
                          0x24: 'SNK_STATE_UNATTACHED_ACCESSORY',
                          0x25: 'SNK_STATE_POWERED_ACCESSORY', 0x26: 'SNK_STATE_UNSUPPORTED_ACCESSORY',
                          0x2B: 'SNK_STATE_ATTACHWAIT_ACCESSORY',
                          0x45: 'DRP_STATE_TRY_SRC', 0x4E: 'DRP_TRY_WAIT_SNK', 0x4F: 'DRP_STATE_TRY_SNK',
                          0x50: 'DRP_STATE_TRY_WAIT_SRC',
                          0x60: 'COMMON_STATE_ATTACHED_SRC', 0x61: 'COMMON_STATE_ATTACHED_SNK',
                          0x62: 'COMMON_STATE_AUDIO_ACC',
                          0x63: 'COMMON_STATE_DEBUG_ACC', 0x64: 'COMMON_STATE_ATTACHWAIT_SRC',
                          0x65: 'COMMON_STATE_ATTACHWAIT_SNK',
                          0x66: 'COMMON_STATE_UNATTACHED_SNK', 0x67: 'COMMON_STATE_UNATTACHED_SRC',
                          0x68: 'COMMON_STATE_DEBUG_ACC_SNK',
                          0x69: 'COMMON_STATE_ORIENTED_DEBUG_ACC_SRC', 0x6A: 'COMMON_STATE_UNORIENTED_DEBUG_ACC_SRC',
                          0x70: 'COMMON_STATE_TYPEC_ISR', 0x71: 'COMMON_STATE_TIMER_ISR',
                          0x72: 'COMMON_STATE_INSLEEP_WAKE',
                          0x73: 'COMMON_STATE_SAFETYZONE', 0x74: 'COMMON_STATE_ATTACHWAIT_SRC_COMPLETE',
                          0x75: 'COMMON_STATE_ATTACHWAIT_SNK_COMPLETE',
                          0x76: 'COMMON_STATE_SRCCHECK0V_IRQ'}

BC12_state_debug_dict = {0x0: 'CHARGER_DETECTION_INIT', '0x01': 'DATA_CONNECTION_DETECTION',
                         '0x02': 'PRIMARY_DETECTION',
                         '0x03': 'SECONDARY_DETECTION', '0x04': 'CHARGER_DETECTION_COMPLETE',
                         '0x05': 'CHARGER_DETECTION_HALTED',
                         '0x06': 'CHARGER_DCP_ADVERTISEMENT', '0x07': 'CHARGER_CDP_ADVERTISE_START',
                         '0x08': 'CHARGER_CDP_ADVERTISE_IDX_DPLUS_ON',
                         '0x09': 'CHARGER_CDP_ADVERTISE_VDX_DMINUS_ON', '0x0A': 'CHARGER_CDP_ADVERTISE_IDX_DPLUS_OFF',
                         '0x0B': 'CHARGER_CDP_ADVERTISE_VDX_DMINUS_OFF',
                         '0x0C': 'CHARGER_CDP_ADVERTISE_COMPLETE', '0x0D': 'CHARGER_DCP_ADVERTISEMENT_COMPLETE',
                         '0x0E': 'CHARGER_DETECTION_DISABLED',
                         '0x0F': 'PRIMARY_DETECTION_WAIT', '0x10': 'DISABLE_PRIMARY_DETECTION_WAIT',
                         '0x11': 'SECONDARY_DETECTION_WAIT'}

PD_state_debug_dict = {0x0: 'PEState_Start', 0x1: 'PEState_CableTypeDetect', 0x2: 'PEState_LaunchPolicyEngine',
                       0x3: 'PEState_Priority__Start',
                       0x4: 'PEState_SendSoftReset', 0x5: 'PEState_SoftReset', 0x6: 'PEState_HardReset',
                       0x7: 'PEState_Priority__Stop',
                       0x8: 'PEState_SendSoftReset_Accept', 0x9: 'PEState_SoftReset_Exit', 0xA: 'PEState_Start_WrapUp',
                       0xB: 'PEState_WrapUpDone',
                       0xC: 'PEState_GiveSourceCap', 0xD: 'PEState_GiveSinkCap', 0xE: 'PEState_GetCap',
                       0xF: 'PEState_GetCap_Rx',
                       0x10: 'PEState_GetCap_Timeout', 0x11: 'PEState_Send_Not_Supported',
                       0x12: 'PEState_Not_Supported_Rx',
                       0x13: 'PEState_Source_Startup', 0x14: 'PEState_Source_Startup_Continue',
                       0x15: 'PEState_Source_Discovery',
                       0x16: 'PEState_Source_SendCapabilities', 0x17: 'PEState_Source_Ready',
                       0x18: 'PEState_Source_CapabilityResponse',
                       0x19: 'PEState_Source_NegotiateCapability', 0x1A: 'PEState_Source_TransitionSupply_GotoMin',
                       0x1B: 'PEState_Source_TransitionSupply_Accept', 0x1C: 'PEState_Source_TransitionSupply',
                       0x1D: 'PEState_UnUsed_0x1D',
                       0x1E: 'PEState_Source_TransitionSupply_SetAlarmsNew',
                       0x1F: 'PEState_Source_TransitionSupply_PS_RDY',
                       0x20: 'PEState_UnUsed_0x20', 0x21: 'PEState_Sink_Startup', 0x22: 'PEState_Sink_Discovery',
                       0x23: 'PEState_RxCapabilitiesOk__Start', 0x24: 'PEState_Sink_WaitForCapabilities',
                       0x25: 'PEState_Sink_WaitForCapabilities_Cont',
                       0x26: 'PEState_Sink_EvaluateCapability', 0x27: 'PEState_Sink_SelectCapability',
                       0x28: 'PEState_Sink_TransitionSink',
                       0x29: 'PEState_Sink_TransitionSink_PS_RDY', 0x2A: 'PEState_Sink_Ready',
                       0x2B: 'PEState_UnUsed_0x2B',
                       0x2C: 'PEState_RxCapabilitiesOk__Stop', 0x2D: 'PEState_Reject_Request',
                       0x2E: 'PEState_Enable_VCONN',
                       0x2F: 'PEState_Enable_VBUS', 0x30: 'PRState_Source_SinkTxOk', 0x31: 'PRState_Source_SinkTxNG',
                       0x32: 'PRState_Sink_SinkTxOk',
                       0x33: 'PRState_Sink_SinkTxNG', 0x34: 'PEState_PD_Send_Custom_Message',
                       0x35: 'PEState_PRS_Evaluate_PR_Swap',
                       0x36: 'PEState_PRS_Send_PR_Swap', 0x37: 'PEState_PRS_Accept_PR_Swap',
                       0x38: 'PEState_PRS_AssertRp',
                       0x39: 'PEState_PRS_AssertRd', 0x3A: 'PEState_PRS_TransitionToOff',
                       0x3B: 'PEState_PRS_TransitionToOff_Sink',
                       0x3C: 'PEState_PRS_TransitionToOff_Source', 0x3D: 'PEState_PRS_SourceOff',
                       0x3E: 'PEState_PRS_SourceOn',
                       0x3F: 'PEState_PRS_SourceOn_PS_RDY', 0x40: 'PEState_Control_Message_FR_Swap_received',
                       0x41: 'PEState_Control_Message_FR_Swap_HR',
                       0x42: 'PEState_Control_Message_Unknown_SR', 0x43: 'PEState_Pretend_DeadBattery',
                       0x44: 'PEState_GotoBISTTesterMode', 0x45: 'PEState_BIST_CarrierMode2',
                       0x46: 'PEState_BIST_TestData', 0x47: 'PEState_BIST_End_Continuous_Test', 0x48: 'reserved',
                       0x49: 'reserved', 0x4A: 'PEState_VCS_Send_Swap', 0x4B: 'PEState_VCS_Wait_for_VCONN',
                       0x4C: 'PEState_VCS_Turn_Off_VCONN',
                       0x4D: 'PEState_VCS_Turn_On_VCONN', 0x4E: 'PEState_VCS_Send_PS_Rdy',
                       0x4F: 'PEState_VCS_Evaluate_Swap',
                       0x50: 'PEState_VCS_Accept_Swap', 0x51: 'PEState_UnUsed_0x51', 0x52: 'PEState_UnUsed_0x52',
                       0x53: 'PEState_DRS_Evaluate_DR_Swap',
                       0x54: 'PEState_DRS_Accept_DR_Swap', 0x55: 'PEState_DRS_DFP_UFP_Change_to_UFP',
                       0x56: 'PEState_DRS_Send_DR_Swap',
                       0x57: 'PEState_DRS_UFP_DFP_Change_to_DFP', 0x58: 'PEState_DRS_SoftReset_SOP_DPrime_AfterDRSwap',
                       0x59: 'PEState_UnUsed_0x59',
                       0x5A: 'PEState_UnUsed_0x5A', 0x5B: 'PEState_UFP_VDM_Send_NAK',
                       0x5C: 'PEState_UFP_VDM_Send_Identity', 0x5D: 'PEState_UFP_VDM_Send_SVIDs',
                       0x5E: 'PEState_UFP_VDM_Send_Modes', 0x5F: 'PEState_UFP_VDM_Evaluate_Mode_Entry',
                       0x60: 'PEState_UFP_VDM_Mode_Entry_ACK', 0x61: 'PEState_UFP_VDM_Mode_Entry_NAK',
                       0x62: 'PEState_UFP_VDM_Mode_Exit',
                       0x63: 'PEState_UFP_VDM_Mode_Exit_ACK', 0x64: 'PEState_UFP_VDM_Mode_Exit_NAK',
                       0x65: 'PEState_UFP_VDM_Attention_Request',
                       0x66: 'PEState_UFP_VDM_Status_Request', 0x67: 'PEState_UFP_VDM_Config_Request',
                       0x68: 'PEState_UFP_VDM_Config_ACK',
                       0x69: 'PEState_UFP_VDM_Send_Data', 0x6A: 'PEState_UFP_VDM_Send_Data_ACK',
                       0x6B: 'PEState_UFP_VDM_RxVWire_Status',
                       0x6C: 'PEState_UFP_VDM_RxVWire_Status_ACK', 0x6D: 'PEState_TBT_Send_Attention',
                       0x6E: 'PEState_Received_Attention',
                       0x6F: 'PEState_Send_UVDM',
                       0x70: 'PEState_Receive_UVDM', 0x71: 'PEState_DFP_VDM_BUSY_Response',
                       0x72: 'PEState_DFP_VDM_Identity_Request', 0x73: 'PEState_DFP_VDM_Identity_ACKed',
                       0x74: 'PEState_DFP_VDM_Identity_NAKed',
                       0x75: 'PEState_DFP_VDM_SVIDs_Request', 0x76: 'PEState_DFP_VDM_SVIDs_ACKed',
                       0x77: 'PEState_DFP_VDM_SVIDs_NAKed',
                       0x78: 'PEState_DFP_VDM_Modes_Request', 0x79: 'PEState_DFP_VDM_Modes_ACKed',
                       0x7A: 'PEState_DFP_VDM_Modes_NAKed',
                       0x7B: 'PEState_DFP_VDM_Mode_Entry_Request', 0x7C: 'PEState_DFP_VDM_Mode_Entry_ACKed',
                       0x7D: 'PEState_DFP_VDM_Mode_Entry_NAKed',
                       0x7E: 'PEState_DFP_VDM_Mode_Exit_Request', 0x7F: 'PEState_DFP_VDM_Exit_Mode_ACKed',
                       0x80: 'PEState_DFP_VDM_Attention_Request',
                       0x81: 'PEState_DFP_VDM_Config_Request', 0x82: 'PEState_DFP_VDM_Config_ACK',
                       0x83: 'PEState_DFP_VDM_Config_NAKed',
                       0x84: 'PEState_DFP_VDM_Send_Data', 0x85: 'PEState_DFP_VDM_Send_Data_ACK',
                       0x86: 'PEState_DFP_VDM_Get_Msg',
                       0x87: 'PEState_DFP_VDM_Get_Msg_RCV', 0x88: 'PEState_DFP_VDM_Status_Update',
                       0x89: 'PEState_DFP_VDM_VWStatus_Send',
                       0x8A: 'PEState_DFP_VDM_VWStatus_BUSY', 0x8B: 'PEState_UnUsed_0x8B', 0x8C: 'PEState_UnUsed_0x8C',
                       0x8D: 'PEState_UnUsed_0x8D', 0x8E: 'PEState_UnUsed_0x8E', 0x8F: 'PEState_UnUsed_0x8F',
                       0x90: 'PEState_Vbus_drop_detected_source', 0x91: 'PEState_Vbus_Rise_detected_sink',
                       0x92: 'PEState_VBUS_On',
                       0x93: 'PEState_Trigger_FRS', 0x94: 'PEState_UnUsed_0x94', 0x95: 'PEState_UnUsed_0x95',
                       0x96: 'PESTATE_SRC2PLUG_VDM_Identity_Request', 0x97: 'PESTATE_SRC2PLUG_VDM_Identity_ACKed',
                       0x98: 'PESTATE_SRC2PLUG_VDM_Identity_NAKed',
                       0x99: 'PEState_PLUG_Send_SoftReset_Request', 0x9A: 'PEState_PLUG_Prepare_For_CableReset',
                       0x9B: 'PEState_PLUG_CableReset',
                       0x9C: 'PEState_PLUG_CableReset_Sent', 0x9D: 'PEState_DFP2PLUG_VDM_Identity_Request',
                       0x9E: 'PEState_DFP2PLUG_VDM_Identity_ACKed',
                       0x9F: 'PEState_DFP2PLUG_VDM_Identity_NAKed',
                       0xA0: 'PEState_DFP2PLUG_VDM_SVIDs_Request', 0xA1: 'PEState_DFP2PLUG_VDM_SVIDs_ACKed',
                       0xA2: 'PEState_DFP2PLUG_VDM_SVIDs_NAKed', 0xA3: 'PEState_DFP2PLUG_VDM_Modes_Request',
                       0xA4: 'PEState_DFP2PLUG_VDM_Modes_ACKed',
                       0xA5: 'PEState_DFP2PLUG_VDM_Modes_NAKed', 0xA6: 'PEState_DFP2PLUG_VDM_Mode_Entry_Request',
                       0xA7: 'PEState_DFP2PLUG_VDM_Mode_Entry_ACKed',
                       0xA8: 'PEState_DFP2PLUG_VDM_Mode_Entry_NAKed', 0xA9: 'PEState_DFP2PLUG_VDM_Mode_Exit_Request',
                       0xAA: 'PEState_DFP2PLUG_VDM_Mode_Exit_ACKed', 0xAB: 'PEState_DFP2PLUG_VDM_Mode_Exit_NAKed',
                       0xAC: 'PEState_DFP2PLUG_VDM_DP_Config_Request', 0xAD: 'PEState_DFP2PLUG_VDM_DP_Config_ACK',
                       0xAE: 'PEState_DFP2PLUG_VDM_DP_Config_NACK', 0xAF: 'PEState_DFP2PLUG_VDM_RESERVED_0xAF',
                       0xB0: 'PEState_DFP2PLUG_VDM_RESERVED_0xB0', 0xB1: 'PEState_DFP2PLUG_VDM_RESERVED_0xB1',
                       0xB2: 'PEState_DFP2PLUG_VDM_RESERVED_0xB2',
                       0xB3: 'PEState_DFP2PLUG_VDM_RESERVED_0xB3', 0xB4: 'PEState_DFP2PLUG_VDM_RESERVED_0xB4',
                       0xB5: 'PEState_DFP2PLUG_VDM_RESERVED_0xB5',
                       0xB6: 'PEState_DFP2PLUG_VDM_RESERVED_0xB6', 0xB7: 'PEState_DFP2PLUG_VDM_RESERVED_0xB7',
                       0xB8: 'PEState_Extended_DataMessage_Timeout',
                       0xB9: 'PEState_ExtendedMessage_Timeout', 0xBA: 'PRState_Source_AMS_Tx',
                       0xBB: 'PEState_VconnThermalShutdown',
                       0xBC: 'PEState_PowerPathTsdErrorRecovery', 0xBD: 'PEState_Legacy', 0xBE: 'PEState_Disabled',
                       0xBF: 'PEState_ErrorRecovery',
                       0xC0: 'PRState_SQUELCH_ACTIVE', 0xC1: 'PRState_SQUELCH_IDLE', 0xC2: 'PRState_SOP_RECEIVED',
                       0xC3: 'PRState_SOP_PRIME_RECEIVED',
                       0xC4: 'PRState_SOP_DPRIME_RECEIVED', 0xC5: 'PRState_RX_BUF_RDY',
                       0xC6: 'PRState_HARDRESET_RECEIVED',
                       0xC7: 'PRState_CABLERESET_RECEIVED', 0xC8: 'PRState_TXDONE', 0xC9: 'PRState_INVALID_BIT_TIME',
                       0xCA: 'PRState_SENDING_GOODCRC',
                       0xCB: 'PRState_RECEIVED_GOODCRC', 0xCC: 'PRState_VBUS_MON_HILO', 0xCD: 'PRState_VBUS_OVP',
                       0xCE: 'PEState_DFP_VDM_Reconfigure', 0xCF: 'PEState_Unused_0xCF',
                       0xD0: 'PE_CBL_Ready',
                       0xD1: 'PE_CBL_Send_Identity_SOP_P', 0xD2: 'PE_CBL_Send_SVIDs_SOP_P',
                       0xD3: 'PE_CBL_Send_Modes_SOP_P',
                       0xD4: 'PE_CBL_Evaluate_Mode_Entry_SOP_P', 0xD5: 'PE_CBL_Mode_Entry_ACK_SOP_P',
                       0xD6: 'PE_CBL_Mode_Entry_NAK_SOP_P',
                       0xD7: 'PE_CBL_Mode_Exit_SOP_P', 0xD8: 'PE_CBL_Mode_Exit_ACK_SOP_P',
                       0xFF: '***PEstate_Invalid***'
                       }

INT_state_debug_dict = {0x00: 'PD_SOFT_RESET', 0x01: 'PD_HARD_RESET', 0x02: 'PD_CABLE_RESET',
                        0x03: 'PLUG_INSERT_OR_REMOVAL',
                        0x04: 'PR_SWAP_COMPLETE', 0x05: 'DR_SWAP_COMPLETE', 0x06: 'FR_SWAP_COMPLETE',
                        0x07: 'RDO_RECEIVED_FROM_SINK',
                        0x08: 'BIST_EVENT', 0x09: 'OVERCURRENT', 0x0a: 'ATTENTION_RECEIVED', 0x0b: 'VDM_RECEIVED',
                        0x0c: 'NEW_CONTRACT_AS_CONS',
                        0x0d: 'NEW_CONTRACT_AS_PROV', 0x0e: 'SRC_CAP_MSG_READY', 0x0f: 'SNK_CAP_MSG_READY',
                        0x10: 'LOW_VOLTAGE_WARNING',
                        0x11: 'PR_SWAP_REQUESTED', 0x12: 'DR_SWAP_REQUESTED', 0x13: 'GOTO_MIN_RECEIVED',
                        0x14: 'USB_HOST_PRESENT',
                        0x15: 'USB_HOST_PRESENT_NO_LONGER', 0x16: 'HIGH_VOLTAGE_WARNING', 0x17: 'PP_SWITCH_CHANGED',
                        0x18: 'POWER_STATUS_UPDATE',
                        0x19: 'DATA_STATUS_UPDATE', 0x1a: 'STATUS_UPDATE', 0x1b: 'PD_STATUS_UPDATE',
                        0x1c: 'VCONN_SWAP_COMPLETE',
                        0x1d: 'VCONN_SWAP_REQUESTED', 0x1e: 'CMD_1_COMPLETE', 0x1f: 'CMD_2_COMPLETE',
                        0x20: 'ERROR_DEVICE_INCOMPATIBLE',
                        0x21: 'ERROR_CANNOT_PROVIDE_VOLTAGE_OR_CURRENT',
                        0x22: 'ERROR_CAN_PROVIDE_VOLTAGE_OR_CURRENT_LATER',
                        0x23: 'ERROR_POWER_EVENT_OCCURRED', 0x24: 'ERROR_MISSING_GET_CAP_MESSAGE',
                        0x26: 'ERROR_PROTOCOL_ERROR',
                        0x27: 'ERROR_MESSAGE_DATA', 0x29: 'ERROR_DISCHARGE_FAILED', 0x2a: 'SNK_TRANSITION_COMPLETE',
                        0x2e: 'ERROR_UNABLE_TO_SOURCE',
                        0x2f: 'BIST_MESSAGE_IGNORED', 0x30: 'AM_ENTRY_FAIL', 0x31: 'AM_ENTERED', 0x32: 'VDM_MSG_SENT',
                        0x33: 'DISCOVER_MODE_COMPLETE',
                        0x34: 'EXIT_MODE_COMPLETE', 0x38: 'USER_SVID_ALT_MODE_ENTERED',
                        0x39: 'USER_SVID_ALT_MODE_EXITED',
                        0x3a: 'USER_SVID_ALT_MODE_ATTN_VDM', 0x3b: 'USER_SVID_ALT_MODE_OTHER_VDM',
                        0x3e: 'DP_SID_STATUS_UPDATE',
                        0x3f: 'INTEL_VID_STATUS_UPDATE', 0x40: 'PD3_STATUS_UPDATE', 0x41: 'TX_MEM_BUFFER_EMPTY',
                        0x42: 'RX_MEM_BUFFER_FULL',
                        0x43: 'CUSTOM_D_VDM_ARRIVE', 0x44: 'VDM_ENTERED_MODE', 0x45: 'CUSTOM_D_VDM_MSG_SENT',
                        0x4c: 'FRS_SIGNAL_RECEIVED',
                        0x4d: 'CHUNK_RESPONSE_RECEIVED', 0x4e: 'CHUNK_REQUEST_RECEIVED', 0x4f: 'ALERT_MESSAGE_RECEIVED',
                        0x50: 'PATCH_LOADED',
                        0x51: 'READY_FOR_PATCH'}

SLEEP_state_debug_dict = {0x0: 'SLEEP_STATE_AWAKE', 0x4: 'SLEEP_STATE_SLEEP_LITE_ACE',
                          0x5: 'SLEEP_STATE_SLEEP_DEEP_ACE'}

PROTOCOL_state_debug_dict = {0x30: 'PRState_Source_SinkTxOk', 0x31: 'PRState_Source_SinkTxNG',
                             0x32: 'PRState_Sink_SinkTxOk',
                             0x33: 'PRState_Sink_SinkTxNG', 0xB9: 'PRState_Source_AMS_Tx', 0xBA: 'PRState_Sink_AMS_Tx',
                             0xC0: 'PRState_SQUELCH_ACTIVE',
                             0xC1: 'PRState_SQUELCH_IDLE', 0xC2: 'PRState_SOP_RECEIVED',
                             0xC3: 'PRState_SOP_PRIME_RECEIVED', 0xC4: 'PRState_SOP_DPRIME_RECEIVED',
                             0xC5: 'PRState_RX_BUF_RDY', 0xC6: 'PRState_HARDRESET_RECEIVED',
                             0xC7: 'PRState_CABLERESET_RECEIVED', 0xC8: 'PRState_TXDONE',
                             0xC9: 'PRState_INVALID_BIT_TIME', 0xCA: 'PRState_SENDING_GOODCRC',
                             0xCB: 'PRState_RECEIVED_GOODCRC', 0xCE: 'PRState_SWITCH_ILIM_TRIP'}

VBUS_state_debug_dict = {0x90: 'VBUSState_MON_HI', 0x91: 'VBUSState_MON_LO', 0x92: 'VBUSState_VBUSOn',
                         0xAF: 'VBUSState_UVP_Disabled',
                         0xB0: 'VBUSState_FirstPDOSwitch_Enabled', 0xB1: 'VBUSState_CommonHandler_Exited',
                         0xB2: 'VBUSState_FRS_SIGNAL_RECEIVED',
                         0xB3: 'VBUSState_UVP_CHECKFALLING', 0xB4: 'VBUSState_OVP_ENTERED',
                         0xB5: 'VBUSState_UVP_ENTERED', 0xB6: 'VBUSState_GOOD_RISING',
                         0xB7: 'VBUSState_GOOD_FALLING', 0xCC: 'VBUSState_MON_HILO', 0xCD: 'VBUSState_OVP_UVP'}

listOfModules = ['Type-C', 'BC 1.2', 'USB EP', 'HPD', 'PD', 'INT', 'Sleep', 'Other', 'Protocol', 'VBUS']
listOfModuleDict = [TYPEC_state_debug_dict, BC12_state_debug_dict, {}, {}, PD_state_debug_dict, INT_state_debug_dict,
                    SLEEP_state_debug_dict, {}, PROTOCOL_state_debug_dict, VBUS_state_debug_dict, {}]


# --------------------------------SECTION DEALING WITH HI FIRMWARE UPDATE------------------------------------------

def getBootStatus(handle, device_rw, command, data):
    device_rw.write_reg(handle, 0x09, byteArray(0))
    device_rw.read_reg(handle, 0x09, 2)
    device_rw.write_reg_4cc(handle, 0x08, 'FLrr')
    retVal = verify_cmd_completed(handle, device_rw)
    if retVal != "Success":
        return {'status': -2, 'message': retVal}
    (count, readArray) = device_rw.read_reg(handle, 0x09, 5)
    print readArray
    if len(readArray) >= 4:
        region0Addr = readArray[0] | (readArray[1] << 8) | (readArray[2] << 16) | (readArray[3] << 24)
    else:
        return {'status': -2, 'message': 'Read failure from device'}

    device_rw.write_reg(handle, 0x09, byteArray(1))
    device_rw.write_reg_4cc(handle, 0x08, 'FLrr')
    retVal = verify_cmd_completed(handle, device_rw)
    if retVal != "Success":
        return {'status': -2, 'message': retVal}
    (count, readArray) = device_rw.read_reg(handle, 0x09, 5)
    if len(readArray) >= 4:
        region1Addr = readArray[0] | (readArray[1] << 8) | (readArray[2] << 16) | (readArray[3] << 24)
    else:
        return {'status': -2, 'message': 'Read failure from device'}

    (count, readArray) = device_rw.read_reg(handle, 0x2D, 5)

    if readArray[0] & 0x8 == 0x8:
        spiPresent = True
    else:
        spiPresent = False

    if readArray[1] & 0x1 == 0x1:
        region1Attempted = True
    else:
        region1Attempted = False

    (count, readArray) = device_rw.read_reg(handle, 0x03, 5)

    mode = ''.join([chr(b) for b in readArray])

    if mode == 'APP ':
        booted = True
    else:
        booted = False

    if booted and spiPresent:
        if region1Attempted == True:
            bootRegion = 1
        else:
            bootRegion = 0
    else:
        bootRegion = -1

    return {'status': 0, 'message': 'Success', 'return data': (region0Addr, region1Addr, bootRegion)}


def erase4KBlock(handle, device_rw, command, data):
    startAddr = data['Start Address']
    if startAddr & 0xFFF != 0x0:
        return {'status': -2, 'message': 'Start Address must have a block offset (multiple of 0x1000)'}

    sAByteArray = byteArray(startAddr)
    while len(sAByteArray) < 4:
        sAByteArray.append(0)

    sAByteArray.append(1)

    # erase the block
    device_rw.write_reg(handle, 0x09, sAByteArray)
    device_rw.write_reg_4cc(handle, 0x08, 'FLem')
    retVal = verify_cmd_completed(handle, device_rw)

    if retVal == "Success":
        return {'status': 0, 'message': 'Success'}
    else:
        return {'status': -2, 'message': retVal}


def deleteRegionPointer(handle, device_rw, command, data):
    region = data['Write Data']

    sAByteArray = byteArray(region)

    print ('Delete Region pointer of Region : ' + str(region))

    # erase the pointer
    device_rw.write_reg(handle, 0x09, sAByteArray)
    device_rw.write_reg_4cc(handle, 0x08, 'FLer')
    print " Wait for Command to complete"
    time.sleep(0.02)
    retVal = verify_cmd_completed(handle, device_rw)

    if retVal == "Success":
        return {'status': 0, 'message': 'Success'}
    else:
        return {'status': -2, 'message': retVal}


def write64BBlock(handle, device_rw, command, data):
    startAddr = data['Start Address']
    writeData = data['Write Data']

    print '**********************************************'
    print ('Write Address: ' + hex(startAddr))

    #    print 'Data to Write : ', writeData

    #    print 'Length of Data to Write : ', len(writeData)

    BLOCK_SIZE = 32

    if startAddr % BLOCK_SIZE != 0:
        return {'status': -2, 'message': 'Start Address must be a multiple of %d' % BLOCK_SIZE}

    if len(writeData) != BLOCK_SIZE:
        return {'status': -2,
                'message': 'Write data size must be exactly 32. Received data of size %d' % len(writeData)}

    sAByteArray = byteArray(startAddr)
    while len(sAByteArray) < 4:
        sAByteArray.append(0)

    # pdb.set_trace()

    # set the write pointer
    device_rw.write_reg(handle, 0x09, sAByteArray)
    device_rw.write_reg_4cc(handle, 0x08, 'FLad')
    retVal = verify_cmd_completed(handle, device_rw)

    if retVal != "Success":
        return {'status': -1, 'message': retVal}

    MAX_RETRIES_TRANSFER = 7
    MAX_RETRIES_FLwd = 3
    retriesFLwd = 0
    retriesTransfer = 0
    match = False
    while (retriesFLwd < MAX_RETRIES_FLwd):
        while (retriesTransfer < MAX_RETRIES_TRANSFER) and (match == False):
            (count, matchData) = device_rw.read_reg(handle, 0x03, 5)
            device_rw.write_reg(handle, 0x09, writeData)
            time.sleep(0.1)
            (count, matchData) = device_rw.read_reg(handle, 0x03, 5)
            # print "extra read mode, count: ", count, "test data: ", matchData
            (count, matchData) = device_rw.read_reg(handle, 0x09, BLOCK_SIZE + 1)
            # print 'Contents of readback (DATA register): '
            # print (matchData)
            # print "length of readback data: ", count
            match = True
            # pdb.set_trace()
            for i in range(BLOCK_SIZE):
                if matchData[i] != writeData[i]:
                    match = False
            if match == False:
                retriesTransfer += 1
                print 'Readback of transferred data does NOT match what was written, retries2: ', retriesTransfer
        if retriesTransfer == MAX_RETRIES_TRANSFER:
            # pdb.set_trace()
            print "BAD: read back of transferred data does NOT match what was written"
            return {'status': -3, 'message': 'Flash data transfer failure.  Maximum retries reached.'}

        print "Good readback of transferred data, retries: ", retriesTransfer
        retriesTransfer = 0

        device_rw.write_reg_4cc(handle, 0x08, 'FLwd')
        retVal = verify_cmd_completed(handle, device_rw)
        if retVal != "Success":
            # Command did not complete
            retriesFLwd += 1
            print '%%%%% Flwd command did not complete successfully, retries:', retriesFLwd
        else:
            (count, readArray) = device_rw.read_reg(handle, 0x09, 2)
            if readArray[0] != 0:
                # Command completed in error
                retriesFLwd += 1
                print '***** Flwd returned error code: ', readArray[0], ' retries:', retriesFLwd
            else:
                print 'Flwd completed successfully'
                break

    if retriesFLwd >= MAX_RETRIES_FLwd:
        print 'returning error code retriesFLwd >= MAX_RETRIES_FLwd'
        return {'status': -1, 'message': 'Flash write failure.  Maximum retries reached.'}

    return {'status': 0, 'message': 'Success'}


def read16BBlock(handle, device_rw, command, data):
    startAddr = data['Start Address']

    readAddr = byteArray(startAddr)
    while len(readAddr) < 4:
        readAddr.append(0)

    device_rw.write_reg(handle, 0x09, readAddr)
    device_rw.write_reg_4cc(handle, 0x08, 'FLrd')
    retVal = verify_cmd_completed(handle, device_rw)
    if retVal != "Success":
        return {'status': -2, 'message': retVal}
    (count, readArray) = device_rw.read_reg(handle, 0x09, 17)

    return {'status': 0, 'message': 'Success', 'Read Data': readArray}


def reboot(handle, device_rw, command, data):
    device_rw.write_reg_4cc(handle, 0x08, 'GAID')
    # there is no verification step when rebooting
    return {'status': 0, 'message': 'Reboot request sent'}


def HIFirmwareUpdate(handle, device_rw, command, data):
    # return an array of strings in case someone wants to organize by line
    if command == 'getBootStatus':
        return getBootStatus(handle, device_rw, command, data)

    if command == 'erase4KBlock':
        return erase4KBlock(handle, device_rw, command, data)

    if command == 'write64BBlock':
        return write64BBlock(handle, device_rw, command, data)

    if command == 'read16BBlock':
        return read16BBlock(handle, device_rw, command, data)

    if command == 'deleteRegionPointer':
        return deleteRegionPointer(handle, device_rw, command, data)

    if command == 'reboot':
        return reboot(handle, device_rw, command, data)

    return {'status': -1, 'message': 'Command not recognized'}


# -----------------------------------------------------------------------------------------------------------------------


templateDevice = "TPS65987D ROM 1.3"
templateVersion = "3.04"

# these must exactly match the preexisting names defined in the tool or they will not be shown
acHeaderListOfFields = [
    "Customer Version",
    "XID",
    #        "Unlock Code", \
    #        "Protection Flags" \
]

hideShareConfigs = True
hideNumDevices = True

# String Table Definitions
# stringTableListofDict = [  ]


zeroOneList = ['0', '1']
i2cAddrList = ['0 (R1/R2 = 0.00-0.18)',
               '1 (R1/R2 = 0.20-0.38)',
               '2 (R1/R2 = 0.40-0.58)',
               '3 (R1/R2 = 0.60-1.00)',
               ]


def i2cAddrValueFromAddr(strapping):
    return (strapping) & 0x3


# 1-byte selection bitfield if 3 bits in address
# 4-byte selection bitfield if 5 bits in address
numBitsDeviceAddress = 3

deviceStrappingListOfDict = [
    {'name': 'I2C_ADDR', 'type': 'pulldown', 'option list': i2cAddrList, 'value function': i2cAddrValueFromAddr},
    ]


def indexOfName(name, deviceStrappingValuesListOfDict):
    for (i, record) in enumerate(deviceStrappingValuesListOfDict):
        if record['name'] == name:
            return i

    return None


# deviceStrappingValuesListOfDict
# list of Dict [{'name' : name, 'value' : value},]
def tps65988_addr_function(portNum, deviceStrappingValuesListOfDict):
    i2cAddrValue = deviceStrappingValuesListOfDict[indexOfName('I2C_ADDR', deviceStrappingValuesListOfDict)]['value']

    assert portNum >= 0
    assert portNum <= 1

    addr = 0
    addr |= i2cAddrValue
    addr |= portNum << 2

    return addr


# calculate I2C1 address from deviceStrappingValuesListOfDict
def tps65988_addr_function_i2c1(portNum, deviceStrappingValuesListOfDict):
    i2cAddrValue = deviceStrappingValuesListOfDict[indexOfName('I2C_ADDR', deviceStrappingValuesListOfDict)]['value']

    assert portNum >= 0
    assert portNum <= 1

    addr = 0
    addr |= i2cAddrValue
    addr |= portNum << 2

    addr |= 0x20

    return addr


# calculate I2C2 address from deviceStrappingValuesListOfDict
def tps65988_addr_function_i2c2(portNum, deviceStrappingValuesListOfDict):
    assert portNum >= 0
    assert portNum <= 1

    if portNum == 0:
        addr = 0x38
    else:
        addr = 0x3F

    return addr


devicePortsListOfDict = [
    {'name': 'Port1', 'port value': 0, 'addr function': tps65988_addr_function,
     'addr function I2C1': tps65988_addr_function_i2c1, 'addr function I2C2': tps65988_addr_function_i2c2,
     'selectionBitmask': 0x1},
    ]

virtualStrappingListOfDict = [
    {'name': 'I2C_ADDR', 'type': 'pulldown', 'option list': i2cAddrList},
    ]

virtualStrappingAddrFunction = tps65988_addr_function

# device definitions
allAceDevice = register_class.cDevice(
    {'I2C address': 0x00, 'strapping': deviceStrappingListOfDict, 'ports': devicePortsListOfDict})
allAceDevice.addRegister(cCustUse_0x06_register())
allAceDevice.configureDerivedFields()
allAceDevice.hide()

NUM_PHYSICAL_DEVICES = 1
oneAceDeviceList = []
for i in range(NUM_PHYSICAL_DEVICES):
    device = register_class.cDevice(
        {'I2C address': i, 'strapping': deviceStrappingListOfDict, 'ports': devicePortsListOfDict})
    # device.setPDDumpFunction(pdStateDump)
    # device.setHIFirmwareUpdateFunction(HIFirmwareUpdate)
    device.addRegister(cVID_0x00_register())
    device.addRegister(cDID_0x01_register())
    device.addRegister(cMode_0x03_register())
    device.addRegister(cCustUse_0x06_register())
    mask1 = cIntMask1_0x16_register()
    mask1.hide()
    device.addRegister(mask1)
    mask2 = cIntMask2_0x17_register()
    mask2.hide()
    device.addRegister(mask2)
    device.addRegister(cStatus_0x1A_register())
    device.addRegister(cPowerPathStatus_0x26_register())
    device.addRegister(cGlobalSysConfig_0x27_register())
    device.addRegister(cPortConfig_0x28_register())
    device.addRegister(cPortControl_0x29_register())
    device.addRegister(cBootFlags_0x2D_register())
    device.addRegister(cRxSrcCap_0x30_register())
    device.addRegister(cRxSinkCap_0x31_register())
    device.addRegister(cTxSrcCap_0x32_register())
    device.addRegister(cTxSinkCap_0x33_register())
    device.addRegister(cActiveContractPDO_0x34_register())
    device.addRegister(cActiveContractRDO_0x35_register())
    ANEG = cAutoNegSink_0x37_register()
    ANEG.hide()
    device.addRegister(ANEG)
    altEntryQueue = cAltModeEntryQueue_0x38_register()
    altEntryQueue.hide()
    device.addRegister(altEntryQueue)
    device.addRegister(cPowerStatus_0x3F_register())
    device.addRegister(cPDStatus_0x40_register())
    device.addRegister(cPD3_Status_0x41_register())
    device.addRegister(cPD3Config_0x42_register())
    EDELAY = cEventDelay_0x43_register()
    EDELAY.hide()
    device.addRegister(EDELAY)
    device.addRegister(cTxIDO_0x47_register())
    device.addRegister(cDisplayPortCapabilities_0x51_register())
    device.addRegister(cDPSIDStatus_0x58_register())
    device.addRegister(cIntVidConf_0x52_register())
    device.addRegister(cIntelVIDStatus_0x59_register())
    miscCont = cMiscellaneousControl_0x55_register()
    miscCont.showRawOnly()
    device.addRegister(miscCont)
    device.addRegister(cIOConfig_0x5C_register())
    binIndex = cBinaryIndices_0x62_register()
    binIndex.hide()
    device.addRegister(binIndex)
    i2cMast = cI2CMaster_0x64_register()
    i2cMast.hide()
    device.addRegister(i2cMast)
    HWControl = cHWcontrol_0x6B_register()
    HWControl.hide()
    device.addRegister(HWControl)
    sleep = cSleepControl_0x70_register()
    sleep.hide()
    device.addRegister(sleep)
    device.addRegister(cGPIOStatus_0x72_register())
    device.addRegister(cRXMIDBSOP_0x71_register())
    device.addRegister(cTxMidbSop_0x73_register())
    device.addRegister(cRXSCEDB_0x76_register())
    device.addRegister(cTxSCEDB_0x77_register())

    device.addHIFunction(function_class.cRawRead())
    device.addHIFunction(function_class.cRawWrite())
    device.addHIFunction(cDBfg())
    # device.addHIFunction(cABRT())
    device.addHIFunction(cGaid())
    device.addHIFunction(cGAID())
    device.addHIFunction(cHRST())
    device.addHIFunction(cCRST())
    device.addHIFunction(cGSkC())
    device.addHIFunction(cGSrC())
    device.addHIFunction(cSSrC())
    # device.addHIFunction(cSRDO())
    device.addHIFunction(cSWSk())
    device.addHIFunction(cSWSr())
    device.addHIFunction(cSWDF())
    device.addHIFunction(cSWUF())
    device.addHIFunction(cSWVC())
    # device.addHIFunction(cSRDY())
    # device.addHIFunction(cAMEn())
    # device.addHIFunction(cAMEx())
    # device.addHIFunction(cANEG())
    # device.addHIFunction(cAMDs())
    # device.addHIFunction(cGPie())
    # device.addHIFunction(cGPoe())
    # device.addHIFunction(cGPsh())
    # device.addHIFunction(cGPsl())
    # device.addHIFunction(cVDMs())
    # device.addHIFunction(cPTCq())
    # device.addHIFunction(cADCs())
    # device.addHIFunction(cGSCX())
    # device.addHIFunction(cALRT())
    # device.addHIFunction(cGSSt())
    # device.addHIFunction(cGBaS())
    # device.addHIFunction(cGBaC())
    # device.addHIFunction(cGMfI())
    # device.addHIFunction(cLOCK())
    # device.addHIFunction(cMEMr())
    # device.addHIFunction(cMEMw())
    # device.addHIFunction(cI2Cr())
    # device.addHIFunction(cI2Cw())

    device.configureDerivedFields()
    oneAceDeviceList.append(device)

ACE_register_definition_metadata_json_delimiter{
    "virtual device list of dict": [], 
    "firmware filename": "C:\\Program Files\\Texas Instruments\\TPS65981_2_6_7_8 Application Customization 6.1.4\\tps6598x-application-customization\\TPS65987_88_F707_10_10.bin", 
    "device list of dict": [
        {
            "show": 1, 
            "name": "Device 1", 
            "addr": 0
        }
    ], 
    "configuration values": "{\"meta\": {\"project\": 1, \"version\": 1}, \"data\": {\"every_ace\": [{\"register\": 6, \"data\": [8, 2, 0, 0, 0, 0, 0, 0]}], \"header\": {\"usb_if_xid\": 0, \"unlock_code\": \"CST1\", \"customer_version\": 0, \"protection_flags\": 250}, \"bin_table\": [], \"strings\": [], \"selected_ace\": [{\"rights\": 0, \"register\": 0, \"data\": [40, 0, 0, 0], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 1, \"data\": [65, 67, 69, 76], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 6, \"data\": [0, 0, 0, 0, 0, 0, 0, 0], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 22, \"data\": [8, 0, 0, 2, 0, 0, 0, 0, 0, 0, 3], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 23, \"data\": [8, 0, 0, 2, 0, 0, 0, 0, 0, 0, 3], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 39, \"data\": [1, 0, 10, 0, 0, 0, 128, 0, 20, 20, 0, 0, 0, 120], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 40, \"data\": [202, 88, 182, 223, 1], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 41, \"data\": [194, 84, 17, 64], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 50, \"data\": [1, 252, 0, 0, 85, 0, 0, 0, 90, 144, 1, 5, 44, 209, 2, 0, 44, 177, 4, 0, 44, 65, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 144, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 51, \"data\": [4, 90, 144, 1, 54, 4, 177, 4, 0, 200, 192, 3, 0, 44, 209, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 44, 105, 1, 64, 44, 105, 1, 64, 44, 105, 1, 64, 44, 105, 1, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 55, \"data\": [111, 61, 61, 0, 0, 0, 0, 0, 200, 144, 1, 0], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 56, \"data\": [1, 255, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 66, \"data\": [26, 4, 0, 0], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 67, \"data\": [25, 25, 25, 25, 25, 25, 50, 0, 0], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 71, \"data\": [3, 81, 4, 64, 196, 0, 124, 2, 32, 0, 7, 52, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 124, 2, 32, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 81, \"data\": [3, 71, 28, 12, 25, 0, 0], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 82, \"data\": [0, 5, 0, 0, 0, 0, 0, 0], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 85, \"data\": [4], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 92, \"data\": [7, 128, 51, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 39, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 92, 9, 0, 0, 10, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 98, \"data\": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 100, \"data\": [0, 0, 0, 0, 0, 0, 0, 0], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 107, \"data\": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 112, \"data\": [0], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 115, \"data\": [81, 4, 52, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 119, \"data\": [81, 4, 52, 18, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4], \"offset\": 0, \"address\": [15]}]}}", 
    "devices use same config": true, 
    "debug settings": {
        "adapter": "TIVA"
    }, 
    "template properties": {
        "Config Question List": [
            {
                "Question": "What is the port type of the design?", 
                "Answer List": [
                    {
                        "Answer": "Upstream Facing Port (UFP) Only", 
                        "configuration updates": "{\"data\": {\"selected_ace\": [{\"rights\": 0, \"register\": 39, \"data\": [2], \"offset\": 2, \"address\": [15]}, {\"rights\": 0, \"register\": 40, \"data\": [200], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 41, \"data\": [2, 4], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 50, \"data\": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 51, \"data\": [2, 90, 144, 1, 54, 90, 144, 1, 153, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 44, 105, 1, 64, 44, 105, 1, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 81, \"data\": [69], \"offset\": 1, \"address\": [15]}, {\"rights\": 0, \"register\": 81, \"data\": [17], \"offset\": 4, \"address\": [15]}, {\"rights\": 0, \"register\": 92, \"data\": [0, 0], \"offset\": 1, \"address\": [15]}, {\"rights\": 0, \"register\": 92, \"data\": [0, 0], \"offset\": 5, \"address\": [15]}, {\"rights\": 0, \"register\": 92, \"data\": [0, 0], \"offset\": 9, \"address\": [15]}, {\"rights\": 0, \"register\": 92, \"data\": [0, 0], \"offset\": 13, \"address\": [15]}, {\"rights\": 0, \"register\": 92, \"data\": [0, 0], \"offset\": 21, \"address\": [15]}, {\"rights\": 0, \"register\": 92, \"data\": [0, 0], \"offset\": 25, \"address\": [15]}, {\"rights\": 0, \"register\": 92, \"data\": [0, 0], \"offset\": 29, \"address\": [15]}, {\"rights\": 0, \"register\": 92, \"data\": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \"offset\": 40, \"address\": [15]} ]}}"
                    }, 
                    {
                        "Answer": "Downstream Facing Port (DFP) Only", 
                        "configuration updates": "{\"data\": {\"selected_ace\": [{\"rights\": 0, \"register\": 39, \"data\": [8], \"offset\": 2, \"address\": [15]}, {\"rights\": 0, \"register\": 40, \"data\": [201], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 41, \"data\": [2, 4], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 50, \"data\": [4, 252, 0, 0, 85, 0, 0, 0, 44, 145, 1, 1, 44, 209, 2, 0, 44, 177, 4, 0, 44, 65, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 144, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 51, \"data\": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 92, \"data\": [192, 18], \"offset\": 1, \"address\": [15]}, {\"rights\": 0, \"register\": 81, \"data\": [70], \"offset\": 1, \"address\": [15]}, {\"rights\": 0, \"register\": 81, \"data\": [11], \"offset\": 4, \"address\": [15]}, {\"rights\": 0, \"register\": 92, \"data\": [0, 0], \"offset\": 5, \"address\": [15]}, {\"rights\": 0, \"register\": 92, \"data\": [0, 0], \"offset\": 9, \"address\": [15]}, {\"rights\": 0, \"register\": 92, \"data\": [0, 0], \"offset\": 13, \"address\": [15]}, {\"rights\": 0, \"register\": 92, \"data\": [0, 0], \"offset\": 21, \"address\": [15]}, {\"rights\": 0, \"register\": 92, \"data\": [0, 0], \"offset\": 25, \"address\": [15]}, {\"rights\": 0, \"register\": 92, \"data\": [0, 0], \"offset\": 29, \"address\": [15]}, {\"rights\": 0, \"register\": 92, \"data\": [0, 0, 0, 0, 0, 0, 7, 8, 0, 9, 0, 0, 10, 0], \"offset\": 40, \"address\": [15]}]}}"
                    }, 
                    {
                        "Answer": "Dual Role Port (DRP), prefers data host", 
                        "configuration updates": "{\"data\": {\"selected_ace\": [{\"rights\": 0, \"register\": 39, \"data\": [10], \"offset\": 2, \"address\": [15]}, {\"rights\": 0, \"register\": 40, \"data\": [202], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 41, \"data\": [82, 196], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 50, \"data\": [1, 0, 0, 0, 1, 0, 0, 0, 44, 145, 1, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 144, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 51, \"data\": [2, 90, 144, 1, 54, 90, 144, 1, 153, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 44, 105, 1, 64, 44, 105, 1, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 81, \"data\": [70], \"offset\": 1, \"address\": [15]}, {\"rights\": 0, \"register\": 81, \"data\": [11], \"offset\": 4, \"address\": [15]}, {\"rights\": 0, \"register\": 92, \"data\": [0, 0], \"offset\": 1, \"address\": [15]}, {\"rights\": 0, \"register\": 92, \"data\": [0, 0], \"offset\": 5, \"address\": [15]}, {\"rights\": 0, \"register\": 92, \"data\": [0, 0], \"offset\": 9, \"address\": [15]}, {\"rights\": 0, \"register\": 92, \"data\": [0, 0], \"offset\": 13, \"address\": [15]}, {\"rights\": 0, \"register\": 92, \"data\": [0, 0], \"offset\": 21, \"address\": [15]}, {\"rights\": 0, \"register\": 92, \"data\": [0, 0], \"offset\": 25, \"address\": [15]}, {\"rights\": 0, \"register\": 92, \"data\": [0, 0], \"offset\": 29, \"address\": [15]}, {\"rights\": 0, \"register\": 92, \"data\": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \"offset\": 40, \"address\": [15]}]}}"
                    }, 
                    {
                        "Answer": "Dual Role Port (DRP), prefers power source", 
                        "configuration updates": "{\"data\": {\"selected_ace\": [{\"rights\": 0, \"register\": 39, \"data\": [10], \"offset\": 2, \"address\": [15]}, {\"rights\": 0, \"register\": 40, \"data\": [202], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 41, \"data\": [194, 84], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 50, \"data\": [4, 252, 0, 0, 85, 0, 0, 0, 44, 145, 1, 1, 44, 209, 2, 0, 44, 177, 4, 0, 44, 65, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 144, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 51, \"data\": [2, 90, 144, 1, 54, 90, 144, 1, 153, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 44, 105, 1, 64, 44, 105, 1, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \"offset\": 0, \"address\": [15]}, {\"rights\": 0, \"register\": 81, \"data\": [69], \"offset\": 1, \"address\": [15]}, {\"rights\": 0, \"register\": 81, \"data\": [17], \"offset\": 4, \"address\": [15]}, {\"rights\": 0, \"register\": 92, \"data\": [192, 18], \"offset\": 1, \"address\": [15]}, {\"rights\": 0, \"register\": 92, \"data\": [0, 0], \"offset\": 5, \"address\": [15]}, {\"rights\": 0, \"register\": 92, \"data\": [0, 0], \"offset\": 9, \"address\": [15]}, {\"rights\": 0, \"register\": 92, \"data\": [0, 0], \"offset\": 13, \"address\": [15]}, {\"rights\": 0, \"register\": 92, \"data\": [0, 0], \"offset\": 21, \"address\": [15]}, {\"rights\": 0, \"register\": 92, \"data\": [0, 0], \"offset\": 25, \"address\": [15]}, {\"rights\": 0, \"register\": 92, \"data\": [0, 0], \"offset\": 29, \"address\": [15]}, {\"rights\": 0, \"register\": 92, \"data\": [0, 0, 0, 0, 0, 0, 7, 8, 0, 9, 0, 0, 10, 0], \"offset\": 40, \"address\": [15]}]}}"
                    }
                ]
            }
        ], 
        "Description": "TPS65987D Standard\n\nConfigured for TPS65988 EVM with 87D EVM factory-default jumper settings.  May be configured for UFP, DFP or DRP, with or without Thunderbolt support. based on answers to user questions.  Uses PP2 for Sourcing when applicable.  Sources 5, 9, 15 and 20V using an adjustable voltage regulator when applicable. \n\nThis is a standard customer template that exposes the most commonly used settings.  Hidden settings are either set to default values or derived from exposed user inputs.  For access to all host interface fields, use the advanced customer template.  Note that you may begin with a standard customer template and import your settings into the advanced template later.\n\n", 
        "Template Version": "6.1.4", 
        "Port Type": "All", 
        "Mux Type": "All", 
        "Category Type": "Standard Customer Project", 
        "Device Type": "TPS65987DDH", 
        "Display As": "TPS65987DDH (Standard)", 
        "Question List": [
            {
                "Answer": "TPS65987DDH", 
                "Question": "Which device are you using?"
            }, 
            {
                "Answer": "TPS65987DDH (ROM 1.6)", 
                "Question": "Which ROM version are you using?"
            }, 
            {
                "Answer": "Standard (Recommended)", 
                "Question": "Which template type do you want to start with?"
            }, 
            {
                "Answer": "87DDH EVM or custom hardware", 
                "Question": "Which hardware platform are you using?"
            }
        ]
    }
}
